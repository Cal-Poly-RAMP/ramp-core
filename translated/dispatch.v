//-------------------------------------------------------------------------
// Dispatch.v
//-------------------------------------------------------------------------
// This file is generated by PyMTL SystemVerilog translation pass.

// PyMTL BitStruct MicroOp__38e2b09b91e4b306 Definition
typedef struct packed {
  logic [2:0] optype;
  logic [31:0] inst;
  logic [31:0] pc;
  logic [0:0] valid;
  logic [4:0] lrd;
  logic [4:0] lrs1;
  logic [4:0] lrs2;
  logic [5:0] prd;
  logic [5:0] prs1;
  logic [5:0] prs2;
  logic [5:0] stale;
  logic [31:0] imm;
  logic [1:0] issue_unit;
  logic [1:0] funct_unit;
  logic [3:0] funct_op;
  logic [0:0] branch_taken;
  logic [7:0] br_mask;
  logic [2:0] br_tag;
  logic [4:0] rob_idx;
  logic [3:0] mem_q_idx;
} MicroOp__38e2b09b91e4b306;

// PyMTL BitStruct DualMicroOp__93e30b890d7542af Definition
typedef struct packed {
  MicroOp__38e2b09b91e4b306 uop1;
  MicroOp__38e2b09b91e4b306 uop2;
} DualMicroOp__93e30b890d7542af;

// PyMTL Component SingleDispatch Definition
// At /Users/curtisbucher/Desktop/ramp-core/src/cl/dispatch.py

module SingleDispatch_noparam
(
  input  logic [0:0] clk ,
  input  MicroOp__38e2b09b91e4b306 in_ ,
  input  logic [3:0] mem_q_idx ,
  input  logic [0:0] reset ,
  input  logic [4:0] rob_idx ,
  output MicroOp__38e2b09b91e4b306 to_branch_issue ,
  output MicroOp__38e2b09b91e4b306 to_int_issue ,
  output MicroOp__38e2b09b91e4b306 to_mem_issue ,
  output MicroOp__38e2b09b91e4b306 to_rob 
);
  localparam logic [0:0] __const__INT_ISSUE_UNIT  = 1'd1;
  localparam logic [167:0] __const__NO_OP  = 168'd0;
  localparam logic [1:0] __const__MEM_ISSUE_UNIT  = 2'd2;
  localparam logic [1:0] __const__BRANCH_FUNCT_UNIT  = 2'd3;

  // PyMTL Update Block Source
  // At /Users/curtisbucher/Desktop/ramp-core/src/cl/dispatch.py:78
  // @update
  // def conditional_dispatch():
  //     s.to_rob @= s.in_
  
  always_comb begin : conditional_dispatch
    to_rob = in_;
  end

  // PyMTL Update Block Source
  // At /Users/curtisbucher/Desktop/ramp-core/src/cl/dispatch.py:82
  // @update
  // def issue():
  //     if s.in_.issue_unit == INT_ISSUE_UNIT:
  //         s.to_int_issue @= s.in_
  //         s.to_int_issue.rob_idx @= s.rob_idx
  //         s.to_int_issue.mem_q_idx @= 0
  //     else:
  //         s.to_int_issue @= NO_OP
  //     if s.in_.issue_unit == MEM_ISSUE_UNIT:
  //         s.to_mem_issue @= s.in_
  //         s.to_mem_issue.rob_idx @= s.rob_idx
  //         s.to_mem_issue.mem_q_idx @= s.mem_q_idx
  //     else:
  //         s.to_mem_issue @= NO_OP
  //     if s.in_.funct_unit == BRANCH_FUNCT_UNIT:
  //         s.to_branch_issue @= s.in_
  //         s.to_branch_issue.rob_idx @= s.rob_idx
  //         s.to_branch_issue.mem_q_idx @= 0
  //     else:
  //         s.to_branch_issue @= NO_OP
  
  always_comb begin : issue
    if ( in_.issue_unit == 2'( __const__INT_ISSUE_UNIT ) ) begin
      to_int_issue = in_;
      to_int_issue.rob_idx = rob_idx;
      to_int_issue.mem_q_idx = 4'd0;
    end
    else
      to_int_issue = 168'( __const__NO_OP );
    if ( in_.issue_unit == 2'( __const__MEM_ISSUE_UNIT ) ) begin
      to_mem_issue = in_;
      to_mem_issue.rob_idx = rob_idx;
      to_mem_issue.mem_q_idx = mem_q_idx;
    end
    else
      to_mem_issue = 168'( __const__NO_OP );
    if ( in_.funct_unit == 2'( __const__BRANCH_FUNCT_UNIT ) ) begin
      to_branch_issue = in_;
      to_branch_issue.rob_idx = rob_idx;
      to_branch_issue.mem_q_idx = 4'd0;
    end
    else
      to_branch_issue = 168'( __const__NO_OP );
  end

endmodule


// PyMTL Component Dispatch Definition
// Full name: Dispatch_noparam
// At /Users/curtisbucher/Desktop/ramp-core/src/cl/dispatch.py

module Dispatch
(
  input  logic [0:0] clk ,
  input  DualMicroOp__93e30b890d7542af in_ ,
  input  logic [3:0] mem_q_tail ,
  input  logic [0:0] reset ,
  input  logic [4:0] rob_idx ,
  output DualMicroOp__93e30b890d7542af to_branch_issue ,
  output DualMicroOp__93e30b890d7542af to_int_issue ,
  output DualMicroOp__93e30b890d7542af to_mem_issue ,
  output DualMicroOp__93e30b890d7542af to_rob 
);
  localparam logic [1:0] __const__MEM_ISSUE_UNIT  = 2'd2;
  //-------------------------------------------------------------
  // Component uop1_dispatch
  //-------------------------------------------------------------

  logic [0:0] uop1_dispatch__clk;
  MicroOp__38e2b09b91e4b306 uop1_dispatch__in_;
  logic [3:0] uop1_dispatch__mem_q_idx;
  logic [0:0] uop1_dispatch__reset;
  logic [4:0] uop1_dispatch__rob_idx;
  MicroOp__38e2b09b91e4b306 uop1_dispatch__to_branch_issue;
  MicroOp__38e2b09b91e4b306 uop1_dispatch__to_int_issue;
  MicroOp__38e2b09b91e4b306 uop1_dispatch__to_mem_issue;
  MicroOp__38e2b09b91e4b306 uop1_dispatch__to_rob;

  SingleDispatch_noparam uop1_dispatch
  (
    .clk( uop1_dispatch__clk ),
    .in_( uop1_dispatch__in_ ),
    .mem_q_idx( uop1_dispatch__mem_q_idx ),
    .reset( uop1_dispatch__reset ),
    .rob_idx( uop1_dispatch__rob_idx ),
    .to_branch_issue( uop1_dispatch__to_branch_issue ),
    .to_int_issue( uop1_dispatch__to_int_issue ),
    .to_mem_issue( uop1_dispatch__to_mem_issue ),
    .to_rob( uop1_dispatch__to_rob )
  );

  //-------------------------------------------------------------
  // End of component uop1_dispatch
  //-------------------------------------------------------------

  //-------------------------------------------------------------
  // Component uop2_dispatch
  //-------------------------------------------------------------

  logic [0:0] uop2_dispatch__clk;
  MicroOp__38e2b09b91e4b306 uop2_dispatch__in_;
  logic [3:0] uop2_dispatch__mem_q_idx;
  logic [0:0] uop2_dispatch__reset;
  logic [4:0] uop2_dispatch__rob_idx;
  MicroOp__38e2b09b91e4b306 uop2_dispatch__to_branch_issue;
  MicroOp__38e2b09b91e4b306 uop2_dispatch__to_int_issue;
  MicroOp__38e2b09b91e4b306 uop2_dispatch__to_mem_issue;
  MicroOp__38e2b09b91e4b306 uop2_dispatch__to_rob;

  SingleDispatch_noparam uop2_dispatch
  (
    .clk( uop2_dispatch__clk ),
    .in_( uop2_dispatch__in_ ),
    .mem_q_idx( uop2_dispatch__mem_q_idx ),
    .reset( uop2_dispatch__reset ),
    .rob_idx( uop2_dispatch__rob_idx ),
    .to_branch_issue( uop2_dispatch__to_branch_issue ),
    .to_int_issue( uop2_dispatch__to_int_issue ),
    .to_mem_issue( uop2_dispatch__to_mem_issue ),
    .to_rob( uop2_dispatch__to_rob )
  );

  //-------------------------------------------------------------
  // End of component uop2_dispatch
  //-------------------------------------------------------------

  // PyMTL Update Block Source
  // At /Users/curtisbucher/Desktop/ramp-core/src/cl/dispatch.py:38
  // @update
  // def update_rob_idx():
  //     s.uop1_dispatch.rob_idx @= s.rob_idx
  //     s.uop2_dispatch.rob_idx @= s.rob_idx + 1
  // 
  //     s.uop1_dispatch.mem_q_idx @= 0
  //     s.uop2_dispatch.mem_q_idx @= 0
  //     # uop1 and uop2 in buffer
  //     if (s.in_.uop1.issue_unit == MEM_ISSUE_UNIT) & (
  //         s.in_.uop2.issue_unit == MEM_ISSUE_UNIT
  //     ):
  //         s.uop1_dispatch.mem_q_idx @= s.mem_q_tail - 2
  //         s.uop2_dispatch.mem_q_idx @= s.mem_q_tail - 1
  //     # uop1 is in ls buffer
  //     elif s.in_.uop1.issue_unit == MEM_ISSUE_UNIT:
  //         s.uop1_dispatch.mem_q_idx @= s.mem_q_tail - 1
  //     # uop2 is in ls buffer
  //     elif s.in_.uop2.issue_unit == MEM_ISSUE_UNIT:
  //         s.uop2_dispatch.mem_q_idx @= s.mem_q_tail - 1
  
  always_comb begin : update_rob_idx
    uop1_dispatch__rob_idx = rob_idx;
    uop2_dispatch__rob_idx = rob_idx + 5'd1;
    uop1_dispatch__mem_q_idx = 4'd0;
    uop2_dispatch__mem_q_idx = 4'd0;
    if ( ( in_.uop1.issue_unit == 2'( __const__MEM_ISSUE_UNIT ) ) & ( in_.uop2.issue_unit == 2'( __const__MEM_ISSUE_UNIT ) ) ) begin
      uop1_dispatch__mem_q_idx = mem_q_tail - 4'd2;
      uop2_dispatch__mem_q_idx = mem_q_tail - 4'd1;
    end
    else if ( in_.uop1.issue_unit == 2'( __const__MEM_ISSUE_UNIT ) ) begin
      uop1_dispatch__mem_q_idx = mem_q_tail - 4'd1;
    end
    else if ( in_.uop2.issue_unit == 2'( __const__MEM_ISSUE_UNIT ) ) begin
      uop2_dispatch__mem_q_idx = mem_q_tail - 4'd1;
    end
  end

  assign uop1_dispatch__clk = clk;
  assign uop1_dispatch__reset = reset;
  assign uop1_dispatch__in_ = in_.uop1;
  assign to_rob.uop1 = uop1_dispatch__to_rob;
  assign to_int_issue.uop1 = uop1_dispatch__to_int_issue;
  assign to_mem_issue.uop1 = uop1_dispatch__to_mem_issue;
  assign to_branch_issue.uop1 = uop1_dispatch__to_branch_issue;
  assign uop2_dispatch__clk = clk;
  assign uop2_dispatch__reset = reset;
  assign uop2_dispatch__in_ = in_.uop2;
  assign to_rob.uop2 = uop2_dispatch__to_rob;
  assign to_int_issue.uop2 = uop2_dispatch__to_int_issue;
  assign to_mem_issue.uop2 = uop2_dispatch__to_mem_issue;
  assign to_branch_issue.uop2 = uop2_dispatch__to_branch_issue;

endmodule
