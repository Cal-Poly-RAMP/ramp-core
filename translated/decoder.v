//-------------------------------------------------------------------------
// SingleInstDecode.v
//-------------------------------------------------------------------------
// This file is generated by PyMTL SystemVerilog translation pass.

// PyMTL BitStruct PhysicalRegs__prd_6__prs1_6__prs2_6__stale_6 Definition
typedef struct packed {
  logic [5:0] prd;
  logic [5:0] prs1;
  logic [5:0] prs2;
  logic [5:0] stale;
} PhysicalRegs__prd_6__prs1_6__prs2_6__stale_6;

// PyMTL BitStruct PRegBusy__prs1_1__prs2_1 Definition
typedef struct packed {
  logic [0:0] prs1;
  logic [0:0] prs2;
} PRegBusy__prs1_1__prs2_1;

// PyMTL BitStruct MicroOp__c9b3dc01a081cc30 Definition
typedef struct packed {
  logic [5:0] uop_type;
  logic [31:0] inst;
  logic [7:0] pc;
  logic [0:0] valid;
  logic [4:0] lrd;
  logic [4:0] lrs1;
  logic [4:0] lrs2;
  logic [5:0] prd;
  logic [5:0] prs1;
  logic [5:0] prs2;
  logic [5:0] stale;
  logic [0:0] prs1_busy;
  logic [0:0] prs2_busy;
  logic [31:0] imm;
  logic [1:0] issue_unit;
  logic [1:0] fu_unit;
  logic [1:0] fu_op;
  logic [4:0] rob_idx;
} MicroOp__c9b3dc01a081cc30;

// PyMTL Component SingleInstDecode Definition
// Full name: SingleInstDecode_noparam
// At /Users/curtisbucher/Desktop/ramp-core/src/cl/decoder.py

module SingleInstDecode
(
  input  logic [0:0] clk ,
  input  logic [0:0] idx ,
  input  logic [31:0] inst ,
  input  logic [7:0] pc ,
  input  PhysicalRegs__prd_6__prs1_6__prs2_6__stale_6 pregs ,
  input  PRegBusy__prs1_1__prs2_1 pregs_busy ,
  input  logic [0:0] reset ,
  output MicroOp__c9b3dc01a081cc30 uop 
);
  localparam logic [5:0] __const__RTYPE_OPCODE  = 6'd51;
  localparam logic [4:0] __const__ITYPE_OPCODE1  = 5'd19;
  localparam logic [1:0] __const__ITYPE_OPCODE2  = 2'd3;
  localparam logic [6:0] __const__ITYPE_OPCODE3  = 7'd103;
  localparam logic [5:0] __const__STYPE_OPCODE  = 6'd35;
  localparam logic [6:0] __const__BTYPE_OPCODE  = 7'd99;
  localparam logic [5:0] __const__UTYPE_OPCODE1  = 6'd55;
  localparam logic [4:0] __const__UTYPE_OPCODE2  = 5'd23;
  localparam logic [6:0] __const__JTYPE_OPCODE  = 7'd111;
  localparam logic [6:0] __const__CSRTYPE_OPCODE  = 7'd115;
  localparam logic [0:0] __const__INT_ISSUE_UNIT  = 1'd1;
  localparam logic [1:0] __const__MEM_ISSUE_UNIT  = 2'd2;
  logic [6:0] __tmpvar__decode_comb_opcode;
  logic [0:0] __tmpvar__decode_comb_Rtype;
  logic [0:0] __tmpvar__decode_comb_Itype;
  logic [0:0] __tmpvar__decode_comb_Stype;
  logic [0:0] __tmpvar__decode_comb_Btype;
  logic [0:0] __tmpvar__decode_comb_Utype;
  logic [0:0] __tmpvar__decode_comb_Jtype;
  logic [0:0] __tmpvar__decode_comb_Csrtype;
  logic [0:0] __tmpvar__decode_comb_mem_issue;
  logic [0:0] __tmpvar__decode_comb_int_issue;

  // PyMTL Update Block Source
  // At /Users/curtisbucher/Desktop/ramp-core/src/cl/decoder.py:129
  // @update
  // def decode_comb():
  //     # For determining type
  //     opcode = s.inst[0:7]
  // 
  //     Rtype = opcode == RTYPE_OPCODE
  //     Itype = (
  //         (opcode == ITYPE_OPCODE1)
  //         | (opcode == ITYPE_OPCODE2)
  //         | (opcode == ITYPE_OPCODE3)
  //     )
  //     Stype = opcode == STYPE_OPCODE
  //     Btype = opcode == BTYPE_OPCODE
  //     Utype = (opcode == UTYPE_OPCODE1) | (opcode == UTYPE_OPCODE2)
  //     Jtype = opcode == JTYPE_OPCODE
  //     Csrtype = opcode == CSRTYPE_OPCODE
  // 
  //     # For determining issue unit
  //     mem_issue = (opcode == ITYPE_OPCODE2) | (opcode == STYPE_OPCODE)
  //     int_issue = ~mem_issue  # TODO: fpu issue
  // 
  //     # uop (hardcoded values)
  //     # TODO: uopcode
  //     s.uop.inst @= s.inst
  //     s.uop.pc @= (s.pc + 4) if s.idx else (s.pc)
  //     s.uop.valid @= 1
  // 
  //     s.uop.lrd @= s.inst[RD_SLICE]
  //     s.uop.lrs1 @= s.inst[RS1_SLICE]
  //     s.uop.lrs2 @= s.inst[RS2_SLICE]
  // 
  //     s.uop.prd @= s.pregs.prd
  //     s.uop.prs1 @= s.pregs.prs1
  //     s.uop.prs2 @= s.pregs.prs2
  //     s.uop.stale @= s.pregs.stale
  // 
  //     s.uop.prs1_busy @= s.pregs_busy.prs1
  //     s.uop.prs2_busy @= s.pregs_busy.prs2
  // 
  //     s.uop.issue_unit @= (
  //         INT_ISSUE_UNIT if int_issue else MEM_ISSUE_UNIT if mem_issue else 0
  //     )
  // 
  //     # immediates TODO: update with slices
  //     if Rtype:
  //         s.uop.imm @= 0
  //     elif Itype:
  //         s.uop.imm @= sext(s.inst[20:32], 32)
  //         s.uop.lrs2 @= 0
  //     elif Stype:
  //         s.uop.imm @= sext(concat(s.inst[25:32], s.inst[7:12]), 32)
  //         s.uop.lrd @= 0
  //     elif Btype:
  //         s.uop.imm @= sext(
  //             concat(
  //                 s.inst[31], s.inst[7], s.inst[25:31], s.inst[8:12], Bits1(0)
  //             ),
  //             32,
  //         )
  //         s.uop.lrd @= 0
  //     elif Utype:
  //         s.uop.imm @= concat(s.inst[12:32], Bits12(0))
  //         s.uop.lrs1 @= 0
  //         s.uop.lrs2 @= 0
  //     elif Jtype:
  //         s.uop.imm @= sext(
  //             concat(
  //                 s.inst[31],
  //                 s.inst[12:20],
  //                 s.inst[20],
  //                 s.inst[25:31],
  //                 s.inst[21:25],
  //                 Bits1(0),
  //             ),
  //             32,
  //         )
  //         s.uop.lrs1 @= 0
  //         s.uop.lrs2 @= 0
  //     elif Csrtype:
  //         s.uop.imm @= 0
  //         s.uop.lrs2 @= 0
  
  always_comb begin : decode_comb
    __tmpvar__decode_comb_opcode = inst[5'd6:5'd0];
    __tmpvar__decode_comb_Rtype = __tmpvar__decode_comb_opcode == 7'( __const__RTYPE_OPCODE );
    __tmpvar__decode_comb_Itype = ( ( __tmpvar__decode_comb_opcode == 7'( __const__ITYPE_OPCODE1 ) ) | ( __tmpvar__decode_comb_opcode == 7'( __const__ITYPE_OPCODE2 ) ) ) | ( __tmpvar__decode_comb_opcode == 7'( __const__ITYPE_OPCODE3 ) );
    __tmpvar__decode_comb_Stype = __tmpvar__decode_comb_opcode == 7'( __const__STYPE_OPCODE );
    __tmpvar__decode_comb_Btype = __tmpvar__decode_comb_opcode == 7'( __const__BTYPE_OPCODE );
    __tmpvar__decode_comb_Utype = ( __tmpvar__decode_comb_opcode == 7'( __const__UTYPE_OPCODE1 ) ) | ( __tmpvar__decode_comb_opcode == 7'( __const__UTYPE_OPCODE2 ) );
    __tmpvar__decode_comb_Jtype = __tmpvar__decode_comb_opcode == 7'( __const__JTYPE_OPCODE );
    __tmpvar__decode_comb_Csrtype = __tmpvar__decode_comb_opcode == 7'( __const__CSRTYPE_OPCODE );
    __tmpvar__decode_comb_mem_issue = ( __tmpvar__decode_comb_opcode == 7'( __const__ITYPE_OPCODE2 ) ) | ( __tmpvar__decode_comb_opcode == 7'( __const__STYPE_OPCODE ) );
    __tmpvar__decode_comb_int_issue = ~__tmpvar__decode_comb_mem_issue;
    uop.inst = inst;
    uop.pc = idx ? pc + 8'd4 : pc;
    uop.valid = 1'd1;
    uop.lrd = inst[5'd11:5'd7];
    uop.lrs1 = inst[5'd19:5'd15];
    uop.lrs2 = inst[5'd24:5'd20];
    uop.prd = pregs.prd;
    uop.prs1 = pregs.prs1;
    uop.prs2 = pregs.prs2;
    uop.stale = pregs.stale;
    uop.prs1_busy = pregs_busy.prs1;
    uop.prs2_busy = pregs_busy.prs2;
    uop.issue_unit = __tmpvar__decode_comb_int_issue ? 2'( __const__INT_ISSUE_UNIT ) : __tmpvar__decode_comb_mem_issue ? 2'( __const__MEM_ISSUE_UNIT ) : 2'd0;
    if ( __tmpvar__decode_comb_Rtype ) begin
      uop.imm = 32'd0;
    end
    else if ( __tmpvar__decode_comb_Itype ) begin
      uop.imm = { { 20 { inst[5'd31] } }, inst[5'd31:5'd20] };
      uop.lrs2 = 5'd0;
    end
    else if ( __tmpvar__decode_comb_Stype ) begin
      uop.imm = { { 20 { { inst[5'd31:5'd25], inst[5'd11:5'd7] }[11] } }, { inst[5'd31:5'd25], inst[5'd11:5'd7] } };
      uop.lrd = 5'd0;
    end
    else if ( __tmpvar__decode_comb_Btype ) begin
      uop.imm = { { 19 { { inst[5'd31], inst[5'd7], inst[5'd30:5'd25], inst[5'd11:5'd8], 1'd0 }[12] } }, { inst[5'd31], inst[5'd7], inst[5'd30:5'd25], inst[5'd11:5'd8], 1'd0 } };
      uop.lrd = 5'd0;
    end
    else if ( __tmpvar__decode_comb_Utype ) begin
      uop.imm = { inst[5'd31:5'd12], 12'd0 };
      uop.lrs1 = 5'd0;
      uop.lrs2 = 5'd0;
    end
    else if ( __tmpvar__decode_comb_Jtype ) begin
      uop.imm = { { 11 { { inst[5'd31], inst[5'd19:5'd12], inst[5'd20], inst[5'd30:5'd25], inst[5'd24:5'd21], 1'd0 }[20] } }, { inst[5'd31], inst[5'd19:5'd12], inst[5'd20], inst[5'd30:5'd25], inst[5'd24:5'd21], 1'd0 } };
      uop.lrs1 = 5'd0;
      uop.lrs2 = 5'd0;
    end
    else if ( __tmpvar__decode_comb_Csrtype ) begin
      uop.imm = 32'd0;
      uop.lrs2 = 5'd0;
    end
  end

endmodule
