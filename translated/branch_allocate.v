//-------------------------------------------------------------------------
// BranchAllocate.v
//-------------------------------------------------------------------------
// This file is generated by PyMTL SystemVerilog translation pass.

// PyMTL BitStruct BranchUpdate__target_32__mispredict_1__tag_3 Definition
typedef struct packed {
  logic [31:0] target;
  logic [0:0] mispredict;
  logic [2:0] tag;
} BranchUpdate__target_32__mispredict_1__tag_3;

// PyMTL Component BranchAllocate Definition
// Full name: BranchAllocate__ntags_8__window_size_2
// At /Users/curtisbucher/Desktop/ramp-core/src/cl/branch_allocate.py

module BranchAllocate
(
  output logic [7:0] br_mask [0:1],
  input  logic [0:0] clk ,
  input  logic [0:0] reset ,
  output logic [0:0] br_tag__en [0:1] ,
  output logic [2:0] br_tag__msg [0:1] ,
  input logic [0:0] br_tag__rdy [0:1] ,
  input logic [0:0] br_update__en  ,
  input BranchUpdate__target_32__mispredict_1__tag_3 br_update__msg  ,
  output logic [0:0] br_update__rdy  
);
  localparam logic [1:0] __const__window_size_at_updt  = 2'd2;
  localparam logic [3:0] __const__ntags_at_updt  = 4'd8;
  logic [7:0] br_freelist;
  logic [7:0] br_freelist_next;
  logic [0:0] full;

  // PyMTL Update Block Source
  // At /Users/curtisbucher/Desktop/ramp-core/src/cl/branch_allocate.py:30
  // @update
  // def updt():
  //     # deallocate executed branch
  //     s.br_freelist_next @= s.br_freelist
  //     if s.br_update.en:
  //         s.br_freelist_next[s.br_update.msg.tag] @= 0
  // 
  //     # allocate the first available bit in br_mask, if available
  //     # update freelist accordingly
  //     for i in range(window_size):
  //         s.br_tag[i].en @= 0
  //         s.br_tag[i].msg @= 0
  //         s.br_mask[i] @= s.br_freelist_next
  //         for b in range(ntags):
  //             s.full @= reduce_and(s.br_freelist_next)
  //             if (s.br_freelist_next[b] == 0) & s.br_tag[i].rdy & ~s.br_tag[i].en:
  //                 s.br_tag[i].en @= 1
  //                 s.br_tag[i].msg @= b
  //                 s.br_freelist_next[s.br_tag[i].msg] @= 1
  
  always_comb begin : updt
    br_freelist_next = br_freelist;
    if ( br_update__en ) begin
      br_freelist_next[br_update__msg.tag] = 1'd0;
    end
    for ( int unsigned i = 1'd0; i < 2'( __const__window_size_at_updt ); i += 1'd1 ) begin
      br_tag__en[1'(i)] = 1'd0;
      br_tag__msg[1'(i)] = 3'd0;
      br_mask[1'(i)] = br_freelist_next;
      for ( int unsigned b = 1'd0; b < 4'( __const__ntags_at_updt ); b += 1'd1 ) begin
        full = ( & br_freelist_next );
        if ( ( ( br_freelist_next[3'(b)] == 1'd0 ) & br_tag__rdy[1'(i)] ) & ( ~br_tag__en[1'(i)] ) ) begin
          br_tag__en[1'(i)] = 1'd1;
          br_tag__msg[1'(i)] = 3'(b);
          br_freelist_next[br_tag__msg[1'(i)]] = 1'd1;
        end
      end
    end
  end

  // PyMTL Update Block Source
  // At /Users/curtisbucher/Desktop/ramp-core/src/cl/branch_allocate.py:23
  // @update_ff
  // def updt_ff():
  //     if s.reset:
  //         s.br_freelist <<= 0
  //     else:
  //         s.br_freelist <<= s.br_freelist_next
  
  always_ff @(posedge clk) begin : updt_ff
    if ( reset ) begin
      br_freelist <= 8'd0;
    end
    else
      br_freelist <= br_freelist_next;
  end

  assign br_update__rdy = 1'd1;

endmodule
