//-------------------------------------------------------------------------
// Decode.v
//-------------------------------------------------------------------------
// This file is generated by PyMTL SystemVerilog translation pass.

// PyMTL BitStruct BranchUpdate__target_32__mispredict_1__tag_3 Definition
typedef struct packed {
  logic [31:0] target;
  logic [0:0] mispredict;
  logic [2:0] tag;
} BranchUpdate__target_32__mispredict_1__tag_3;

// PyMTL BitStruct MicroOp__38e2b09b91e4b306 Definition
typedef struct packed {
  logic [2:0] optype;
  logic [31:0] inst;
  logic [31:0] pc;
  logic [0:0] valid;
  logic [4:0] lrd;
  logic [4:0] lrs1;
  logic [4:0] lrs2;
  logic [5:0] prd;
  logic [5:0] prs1;
  logic [5:0] prs2;
  logic [5:0] stale;
  logic [31:0] imm;
  logic [1:0] issue_unit;
  logic [1:0] funct_unit;
  logic [3:0] funct_op;
  logic [0:0] branch_taken;
  logic [7:0] br_mask;
  logic [2:0] br_tag;
  logic [4:0] rob_idx;
  logic [3:0] mem_q_idx;
} MicroOp__38e2b09b91e4b306;

// PyMTL BitStruct DualMicroOp__93e30b890d7542af Definition
typedef struct packed {
  MicroOp__38e2b09b91e4b306 uop1;
  MicroOp__38e2b09b91e4b306 uop2;
} DualMicroOp__93e30b890d7542af;

// PyMTL BitStruct FetchPacket__pc_32__branch_taken_1__inst1_32__inst2_32__valid_1 Definition
typedef struct packed {
  logic [31:0] pc;
  logic [0:0] branch_taken;
  logic [31:0] inst1;
  logic [31:0] inst2;
  logic [0:0] valid;
} FetchPacket__pc_32__branch_taken_1__inst1_32__inst2_32__valid_1;

// PyMTL BitStruct PhysicalRegs__prd_6__prs1_6__prs2_6__stale_6 Definition
typedef struct packed {
  logic [5:0] prd;
  logic [5:0] prs1;
  logic [5:0] prs2;
  logic [5:0] stale;
} PhysicalRegs__prd_6__prs1_6__prs2_6__stale_6;

// PyMTL BitStruct PRegBusy__prs1_1__prs2_1 Definition
typedef struct packed {
  logic [0:0] prs1;
  logic [0:0] prs2;
} PRegBusy__prs1_1__prs2_1;

// PyMTL BitStruct LogicalRegs__lrd_5__lrs1_5__lrs2_5 Definition
typedef struct packed {
  logic [4:0] lrd;
  logic [4:0] lrs1;
  logic [4:0] lrs2;
} LogicalRegs__lrd_5__lrs1_5__lrs2_5;

// PyMTL Component BranchAllocate Definition
// At /Users/curtisbucher/Desktop/ramp-core/src/cl/branch_allocate.py

module BranchAllocate__ntags_8__window_size_2
(
  output logic [7:0] br_mask [0:1],
  input  logic [0:0] clk ,
  input  logic [0:0] reset ,
  output logic [0:0] br_tag__en [0:1] ,
  output logic [2:0] br_tag__msg [0:1] ,
  input logic [0:0] br_tag__rdy [0:1] ,
  input logic [0:0] br_update__en  ,
  input BranchUpdate__target_32__mispredict_1__tag_3 br_update__msg  ,
  output logic [0:0] br_update__rdy  
);
  localparam logic [1:0] __const__window_size_at_updt  = 2'd2;
  localparam logic [3:0] __const__ntags_at_updt  = 4'd8;
  logic [7:0] br_freelist;
  logic [7:0] br_freelist_next;
  logic [0:0] full;

  // PyMTL Update Block Source
  // At /Users/curtisbucher/Desktop/ramp-core/src/cl/branch_allocate.py:30
  // @update
  // def updt():
  //     # deallocate executed branch
  //     s.br_freelist_next @= s.br_freelist
  //     if s.br_update.en:
  //         s.br_freelist_next[s.br_update.msg.tag] @= 0
  // 
  //     # allocate the first available bit in br_mask, if available
  //     # update freelist accordingly
  //     for i in range(window_size):
  //         s.br_tag[i].en @= 0
  //         s.br_tag[i].msg @= 0
  //         s.br_mask[i] @= s.br_freelist_next
  //         for b in range(ntags):
  //             s.full @= reduce_and(s.br_freelist_next)
  //             if (s.br_freelist_next[b] == 0) & s.br_tag[i].rdy & ~s.br_tag[i].en:
  //                 s.br_tag[i].en @= 1
  //                 s.br_tag[i].msg @= b
  //                 s.br_freelist_next[s.br_tag[i].msg] @= 1
  
  always_comb begin : updt
    br_freelist_next = br_freelist;
    if ( br_update__en ) begin
      br_freelist_next[br_update__msg.tag] = 1'd0;
    end
    for ( int unsigned i = 1'd0; i < 2'( __const__window_size_at_updt ); i += 1'd1 ) begin
      br_tag__en[1'(i)] = 1'd0;
      br_tag__msg[1'(i)] = 3'd0;
      br_mask[1'(i)] = br_freelist_next;
      for ( int unsigned b = 1'd0; b < 4'( __const__ntags_at_updt ); b += 1'd1 ) begin
        full = ( & br_freelist_next );
        if ( ( ( br_freelist_next[3'(b)] == 1'd0 ) & br_tag__rdy[1'(i)] ) & ( ~br_tag__en[1'(i)] ) ) begin
          br_tag__en[1'(i)] = 1'd1;
          br_tag__msg[1'(i)] = 3'(b);
          br_freelist_next[br_tag__msg[1'(i)]] = 1'd1;
        end
      end
    end
  end

  // PyMTL Update Block Source
  // At /Users/curtisbucher/Desktop/ramp-core/src/cl/branch_allocate.py:23
  // @update_ff
  // def updt_ff():
  //     if s.reset:
  //         s.br_freelist <<= 0
  //     else:
  //         s.br_freelist <<= s.br_freelist_next
  
  always_ff @(posedge clk) begin : updt_ff
    if ( reset ) begin
      br_freelist <= 8'd0;
    end
    else
      br_freelist <= br_freelist_next;
  end

  assign br_update__rdy = 1'd1;

endmodule


// PyMTL Component SingleInstDecode Definition
// At /Users/curtisbucher/Desktop/ramp-core/src/cl/decode.py

module SingleInstDecode_noparam
(
  input  logic [7:0] br_mask ,
  input  logic [2:0] br_tag ,
  input  logic [0:0] branch_taken ,
  input  logic [0:0] clk ,
  input  logic [31:0] inst ,
  input  logic [3:0] mem_q_idx ,
  input  logic [31:0] pc ,
  input  PhysicalRegs__prd_6__prs1_6__prs2_6__stale_6 pregs ,
  input  PRegBusy__prs1_1__prs2_1 pregs_busy ,
  input  logic [0:0] reset ,
  output MicroOp__38e2b09b91e4b306 uop ,
  input  logic [0:0] valid 
);
  localparam logic [4:0] __const__INSTR_NOP  = 5'd19;
  localparam logic [5:0] __const__RTYPE_OPCODE  = 6'd51;
  localparam logic [0:0] __const__R_TYPE  = 1'd1;
  localparam logic [0:0] __const__INT_ISSUE_UNIT  = 1'd1;
  localparam logic [0:0] __const__ALU_FUNCT_UNIT  = 1'd1;
  localparam logic [4:0] __const__ITYPE_OPCODE1  = 5'd19;
  localparam logic [1:0] __const__I_TYPE  = 2'd2;
  localparam logic [1:0] __const__ITYPE_OPCODE2  = 2'd3;
  localparam logic [1:0] __const__MEM_ISSUE_UNIT  = 2'd2;
  localparam logic [1:0] __const__MEM_FUNCT_UNIT  = 2'd2;
  localparam logic [6:0] __const__ITYPE_OPCODE3  = 7'd103;
  localparam logic [1:0] __const__BRANCH_ISSUE_UNIT  = 2'd3;
  localparam logic [1:0] __const__BRANCH_FUNCT_UNIT  = 2'd3;
  localparam logic [5:0] __const__STYPE_OPCODE  = 6'd35;
  localparam logic [1:0] __const__S_TYPE  = 2'd3;
  localparam logic [6:0] __const__BTYPE_OPCODE  = 7'd99;
  localparam logic [2:0] __const__B_TYPE  = 3'd4;
  localparam logic [5:0] __const__UTYPE_OPCODE1  = 6'd55;
  localparam logic [4:0] __const__UTYPE_OPCODE2  = 5'd23;
  localparam logic [2:0] __const__U_TYPE  = 3'd5;
  localparam logic [6:0] __const__JTYPE_OPCODE  = 7'd111;
  localparam logic [2:0] __const__J_TYPE  = 3'd6;
  localparam logic [6:0] __const__CSRTYPE_OPCODE  = 7'd115;
  localparam logic [2:0] __const__CSR_TYPE  = 3'd7;
  localparam logic [0:0] __const__NA_ISSUE_UNIT  = 1'd0;
  localparam logic [0:0] __const__NA_FUNCT_UNIT  = 1'd0;
  localparam logic [0:0] __const__NA_TYPE  = 1'd0;
  logic [6:0] __tmpvar__decode_comb_opcode;

  // PyMTL Update Block Source
  // At /Users/curtisbucher/Desktop/ramp-core/src/cl/decode.py:217
  // @update
  // def decode_comb():
  //     # defaults
  //     s.uop.inst @= s.inst
  //     s.uop.pc @= (s.pc + 4) if s.idx else (s.pc)
  //     s.uop.branch_taken @= s.branch_taken
  //     s.uop.br_tag @= s.br_tag
  //     s.uop.br_mask @= s.br_mask
  //     s.uop.valid @= (s.inst != INSTR_NOP) & ~(s.inst == 0)
  // 
  //     # TODO: Currently, register renaming is dependent on not-used
  //     # logical registers being zeroed out. If we want to get rid of the
  //     # zeroing out logic, register renaming must be changed.
  //     s.uop.lrd @= s.inst[RD_SLICE]
  //     s.uop.lrs1 @= s.inst[RS1_SLICE]
  //     s.uop.lrs2 @= s.inst[RS2_SLICE]
  // 
  //     s.uop.prd @= s.pregs.prd
  //     s.uop.prs1 @= s.pregs.prs1
  //     s.uop.prs2 @= s.pregs.prs2
  //     s.uop.stale @= s.pregs.stale
  // 
  //     s.uop.imm @= 0
  //     s.uop.funct_op @= 0
  //     s.uop.rob_idx @= 0
  //     s.uop.mem_q_idx @= 0
  // 
  //     # For determining type
  //     opcode = s.inst[OPCODE_SLICE]
  //     # arithmetic and logical instructions
  //     if opcode == RTYPE_OPCODE:
  //         s.uop.optype @= R_TYPE
  //         s.uop.issue_unit @= INT_ISSUE_UNIT
  //         s.uop.funct_unit @= ALU_FUNCT_UNIT
  //         s.uop.funct_op @= concat(s.inst[30], s.inst[FUNCT3_SLICE])
  // 
  //     # immediate arithmetic and logical
  //     elif opcode == ITYPE_OPCODE1:
  //         s.uop.optype @= I_TYPE
  //         s.uop.issue_unit @= INT_ISSUE_UNIT
  //         s.uop.funct_unit @= ALU_FUNCT_UNIT
  //         s.uop.funct_op @= zext(s.inst[FUNCT3_SLICE], 4)
  //         # srli, srai
  //         if s.inst[FUNCT3_SLICE] == 0b101:
  //             s.uop.funct_op @= concat(s.inst[30], s.inst[FUNCT3_SLICE])
  //         s.uop.imm @= sext(s.inst[20:32], 32)
  // 
  //         s.uop.lrs2 @= 0
  //     # loads
  //     elif opcode == ITYPE_OPCODE2:
  //         s.uop.optype @= I_TYPE
  //         s.uop.issue_unit @= MEM_ISSUE_UNIT
  //         s.uop.funct_unit @= MEM_FUNCT_UNIT
  //         s.uop.funct_op @= concat(opcode[5], s.inst[FUNCT3_SLICE])
  //         s.uop.imm @= sext(s.inst[20:32], 32)
  // 
  //         s.uop.lrs2 @= 0
  //     # jalr
  //     elif opcode == ITYPE_OPCODE3:
  //         s.uop.optype @= I_TYPE
  //         s.uop.issue_unit @= BRANCH_ISSUE_UNIT
  //         s.uop.funct_unit @= BRANCH_FUNCT_UNIT
  //         s.uop.funct_op @= 0
  //         s.uop.imm @= sext(s.inst[20:32], 32)
  // 
  //         s.uop.lrs2 @= 0
  //     # stores
  //     elif opcode == STYPE_OPCODE:
  //         s.uop.optype @= S_TYPE
  //         s.uop.issue_unit @= MEM_ISSUE_UNIT
  //         s.uop.funct_unit @= MEM_FUNCT_UNIT
  //         s.uop.funct_op @= concat(opcode[5], s.inst[FUNCT3_SLICE])
  //         s.uop.imm @= sext(concat(s.inst[25:32], s.inst[7:12]), 32)
  // 
  //         s.uop.lrd @= 0
  //     # branches
  //     elif opcode == BTYPE_OPCODE:
  //         s.uop.optype @= B_TYPE
  //         s.uop.issue_unit @= BRANCH_ISSUE_UNIT
  //         s.uop.funct_unit @= BRANCH_FUNCT_UNIT
  //         s.uop.funct_op @= zext(s.inst[FUNCT3_SLICE], 4)
  //         s.uop.imm @= sext(
  //             concat(
  //                 s.inst[31], s.inst[7], s.inst[25:31], s.inst[8:12], Bits1(0)
  //             ),
  //             32,
  //         )
  // 
  //         s.uop.lrd @= 0
  //     # lui (1), auipc (2)
  //     elif (opcode == UTYPE_OPCODE1) | (opcode == UTYPE_OPCODE2):
  //         s.uop.optype @= U_TYPE
  //         s.uop.issue_unit @= INT_ISSUE_UNIT
  //         s.uop.funct_unit @= ALU_FUNCT_UNIT
  //         s.uop.funct_op @= Bits4(0b1001)  # alu lui-copy TODO: auipc
  //         s.uop.imm @= concat(s.inst[12:32], Bits12(0))
  // 
  //         s.uop.lrs1 @= 0
  //         s.uop.lrs2 @= 0
  //     # jal
  //     elif opcode == JTYPE_OPCODE:
  //         s.uop.optype @= J_TYPE
  //         s.uop.issue_unit @= BRANCH_ISSUE_UNIT
  //         s.uop.funct_unit @= BRANCH_FUNCT_UNIT
  //         s.uop.imm @= sext(
  //             concat(
  //                 s.inst[31],
  //                 s.inst[12:20],
  //                 s.inst[20],
  //                 s.inst[25:31],
  //                 s.inst[21:25],
  //                 Bits1(0),
  //             ),
  //             32,
  //         )
  // 
  //         s.uop.lrs1 @= 0
  //         s.uop.lrs2 @= 0
  //     # system instructions
  //     elif opcode == CSRTYPE_OPCODE:
  //         s.uop.optype @= CSR_TYPE
  //         s.uop.issue_unit @= NA_ISSUE_UNIT
  //         s.uop.funct_unit @= NA_FUNCT_UNIT
  //         s.uop.funct_op @= 0
  //         s.uop.imm @= 0
  // 
  //         s.uop.lrs2 @= 0
  //     # otherwise noop
  //     else:
  //         s.uop.optype @= NA_TYPE
  //         s.uop.issue_unit @= NA_ISSUE_UNIT
  //         s.uop.funct_unit @= NA_FUNCT_UNIT
  //         s.uop.funct_op @= 0
  //         s.uop.imm @= 0
  //         s.uop.lrs2 @= 0
  //         s.uop.lrs1 @= 0
  //         s.uop.lrd @= 0
  //         s.uop.stale @= 0
  
  always_comb begin : decode_comb
    uop.inst = inst;
    uop.pc = 1'd0 ? pc + 32'd4 : pc;
    uop.branch_taken = branch_taken;
    uop.br_tag = br_tag;
    uop.br_mask = br_mask;
    uop.valid = ( inst != 32'( __const__INSTR_NOP ) ) & ( ~( inst == 32'd0 ) );
    uop.lrd = inst[5'd11:5'd7];
    uop.lrs1 = inst[5'd19:5'd15];
    uop.lrs2 = inst[5'd24:5'd20];
    uop.prd = pregs.prd;
    uop.prs1 = pregs.prs1;
    uop.prs2 = pregs.prs2;
    uop.stale = pregs.stale;
    uop.imm = 32'd0;
    uop.funct_op = 4'd0;
    uop.rob_idx = 5'd0;
    uop.mem_q_idx = 4'd0;
    __tmpvar__decode_comb_opcode = inst[5'd6:5'd0];
    if ( __tmpvar__decode_comb_opcode == 7'( __const__RTYPE_OPCODE ) ) begin
      uop.optype = 3'( __const__R_TYPE );
      uop.issue_unit = 2'( __const__INT_ISSUE_UNIT );
      uop.funct_unit = 2'( __const__ALU_FUNCT_UNIT );
      uop.funct_op = { inst[5'd30], inst[5'd14:5'd12] };
    end
    else if ( __tmpvar__decode_comb_opcode == 7'( __const__ITYPE_OPCODE1 ) ) begin
      uop.optype = 3'( __const__I_TYPE );
      uop.issue_unit = 2'( __const__INT_ISSUE_UNIT );
      uop.funct_unit = 2'( __const__ALU_FUNCT_UNIT );
      uop.funct_op = { { 1 { 1'b0 } }, inst[5'd14:5'd12] };
      if ( inst[5'd14:5'd12] == 3'd5 ) begin
        uop.funct_op = { inst[5'd30], inst[5'd14:5'd12] };
      end
      uop.imm = { { 20 { inst[5'd31] } }, inst[5'd31:5'd20] };
      uop.lrs2 = 5'd0;
    end
    else if ( __tmpvar__decode_comb_opcode == 7'( __const__ITYPE_OPCODE2 ) ) begin
      uop.optype = 3'( __const__I_TYPE );
      uop.issue_unit = 2'( __const__MEM_ISSUE_UNIT );
      uop.funct_unit = 2'( __const__MEM_FUNCT_UNIT );
      uop.funct_op = { __tmpvar__decode_comb_opcode[3'd5], inst[5'd14:5'd12] };
      uop.imm = { { 20 { inst[5'd31] } }, inst[5'd31:5'd20] };
      uop.lrs2 = 5'd0;
    end
    else if ( __tmpvar__decode_comb_opcode == 7'( __const__ITYPE_OPCODE3 ) ) begin
      uop.optype = 3'( __const__I_TYPE );
      uop.issue_unit = 2'( __const__BRANCH_ISSUE_UNIT );
      uop.funct_unit = 2'( __const__BRANCH_FUNCT_UNIT );
      uop.funct_op = 4'd0;
      uop.imm = { { 20 { inst[5'd31] } }, inst[5'd31:5'd20] };
      uop.lrs2 = 5'd0;
    end
    else if ( __tmpvar__decode_comb_opcode == 7'( __const__STYPE_OPCODE ) ) begin
      uop.optype = 3'( __const__S_TYPE );
      uop.issue_unit = 2'( __const__MEM_ISSUE_UNIT );
      uop.funct_unit = 2'( __const__MEM_FUNCT_UNIT );
      uop.funct_op = { __tmpvar__decode_comb_opcode[3'd5], inst[5'd14:5'd12] };
      uop.imm = { { 20 { { inst[5'd31:5'd25], inst[5'd11:5'd7] }[11] } }, { inst[5'd31:5'd25], inst[5'd11:5'd7] } };
      uop.lrd = 5'd0;
    end
    else if ( __tmpvar__decode_comb_opcode == 7'( __const__BTYPE_OPCODE ) ) begin
      uop.optype = 3'( __const__B_TYPE );
      uop.issue_unit = 2'( __const__BRANCH_ISSUE_UNIT );
      uop.funct_unit = 2'( __const__BRANCH_FUNCT_UNIT );
      uop.funct_op = { { 1 { 1'b0 } }, inst[5'd14:5'd12] };
      uop.imm = { { 19 { { inst[5'd31], inst[5'd7], inst[5'd30:5'd25], inst[5'd11:5'd8], 1'd0 }[12] } }, { inst[5'd31], inst[5'd7], inst[5'd30:5'd25], inst[5'd11:5'd8], 1'd0 } };
      uop.lrd = 5'd0;
    end
    else if ( ( __tmpvar__decode_comb_opcode == 7'( __const__UTYPE_OPCODE1 ) ) | ( __tmpvar__decode_comb_opcode == 7'( __const__UTYPE_OPCODE2 ) ) ) begin
      uop.optype = 3'( __const__U_TYPE );
      uop.issue_unit = 2'( __const__INT_ISSUE_UNIT );
      uop.funct_unit = 2'( __const__ALU_FUNCT_UNIT );
      uop.funct_op = 4'd9;
      uop.imm = { inst[5'd31:5'd12], 12'd0 };
      uop.lrs1 = 5'd0;
      uop.lrs2 = 5'd0;
    end
    else if ( __tmpvar__decode_comb_opcode == 7'( __const__JTYPE_OPCODE ) ) begin
      uop.optype = 3'( __const__J_TYPE );
      uop.issue_unit = 2'( __const__BRANCH_ISSUE_UNIT );
      uop.funct_unit = 2'( __const__BRANCH_FUNCT_UNIT );
      uop.imm = { { 11 { { inst[5'd31], inst[5'd19:5'd12], inst[5'd20], inst[5'd30:5'd25], inst[5'd24:5'd21], 1'd0 }[20] } }, { inst[5'd31], inst[5'd19:5'd12], inst[5'd20], inst[5'd30:5'd25], inst[5'd24:5'd21], 1'd0 } };
      uop.lrs1 = 5'd0;
      uop.lrs2 = 5'd0;
    end
    else if ( __tmpvar__decode_comb_opcode == 7'( __const__CSRTYPE_OPCODE ) ) begin
      uop.optype = 3'( __const__CSR_TYPE );
      uop.issue_unit = 2'( __const__NA_ISSUE_UNIT );
      uop.funct_unit = 2'( __const__NA_FUNCT_UNIT );
      uop.funct_op = 4'd0;
      uop.imm = 32'd0;
      uop.lrs2 = 5'd0;
    end
    else begin
      uop.optype = 3'( __const__NA_TYPE );
      uop.issue_unit = 2'( __const__NA_ISSUE_UNIT );
      uop.funct_unit = 2'( __const__NA_FUNCT_UNIT );
      uop.funct_op = 4'd0;
      uop.imm = 32'd0;
      uop.lrs2 = 5'd0;
      uop.lrs1 = 5'd0;
      uop.lrd = 5'd0;
      uop.stale = 6'd0;
    end
  end

endmodule


// PyMTL Component RegisterRename Definition
// At /Users/curtisbucher/Desktop/ramp-core/src/cl/register_rename.py

module RegisterRename_noparam
(
  output logic [63:0] busy_table ,
  input  logic [0:0] clk ,
  output logic [63:0] free_list ,
  input  LogicalRegs__lrd_5__lrs1_5__lrs2_5 inst1_lregs ,
  output PhysicalRegs__prd_6__prs1_6__prs2_6__stale_6 inst1_pregs ,
  output PRegBusy__prs1_1__prs2_1 inst1_pregs_busy ,
  input  LogicalRegs__lrd_5__lrs1_5__lrs2_5 inst2_lregs ,
  output PhysicalRegs__prd_6__prs1_6__prs2_6__stale_6 inst2_pregs ,
  output PRegBusy__prs1_1__prs2_1 inst2_pregs_busy ,
  input  logic [5:0] ready_in [0:1],
  input  logic [0:0] reset ,
  input  logic [5:0] stale_in [0:1],
  input logic [0:0] br_update__en  ,
  input BranchUpdate__target_32__mispredict_1__tag_3 br_update__msg  ,
  output logic [0:0] br_update__rdy  
);
  localparam logic [6:0] __const__NUM_PHYS_REGS  = 7'd64;
  localparam logic [5:0] __const__NUM_ISA_REGS  = 6'd32;
  logic [63:0] busy_table_next;
  logic [63:0] free_list_next;
  logic [5:0] map_table [0:31];
  logic [5:0] map_table_wr1;
  logic [5:0] map_table_wr2;
  logic [5:0] pdst1;
  logic [5:0] pdst2;

  // PyMTL Update Block Source
  // At /Users/curtisbucher/Desktop/ramp-core/src/cl/register_rename.py:71
  // @update
  // def rename_comb():
  //     # Combinatorially getting physical source registers from map table
  //     # and getting physical dest registers from free list
  //     # TODO: add assert statements for when physical registers are full
  // 
  //     # *combinatorially* getting dest registers, but not updating tables
  //     # pdst1, pdst2 = cascading_priority_encoder(2, s.free_list_next)
  //     s.pdst1 @= 0
  //     s.pdst2 @= 0
  //     for i in range(NUM_PHYS_REGS):
  //         if s.free_list[i]:
  //             if s.pdst1 == 0:
  //                 s.pdst1 @= i
  //             elif s.pdst2 == 0:
  //                 s.pdst2 @= i
  //     # making sure that there are free registers
  //     # assert s.pdst1 != 0 or s.pdst2 != 0
  // 
  //     if s.inst1_lregs.lrd:
  //         s.inst1_pregs.prd @= s.pdst1
  //         s.inst2_pregs.prd @= s.pdst2 if s.inst2_lregs.lrd else 0
  //     elif s.inst2_lregs.lrd:
  //         s.inst1_pregs.prd @= 0
  //         s.inst2_pregs.prd @= s.pdst1
  //     else:
  //         s.inst1_pregs.prd @= 0
  //         s.inst2_pregs.prd @= 0
  // 
  //     s.inst1_pregs.prs1 @= s.map_table[s.inst1_lregs.lrs1]
  //     s.inst1_pregs.prs2 @= s.map_table[s.inst1_lregs.lrs2]
  //     s.inst1_pregs.stale @= s.map_table[s.inst1_lregs.lrd]
  //     s.inst1_pregs_busy.prs1 @= s.busy_table[s.inst1_pregs.prs1]
  //     s.inst1_pregs_busy.prs2 @= s.busy_table[s.inst1_pregs.prs2]
  // 
  //     # bypass network.
  //     # forward dependent sources from inst2 to inst1. handle stale
  //     if (s.inst2_lregs.lrd == s.inst1_lregs.lrd) & (s.inst1_lregs.lrd != 0):
  //         # inst2 dependent on inst1.
  //         s.inst2_pregs.stale @= s.pdst1
  //     else:
  //         s.inst2_pregs.stale @= s.map_table[s.inst2_lregs.lrd]
  // 
  //     if (s.inst2_lregs.lrs1 == s.inst1_lregs.lrd) & (s.inst1_lregs.lrd != 0):
  //         # inst2 dependent on inst1. inst2 prs1 = pdst1 and is busy
  //         s.inst2_pregs.prs1 @= s.pdst1
  //         s.inst2_pregs_busy.prs1 @= 1
  //     else:
  //         s.inst2_pregs.prs1 @= s.map_table[s.inst2_lregs.lrs1]
  //         s.inst2_pregs_busy.prs1 @= s.busy_table[s.inst2_pregs.prs2]
  // 
  //     if (s.inst2_lregs.lrs2 == s.inst1_lregs.lrd) & (s.inst1_lregs.lrd != 0):
  //         # inst2 dependent on inst1. inst2 prs2 = pdst1 and is busy
  //         s.inst2_pregs.prs2 @= s.pdst1
  //         s.inst2_pregs_busy.prs2 @= 1
  //     else:
  //         s.inst2_pregs.prs2 @= s.map_table[s.inst2_lregs.lrs2]
  //         s.inst2_pregs_busy.prs2 @= s.busy_table[s.inst2_pregs.prs2]
  // 
  //     # nextstate for updating free_list, map_table, busy_table
  //     if s.reset:
  //         s.free_list_next @= s.free_list_reset
  //         s.busy_table_next @= 0
  //     else:
  //         # updating tables with newely allocated registers
  //         if (s.inst1_lregs.lrd != 0) ^ (s.inst2_lregs.lrd != 0):
  //             s.free_list_next @= s.free_list_next & ~(
  //                 s.ONE << zext(s.pdst1, NUM_PHYS_REGS)
  //             )
  //             s.busy_table_next @= s.busy_table | (
  //                 s.ONE << zext(s.pdst1, NUM_PHYS_REGS)
  //             )
  //             if s.inst1_lregs.lrd:
  //                 s.map_table_wr1 @= s.pdst1
  //                 s.map_table_wr2 @= 0
  //             elif s.inst2_lregs.lrd:
  //                 s.map_table_wr1 @= 0
  //                 s.map_table_wr2 @= s.pdst1
  // 
  //         elif (s.inst1_lregs.lrd != 0) & (s.inst2_lregs.lrd != 0):
  //             # ensuring there are registers to allocate
  //             s.free_list_next @= (
  //                 s.free_list_next
  //                 & ~(s.ONE << zext(s.pdst1, NUM_PHYS_REGS))
  //                 & ~(s.ONE << zext(s.pdst2, NUM_PHYS_REGS))
  //             )
  //             s.busy_table_next @= (
  //                 s.busy_table
  //                 | s.ONE << zext(s.pdst1, NUM_PHYS_REGS)
  //                 | s.ONE << zext(s.pdst2, NUM_PHYS_REGS)
  //             )
  //             s.map_table_wr1 @= s.pdst1
  //             s.map_table_wr2 @= s.pdst2
  //         else:
  //             s.busy_table_next @= s.busy_table
  //             s.map_table_wr1 @= s.map_table[s.inst1_lregs.lrd]
  //             s.map_table_wr2 @= s.map_table[s.inst2_lregs.lrd]
  // 
  //     # updating free_list, busy_table
  //     for i in range(2):
  //         if s.stale_in[i]:
  //             s.free_list_next @= s.free_list_next | (
  //                 s.ONE << zext(s.stale_in[i], NUM_PHYS_REGS)
  //             )
  //         if s.ready_in[i]:
  //             s.busy_table_next @= s.busy_table_next & ~(
  //                 s.ONE << zext(s.ready_in[i], NUM_PHYS_REGS)
  //             )
  
  always_comb begin : rename_comb
    pdst1 = 6'd0;
    pdst2 = 6'd0;
    for ( int unsigned i = 1'd0; i < 7'( __const__NUM_PHYS_REGS ); i += 1'd1 )
      if ( free_list[6'(i)] ) begin
        if ( pdst1 == 6'd0 ) begin
          pdst1 = 6'(i);
        end
        else if ( pdst2 == 6'd0 ) begin
          pdst2 = 6'(i);
        end
      end
    if ( inst1_lregs.lrd ) begin
      inst1_pregs.prd = pdst1;
      inst2_pregs.prd = inst2_lregs.lrd ? pdst2 : 6'd0;
    end
    else if ( inst2_lregs.lrd ) begin
      inst1_pregs.prd = 6'd0;
      inst2_pregs.prd = pdst1;
    end
    else begin
      inst1_pregs.prd = 6'd0;
      inst2_pregs.prd = 6'd0;
    end
    inst1_pregs.prs1 = map_table[inst1_lregs.lrs1];
    inst1_pregs.prs2 = map_table[inst1_lregs.lrs2];
    inst1_pregs.stale = map_table[inst1_lregs.lrd];
    inst1_pregs_busy.prs1 = busy_table[inst1_pregs.prs1];
    inst1_pregs_busy.prs2 = busy_table[inst1_pregs.prs2];
    if ( ( inst2_lregs.lrd == inst1_lregs.lrd ) & ( inst1_lregs.lrd != 5'd0 ) ) begin
      inst2_pregs.stale = pdst1;
    end
    else
      inst2_pregs.stale = map_table[inst2_lregs.lrd];
    if ( ( inst2_lregs.lrs1 == inst1_lregs.lrd ) & ( inst1_lregs.lrd != 5'd0 ) ) begin
      inst2_pregs.prs1 = pdst1;
      inst2_pregs_busy.prs1 = 1'd1;
    end
    else begin
      inst2_pregs.prs1 = map_table[inst2_lregs.lrs1];
      inst2_pregs_busy.prs1 = busy_table[inst2_pregs.prs2];
    end
    if ( ( inst2_lregs.lrs2 == inst1_lregs.lrd ) & ( inst1_lregs.lrd != 5'd0 ) ) begin
      inst2_pregs.prs2 = pdst1;
      inst2_pregs_busy.prs2 = 1'd1;
    end
    else begin
      inst2_pregs.prs2 = map_table[inst2_lregs.lrs2];
      inst2_pregs_busy.prs2 = busy_table[inst2_pregs.prs2];
    end
    if ( reset ) begin
      free_list_next = 64'd18446744073709551614;
      busy_table_next = 64'd0;
    end
    else if ( ( inst1_lregs.lrd != 5'd0 ) ^ ( inst2_lregs.lrd != 5'd0 ) ) begin
      free_list_next = free_list_next & ( ~( 64'd1 << { { 58 { 1'b0 } }, pdst1 } ) );
      busy_table_next = busy_table | ( 64'd1 << { { 58 { 1'b0 } }, pdst1 } );
      if ( inst1_lregs.lrd ) begin
        map_table_wr1 = pdst1;
        map_table_wr2 = 6'd0;
      end
      else if ( inst2_lregs.lrd ) begin
        map_table_wr1 = 6'd0;
        map_table_wr2 = pdst1;
      end
    end
    else if ( ( inst1_lregs.lrd != 5'd0 ) & ( inst2_lregs.lrd != 5'd0 ) ) begin
      free_list_next = ( free_list_next & ( ~( 64'd1 << { { 58 { 1'b0 } }, pdst1 } ) ) ) & ( ~( 64'd1 << { { 58 { 1'b0 } }, pdst2 } ) );
      busy_table_next = ( busy_table | ( 64'd1 << { { 58 { 1'b0 } }, pdst1 } ) ) | ( 64'd1 << { { 58 { 1'b0 } }, pdst2 } );
      map_table_wr1 = pdst1;
      map_table_wr2 = pdst2;
    end
    else begin
      busy_table_next = busy_table;
      map_table_wr1 = map_table[inst1_lregs.lrd];
      map_table_wr2 = map_table[inst2_lregs.lrd];
    end
    for ( int unsigned i = 1'd0; i < 2'd2; i += 1'd1 ) begin
      if ( stale_in[1'(i)] ) begin
        free_list_next = free_list_next | ( 64'd1 << { { 58 { 1'b0 } }, stale_in[1'(i)] } );
      end
      if ( ready_in[1'(i)] ) begin
        busy_table_next = busy_table_next & ( ~( 64'd1 << { { 58 { 1'b0 } }, ready_in[1'(i)] } ) );
      end
    end
  end

  // PyMTL Update Block Source
  // At /Users/curtisbucher/Desktop/ramp-core/src/cl/register_rename.py:180
  // @update_ff
  // def rename_ff():
  //     s.free_list <<= s.free_list_next
  //     s.busy_table <<= s.busy_table_next
  //     s.map_table[s.inst1_lregs.lrd] <<= s.map_table_wr1
  //     s.map_table[s.inst2_lregs.lrd] <<= s.map_table_wr2
  //     # TODO: CL debugging
  //     # assert s.map_table[0] == 0
  //     # assert ~((s.inst1_lregs.lrd == 0) ^ (s.map_table_wr1 == 0))
  //     # assert ~((s.inst2_lregs.lrd == 0) ^ (s.map_table_wr2 == 0))
  // 
  //     # # resetting
  //     if s.reset == 1:
  //         for x in range(NUM_ISA_REGS):
  //             s.map_table[x] <<= 0
  // 
  //     # checking zero always points to zero
  
  always_ff @(posedge clk) begin : rename_ff
    free_list <= free_list_next;
    busy_table <= busy_table_next;
    map_table[inst1_lregs.lrd] <= map_table_wr1;
    map_table[inst2_lregs.lrd] <= map_table_wr2;
    if ( reset == 1'd1 ) begin
      for ( int unsigned x = 1'd0; x < 6'( __const__NUM_ISA_REGS ); x += 1'd1 )
        map_table[5'(x)] <= 6'd0;
    end
  end

  assign br_update__rdy = 1'd1;

endmodule


// PyMTL Component Decode Definition
// Full name: Decode_noparam
// At /Users/curtisbucher/Desktop/ramp-core/src/cl/decode.py

module Decode
(
  output logic [63:0] busy_table ,
  input  logic [0:0] clk ,
  output DualMicroOp__93e30b890d7542af dual_uop ,
  input  FetchPacket__pc_32__branch_taken_1__inst1_32__inst2_32__valid_1 fetch_packet ,
  output logic [1:0] mem_q_allocate ,
  input  logic [5:0] ready_in [0:1],
  input  logic [0:0] reset ,
  input  logic [5:0] stale_in [0:1],
  input logic [0:0] br_update__en  ,
  input BranchUpdate__target_32__mispredict_1__tag_3 br_update__msg  ,
  output logic [0:0] br_update__rdy  
);
  localparam logic [1:0] __const__MEM_ISSUE_UNIT  = 2'd2;
  localparam logic [2:0] __const__B_TYPE  = 3'd4;
  logic [31:0] inst1;
  logic [31:0] inst2;
  //-------------------------------------------------------------
  // Component branch_allocate
  //-------------------------------------------------------------

  logic [7:0] branch_allocate__br_mask [0:1];
  logic [0:0] branch_allocate__clk;
  logic [0:0] branch_allocate__reset;
  logic [0:0] branch_allocate__br_tag__en [0:1];
  logic [2:0] branch_allocate__br_tag__msg [0:1];
  logic [0:0] branch_allocate__br_tag__rdy [0:1];
  logic [0:0] branch_allocate__br_update__en;
  BranchUpdate__target_32__mispredict_1__tag_3 branch_allocate__br_update__msg;
  logic [0:0] branch_allocate__br_update__rdy;

  BranchAllocate__ntags_8__window_size_2 branch_allocate
  (
    .br_mask( branch_allocate__br_mask ),
    .clk( branch_allocate__clk ),
    .reset( branch_allocate__reset ),
    .br_tag__en( branch_allocate__br_tag__en ),
    .br_tag__msg( branch_allocate__br_tag__msg ),
    .br_tag__rdy( branch_allocate__br_tag__rdy ),
    .br_update__en( branch_allocate__br_update__en ),
    .br_update__msg( branch_allocate__br_update__msg ),
    .br_update__rdy( branch_allocate__br_update__rdy )
  );

  //-------------------------------------------------------------
  // End of component branch_allocate
  //-------------------------------------------------------------

  //-------------------------------------------------------------
  // Component d1
  //-------------------------------------------------------------

  logic [7:0] d1__br_mask;
  logic [2:0] d1__br_tag;
  logic [0:0] d1__branch_taken;
  logic [0:0] d1__clk;
  logic [31:0] d1__inst;
  logic [3:0] d1__mem_q_idx;
  logic [31:0] d1__pc;
  PhysicalRegs__prd_6__prs1_6__prs2_6__stale_6 d1__pregs;
  PRegBusy__prs1_1__prs2_1 d1__pregs_busy;
  logic [0:0] d1__reset;
  MicroOp__38e2b09b91e4b306 d1__uop;
  logic [0:0] d1__valid;

  SingleInstDecode_noparam d1
  (
    .br_mask( d1__br_mask ),
    .br_tag( d1__br_tag ),
    .branch_taken( d1__branch_taken ),
    .clk( d1__clk ),
    .inst( d1__inst ),
    .mem_q_idx( d1__mem_q_idx ),
    .pc( d1__pc ),
    .pregs( d1__pregs ),
    .pregs_busy( d1__pregs_busy ),
    .reset( d1__reset ),
    .uop( d1__uop ),
    .valid( d1__valid )
  );

  //-------------------------------------------------------------
  // End of component d1
  //-------------------------------------------------------------

  //-------------------------------------------------------------
  // Component d2
  //-------------------------------------------------------------

  logic [7:0] d2__br_mask;
  logic [2:0] d2__br_tag;
  logic [0:0] d2__branch_taken;
  logic [0:0] d2__clk;
  logic [31:0] d2__inst;
  logic [3:0] d2__mem_q_idx;
  logic [31:0] d2__pc;
  PhysicalRegs__prd_6__prs1_6__prs2_6__stale_6 d2__pregs;
  PRegBusy__prs1_1__prs2_1 d2__pregs_busy;
  logic [0:0] d2__reset;
  MicroOp__38e2b09b91e4b306 d2__uop;
  logic [0:0] d2__valid;

  SingleInstDecode_noparam d2
  (
    .br_mask( d2__br_mask ),
    .br_tag( d2__br_tag ),
    .branch_taken( d2__branch_taken ),
    .clk( d2__clk ),
    .inst( d2__inst ),
    .mem_q_idx( d2__mem_q_idx ),
    .pc( d2__pc ),
    .pregs( d2__pregs ),
    .pregs_busy( d2__pregs_busy ),
    .reset( d2__reset ),
    .uop( d2__uop ),
    .valid( d2__valid )
  );

  //-------------------------------------------------------------
  // End of component d2
  //-------------------------------------------------------------

  //-------------------------------------------------------------
  // Component register_rename
  //-------------------------------------------------------------

  logic [63:0] register_rename__busy_table;
  logic [0:0] register_rename__clk;
  logic [63:0] register_rename__free_list;
  LogicalRegs__lrd_5__lrs1_5__lrs2_5 register_rename__inst1_lregs;
  PhysicalRegs__prd_6__prs1_6__prs2_6__stale_6 register_rename__inst1_pregs;
  PRegBusy__prs1_1__prs2_1 register_rename__inst1_pregs_busy;
  LogicalRegs__lrd_5__lrs1_5__lrs2_5 register_rename__inst2_lregs;
  PhysicalRegs__prd_6__prs1_6__prs2_6__stale_6 register_rename__inst2_pregs;
  PRegBusy__prs1_1__prs2_1 register_rename__inst2_pregs_busy;
  logic [5:0] register_rename__ready_in [0:1];
  logic [0:0] register_rename__reset;
  logic [5:0] register_rename__stale_in [0:1];
  logic [0:0] register_rename__br_update__en;
  BranchUpdate__target_32__mispredict_1__tag_3 register_rename__br_update__msg;
  logic [0:0] register_rename__br_update__rdy;

  RegisterRename_noparam register_rename
  (
    .busy_table( register_rename__busy_table ),
    .clk( register_rename__clk ),
    .free_list( register_rename__free_list ),
    .inst1_lregs( register_rename__inst1_lregs ),
    .inst1_pregs( register_rename__inst1_pregs ),
    .inst1_pregs_busy( register_rename__inst1_pregs_busy ),
    .inst2_lregs( register_rename__inst2_lregs ),
    .inst2_pregs( register_rename__inst2_pregs ),
    .inst2_pregs_busy( register_rename__inst2_pregs_busy ),
    .ready_in( register_rename__ready_in ),
    .reset( register_rename__reset ),
    .stale_in( register_rename__stale_in ),
    .br_update__en( register_rename__br_update__en ),
    .br_update__msg( register_rename__br_update__msg ),
    .br_update__rdy( register_rename__br_update__rdy )
  );

  //-------------------------------------------------------------
  // End of component register_rename
  //-------------------------------------------------------------

  // PyMTL Update Block Source
  // At /Users/curtisbucher/Desktop/ramp-core/src/cl/decode.py:177
  // @update
  // def allocate_():
  //     # allocate memory queue space
  //     s.mem_q_allocate @= zext(
  //         s.d1.uop.issue_unit == MEM_ISSUE_UNIT, WINDOW_SIZE
  //     ) + zext(s.d2.uop.issue_unit == MEM_ISSUE_UNIT, WINDOW_SIZE)
  // 
  //     # allocate branch tags
  //     s.branch_allocate.br_tag[0].rdy @= s.d1.uop.optype == B_TYPE
  //     s.branch_allocate.br_tag[1].rdy @= s.d2.uop.optype == B_TYPE
  // 
  //     # connecting branch update signals
  //     s.br_update.rdy @= s.branch_allocate.br_update.rdy & s.register_rename.br_update.rdy
  // 
  //     # TODO: FOR CL MODEL
  //     # for i in range(2):
  //     #     assert ~(s.branch_allocate.br_tag[i].rdy ^ s.branch_allocate.br_tag[i].en)
  
  always_comb begin : allocate_
    mem_q_allocate = { { 1 { 1'b0 } }, d1__uop.issue_unit == 2'( __const__MEM_ISSUE_UNIT ) } + { { 1 { 1'b0 } }, d2__uop.issue_unit == 2'( __const__MEM_ISSUE_UNIT ) };
    branch_allocate__br_tag__rdy[1'd0] = d1__uop.optype == 3'( __const__B_TYPE );
    branch_allocate__br_tag__rdy[1'd1] = d2__uop.optype == 3'( __const__B_TYPE );
    br_update__rdy = branch_allocate__br_update__rdy & register_rename__br_update__rdy;
  end

  assign inst1 = fetch_packet.inst1;
  assign inst2 = fetch_packet.inst2;
  assign d1__clk = clk;
  assign d1__reset = reset;
  assign d1__inst = inst1;
  assign d1__pc = fetch_packet.pc;
  assign d1__branch_taken = fetch_packet.branch_taken;
  assign dual_uop.uop1 = d1__uop;
  assign d1__valid = fetch_packet.valid;
  assign d2__clk = clk;
  assign d2__reset = reset;
  assign d2__inst = inst2;
  assign d2__pc = fetch_packet.pc;
  assign d2__branch_taken = fetch_packet.branch_taken;
  assign dual_uop.uop2 = d2__uop;
  assign d2__valid = fetch_packet.valid;
  assign register_rename__clk = clk;
  assign register_rename__reset = reset;
  assign register_rename__inst1_lregs.lrd = d1__uop.lrd;
  assign register_rename__inst1_lregs.lrs1 = d1__uop.lrs1;
  assign register_rename__inst1_lregs.lrs2 = d1__uop.lrs2;
  assign register_rename__inst2_lregs.lrd = d2__uop.lrd;
  assign register_rename__inst2_lregs.lrs1 = d2__uop.lrs1;
  assign register_rename__inst2_lregs.lrs2 = d2__uop.lrs2;
  assign d1__pregs.prd = register_rename__inst1_pregs.prd;
  assign d1__pregs.prs1 = register_rename__inst1_pregs.prs1;
  assign d1__pregs.prs2 = register_rename__inst1_pregs.prs2;
  assign d1__pregs.stale = register_rename__inst1_pregs.stale;
  assign d2__pregs.prd = register_rename__inst2_pregs.prd;
  assign d2__pregs.prs1 = register_rename__inst2_pregs.prs1;
  assign d2__pregs.prs2 = register_rename__inst2_pregs.prs2;
  assign d2__pregs.stale = register_rename__inst2_pregs.stale;
  assign d1__pregs_busy = register_rename__inst1_pregs_busy;
  assign d2__pregs_busy = register_rename__inst2_pregs_busy;
  assign busy_table = register_rename__busy_table;
  assign register_rename__br_update__msg = br_update__msg;
  assign register_rename__br_update__en = br_update__en;
  assign branch_allocate__clk = clk;
  assign branch_allocate__reset = reset;
  assign d1__br_mask = branch_allocate__br_mask[0];
  assign d1__br_tag = branch_allocate__br_tag__msg[0];
  assign d2__br_mask = branch_allocate__br_mask[1];
  assign d2__br_tag = branch_allocate__br_tag__msg[1];
  assign branch_allocate__br_update__msg = br_update__msg;
  assign branch_allocate__br_update__en = br_update__en;
  assign register_rename__stale_in[0] = stale_in[0];
  assign register_rename__ready_in[0] = ready_in[0];
  assign register_rename__stale_in[1] = stale_in[1];
  assign register_rename__ready_in[1] = ready_in[1];

endmodule
