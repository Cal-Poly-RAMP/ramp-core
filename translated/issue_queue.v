//-------------------------------------------------------------------------
// IssueQueue.v
//-------------------------------------------------------------------------
// This file is generated by PyMTL SystemVerilog translation pass.

// PyMTL BitStruct MicroOp__38e2b09b91e4b306 Definition
typedef struct packed {
  logic [2:0] optype;
  logic [31:0] inst;
  logic [31:0] pc;
  logic [0:0] valid;
  logic [4:0] lrd;
  logic [4:0] lrs1;
  logic [4:0] lrs2;
  logic [5:0] prd;
  logic [5:0] prs1;
  logic [5:0] prs2;
  logic [5:0] stale;
  logic [31:0] imm;
  logic [1:0] issue_unit;
  logic [1:0] funct_unit;
  logic [3:0] funct_op;
  logic [0:0] branch_taken;
  logic [7:0] br_mask;
  logic [2:0] br_tag;
  logic [4:0] rob_idx;
  logic [3:0] mem_q_idx;
} MicroOp__38e2b09b91e4b306;

// PyMTL BitStruct DualMicroOp__93e30b890d7542af Definition
typedef struct packed {
  MicroOp__38e2b09b91e4b306 uop1;
  MicroOp__38e2b09b91e4b306 uop2;
} DualMicroOp__93e30b890d7542af;

// PyMTL Component IssueQueue Definition
// Full name: IssueQueue_noparam
// At /Users/curtisbucher/Desktop/ramp-core/src/cl/issue_queue.py

module IssueQueue
(
  input  logic [63:0] busy_table ,
  input  logic [0:0] clk ,
  input  DualMicroOp__93e30b890d7542af duop_in ,
  output logic [0:0] queue_empty ,
  output logic [0:0] queue_empty_next ,
  output logic [0:0] queue_full ,
  output logic [0:0] queue_full_next ,
  input  logic [0:0] reset ,
  output MicroOp__38e2b09b91e4b306 uop_out ,
  output MicroOp__38e2b09b91e4b306 uop_out_next 
);
  localparam logic [167:0] __const__NO_OP  = 168'd0;
  localparam logic [4:0] __const__ISSUE_QUEUE_DEPTH  = 5'd16;
  localparam logic [0:0] __const__R_TYPE  = 1'd1;
  localparam logic [1:0] __const__S_TYPE  = 2'd3;
  localparam logic [2:0] __const__B_TYPE  = 3'd4;
  localparam logic [1:0] __const__I_TYPE  = 2'd2;
  localparam logic [2:0] __const__U_TYPE  = 3'd5;
  localparam logic [2:0] __const__J_TYPE  = 3'd6;
  MicroOp__38e2b09b91e4b306 queue [0:15];
  MicroOp__38e2b09b91e4b306 queue_next [0:15];
  logic [3:0] tail;
  logic [3:0] tail_next;
  logic [0:0] __tmpvar__comb_collapse;

  // PyMTL Update Block Source
  // At /Users/curtisbucher/Desktop/ramp-core/src/cl/issue_queue.py:49
  // @update
  // def comb():
  //     if s.reset:
  //         s.tail_next @= 0
  //         s.queue_full_next @= 0
  //         s.queue_empty_next @= 1
  //         s.uop_out_next @= NO_OP
  //         for i in range(ISSUE_QUEUE_DEPTH):
  //             s.queue_next[i] @= NO_OP
  //     else:
  //         # APPENDING new uops to queue, if valid
  //         for i in range(ISSUE_QUEUE_DEPTH):
  //             s.queue_next[i] @= s.queue[i]
  //         s.uop_out_next @= NO_OP
  //         s.tail_next @= s.tail
  //         s.queue_full_next @= s.queue_full
  //         s.queue_empty_next @= s.queue_empty
  // 
  //         if (
  //             s.duop_in.uop1.valid
  //             & s.duop_in.uop2.valid
  //             & (s.tail_next < (ISSUE_QUEUE_DEPTH - 1))
  //         ):
  //             s.queue_next[s.tail_next] @= s.duop_in.uop1
  //             s.queue_next[s.tail_next + 1] @= s.duop_in.uop2
  // 
  //             #  if overflow, no wrap around
  //             s.queue_empty_next @= 0
  //             s.tail_next @= s.tail_next + 2
  //             if s.tail_next == 0:
  //                 s.queue_full_next @= 1
  // 
  //         elif s.duop_in.uop1.valid & ~s.queue_full:
  //             s.queue_next[s.tail_next] @= s.duop_in.uop1
  // 
  //             s.queue_empty_next @= 0
  //             s.tail_next @= s.tail_next + 1
  //             if s.tail_next == 0:
  //                 s.queue_full_next @= 1
  // 
  //         elif s.duop_in.uop2.valid & ~s.queue_full:
  //             s.queue_next[s.tail_next] @= s.duop_in.uop2
  // 
  //             s.queue_empty_next @= 0
  //             s.tail_next @= s.tail_next + 1
  //             if s.tail_next == 0:
  //                 s.queue_full_next @= 1
  // 
  //         # ISSUING uops from queue, if ready
  //         collapse = 0
  //         for i in range(ISSUE_QUEUE_DEPTH):
  //             # s.queue_next[i] @= s.queue[i]
  //             # if instruction has already been issued, collapse queue to fill in
  //             if collapse:
  //                 s.queue_next[i - 1] @= s.queue_next[i]
  //             # if not busy and valid, issue
  //             elif s.queue_next[i].valid:
  //                 # r,s,b type: need rs1, rs2 to be not busy
  //                 if (
  //                     (s.queue_next[i].optype == R_TYPE)
  //                     | (s.queue_next[i].optype == S_TYPE)
  //                     | (s.queue_next[i].optype == B_TYPE)
  //                 ):
  //                     if (
  //                         ~s.busy_table[s.queue_next[i].prs1]
  //                         & ~s.busy_table[s.queue_next[i].prs2]
  //                     ):
  //                         s.uop_out_next @= s.queue_next[i]
  //                         s.tail_next @= s.tail_next - 1
  //                         s.queue_full_next @= 0
  //                         collapse = 1
  // 
  //                 # i type: need rs1 to be not busy
  //                 elif s.queue_next[i].optype == I_TYPE:
  //                     if ~s.busy_table[s.queue_next[i].prs1]:
  //                         s.uop_out_next @= s.queue_next[i]
  //                         s.tail_next @= s.tail_next - 1
  //                         s.queue_full_next @= 0
  //                         collapse = 1
  // 
  //                 # u,b,j type: ready to issue
  //                 elif (s.queue_next[i].optype == U_TYPE) | (
  //                     s.queue_next[i].optype == J_TYPE
  //                 ):
  //                     s.uop_out_next @= s.queue_next[i]
  //                     s.tail_next @= s.tail_next - 1
  //                     s.queue_full_next @= 0
  //                     collapse = 1
  // 
  //         if collapse:
  //             s.queue_empty_next @= (s.tail_next - 1) == 0
  //             s.queue_next[ISSUE_QUEUE_DEPTH - 1] @= NO_OP
  
  always_comb begin : comb
    if ( reset ) begin
      tail_next = 4'd0;
      queue_full_next = 1'd0;
      queue_empty_next = 1'd1;
      uop_out_next = 168'( __const__NO_OP );
      for ( int unsigned i = 1'd0; i < 5'( __const__ISSUE_QUEUE_DEPTH ); i += 1'd1 )
        queue_next[4'(i)] = 168'( __const__NO_OP );
    end
    else begin
      for ( int unsigned i = 1'd0; i < 5'( __const__ISSUE_QUEUE_DEPTH ); i += 1'd1 )
        queue_next[4'(i)] = queue[4'(i)];
      uop_out_next = 168'( __const__NO_OP );
      tail_next = tail;
      queue_full_next = queue_full;
      queue_empty_next = queue_empty;
      if ( ( duop_in.uop1.valid & duop_in.uop2.valid ) & ( tail_next < ( 4'( __const__ISSUE_QUEUE_DEPTH ) - 4'd1 ) ) ) begin
        queue_next[tail_next] = duop_in.uop1;
        queue_next[tail_next + 4'd1] = duop_in.uop2;
        queue_empty_next = 1'd0;
        tail_next = tail_next + 4'd2;
        if ( tail_next == 4'd0 ) begin
          queue_full_next = 1'd1;
        end
      end
      else if ( duop_in.uop1.valid & ( ~queue_full ) ) begin
        queue_next[tail_next] = duop_in.uop1;
        queue_empty_next = 1'd0;
        tail_next = tail_next + 4'd1;
        if ( tail_next == 4'd0 ) begin
          queue_full_next = 1'd1;
        end
      end
      else if ( duop_in.uop2.valid & ( ~queue_full ) ) begin
        queue_next[tail_next] = duop_in.uop2;
        queue_empty_next = 1'd0;
        tail_next = tail_next + 4'd1;
        if ( tail_next == 4'd0 ) begin
          queue_full_next = 1'd1;
        end
      end
      __tmpvar__comb_collapse = 1'd0;
      for ( int unsigned i = 1'd0; i < 5'( __const__ISSUE_QUEUE_DEPTH ); i += 1'd1 )
        if ( 1'(__tmpvar__comb_collapse) ) begin
          queue_next[4'(i) - 4'd1] = queue_next[4'(i)];
        end
        else if ( queue_next[4'(i)].valid ) begin
          if ( ( ( queue_next[4'(i)].optype == 3'( __const__R_TYPE ) ) | ( queue_next[4'(i)].optype == 3'( __const__S_TYPE ) ) ) | ( queue_next[4'(i)].optype == 3'( __const__B_TYPE ) ) ) begin
            if ( ( ~busy_table[queue_next[4'(i)].prs1] ) & ( ~busy_table[queue_next[4'(i)].prs2] ) ) begin
              uop_out_next = queue_next[4'(i)];
              tail_next = tail_next - 4'd1;
              queue_full_next = 1'd0;
              __tmpvar__comb_collapse = 1'd1;
            end
          end
          else if ( queue_next[4'(i)].optype == 3'( __const__I_TYPE ) ) begin
            if ( ~busy_table[queue_next[4'(i)].prs1] ) begin
              uop_out_next = queue_next[4'(i)];
              tail_next = tail_next - 4'd1;
              queue_full_next = 1'd0;
              __tmpvar__comb_collapse = 1'd1;
            end
          end
          else if ( ( queue_next[4'(i)].optype == 3'( __const__U_TYPE ) ) | ( queue_next[4'(i)].optype == 3'( __const__J_TYPE ) ) ) begin
            uop_out_next = queue_next[4'(i)];
            tail_next = tail_next - 4'd1;
            queue_full_next = 1'd0;
            __tmpvar__comb_collapse = 1'd1;
          end
        end
      if ( 1'(__tmpvar__comb_collapse) ) begin
        queue_empty_next = ( tail_next - 4'd1 ) == 4'd0;
        queue_next[5'( __const__ISSUE_QUEUE_DEPTH ) - 5'd1] = 168'( __const__NO_OP );
      end
    end
  end

  // PyMTL Update Block Source
  // At /Users/curtisbucher/Desktop/ramp-core/src/cl/issue_queue.py:142
  // @update_ff
  // def ff():
  //     s.tail <<= s.tail_next
  //     s.queue_full <<= s.queue_full_next
  //     s.queue_empty <<= s.queue_empty_next
  //     s.uop_out <<= s.uop_out_next
  //     for i in range(ISSUE_QUEUE_DEPTH):
  //         s.queue[i] <<= s.queue_next[i]
  
  always_ff @(posedge clk) begin : ff
    tail <= tail_next;
    queue_full <= queue_full_next;
    queue_empty <= queue_empty_next;
    uop_out <= uop_out_next;
    for ( int unsigned i = 1'd0; i < 5'( __const__ISSUE_QUEUE_DEPTH ); i += 1'd1 )
      queue[4'(i)] <= queue_next[4'(i)];
  end

endmodule
