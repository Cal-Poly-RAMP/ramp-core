//-------------------------------------------------------------------------
// IssueQueue.v
//-------------------------------------------------------------------------
// This file is generated by PyMTL SystemVerilog translation pass.

// PyMTL BitStruct MicroOp__55c259864d23ef8d Definition
typedef struct packed {
  logic [2:0] optype;
  logic [31:0] inst;
  logic [7:0] pc;
  logic [0:0] valid;
  logic [4:0] lrd;
  logic [4:0] lrs1;
  logic [4:0] lrs2;
  logic [5:0] prd;
  logic [5:0] prs1;
  logic [5:0] prs2;
  logic [5:0] stale;
  logic [0:0] prs1_busy;
  logic [0:0] prs2_busy;
  logic [31:0] imm;
  logic [1:0] issue_unit;
  logic [1:0] funct_unit;
  logic [3:0] funct_op;
  logic [4:0] rob_idx;
} MicroOp__55c259864d23ef8d;

// PyMTL BitStruct DualMicroOp__8da14009c4c442a1 Definition
typedef struct packed {
  MicroOp__55c259864d23ef8d uop1;
  MicroOp__55c259864d23ef8d uop2;
} DualMicroOp__8da14009c4c442a1;

// PyMTL Component IssueQueue Definition
// Full name: IssueQueue_noparam
// At /Users/curtisbucher/Desktop/ramp-core/src/cl/issue_queue.py

module IssueQueue
(
  input  logic [63:0] busy_table ,
  input  logic [0:0] clk ,
  input  DualMicroOp__8da14009c4c442a1 duop_in ,
  output logic [0:0] queue_empty ,
  output logic [0:0] queue_full ,
  input  logic [0:0] reset ,
  output MicroOp__55c259864d23ef8d uop_out 
);
  localparam logic [4:0] __const__ISSUE_QUEUE_DEPTH  = 5'd16;
  localparam logic [0:0] __const__R_TYPE  = 1'd1;
  localparam logic [1:0] __const__S_TYPE  = 2'd3;
  localparam logic [2:0] __const__B_TYPE  = 3'd4;
  localparam logic [1:0] __const__I_TYPE  = 2'd2;
  localparam logic [2:0] __const__U_TYPE  = 3'd5;
  localparam logic [2:0] __const__J_TYPE  = 3'd6;
  MicroOp__55c259864d23ef8d queue [0:15];
  logic [3:0] tail;
  logic [0:0] __tmpvar__ff_collapse;

  // PyMTL Update Block Source
  // At /Users/curtisbucher/Desktop/ramp-core/src/cl/issue_queue.py:51
  // @update_ff
  // def ff():
  //     if s.reset:
  //         s.tail <<= 0
  //         s.queue_full <<= 0
  //         s.queue_empty <<= 1
  //         # TODO: reset queue
  // 
  //     # ISSUING uops from queue, if ready
  //     collapse = 0
  //     for i in range(ISSUE_QUEUE_DEPTH):
  //         # if instruction has already been issued, collapse queue to fill in
  //         if collapse:
  //             s.queue[i - 1] <<= s.queue[i]
  //         # if not busy and valid, issue
  //         elif s.queue[i].valid:
  //             # r,s,b type: need rs1, rs2 to be not busy
  //             if (
  //                 (s.queue[i].optype == R_TYPE)
  //                 | (s.queue[i].optype == S_TYPE)
  //                 | (s.queue[i].optype == B_TYPE)
  //             ):
  //                 if (
  //                     ~s.busy_table[s.queue[i].prs1]
  //                     & ~s.busy_table[s.queue[i].prs2]
  //                 ):
  //                     s.uop_out <<= s.queue[i]
  //                     s.tail <<= s.tail - 1
  //                     s.queue_full <<= 0
  //                     collapse = 1
  // 
  //             # i type: need rs1 to be not busy
  //             elif s.queue[i].optype == I_TYPE:
  //                 if ~s.busy_table[s.queue[i].prs1]:
  //                     s.uop_out <<= s.queue[i]
  //                     s.tail <<= s.tail - 1
  //                     s.queue_full <<= 0
  //                     collapse = 1
  // 
  //             # u,b,j type: ready to issue
  //             elif (s.queue[i].optype == U_TYPE) | (s.queue[i].optype == J_TYPE):
  //                 s.uop_out <<= s.queue[i]
  //                 s.tail <<= s.tail - 1
  //                 s.queue_full <<= 0
  //                 collapse = 1
  // 
  //     if collapse:
  //         s.queue_empty <<= (s.tail - 1) == 0
  //         s.queue[ISSUE_QUEUE_DEPTH - 1] <<= MicroOp(
  //             0,
  //             0,
  //             0,
  //             0,
  //             0,
  //             0,
  //             0,
  //             0,
  //             0,
  //             0,
  //             0,
  //             0,
  //             0,
  //             0,
  //             0,
  //             0,
  //             0,
  //             0,
  //         )
  // 
  //     # APPENDING new uops to queue, if valid
  //     if (
  //         s.duop_in.uop1.valid
  //         & s.duop_in.uop2.valid
  //         & (s.tail < (ISSUE_QUEUE_DEPTH - 1))
  //     ):
  //         s.queue[s.tail] <<= s.duop_in.uop1
  //         s.queue[s.tail + 1] <<= s.duop_in.uop2
  // 
  //         #  if overflow, no wrap around
  //         s.queue_empty <<= 0
  //         s.tail <<= s.tail + 2
  //         if s.tail + 2 == 0:
  //             s.queue_full <<= 1
  // 
  //     elif s.duop_in.uop1.valid & ~s.queue_full:
  //         s.queue[s.tail] <<= s.duop_in.uop1
  // 
  //         s.queue_empty <<= 0
  //         s.tail <<= s.tail + 1
  //         if s.tail + 1 == 0:
  //             s.queue_full <<= 1
  // 
  //     elif s.duop_in.uop2.valid & ~s.queue_full:
  //         s.queue[s.tail] <<= s.duop_in.uop2
  // 
  //         s.queue_empty <<= 0
  //         s.tail <<= s.tail + 1
  //         if s.tail + 1 == 0:
  //             s.queue_full <<= 1
  
  always_ff @(posedge clk) begin : ff
    if ( reset ) begin
      tail <= 4'd0;
      queue_full <= 1'd0;
      queue_empty <= 1'd1;
    end
    __tmpvar__ff_collapse = 1'd0;
    for ( int unsigned i = 1'd0; i < 5'( __const__ISSUE_QUEUE_DEPTH ); i += 1'd1 )
      if ( 1'(__tmpvar__ff_collapse) ) begin
        queue[4'(i) - 4'd1] <= queue[4'(i)];
      end
      else if ( queue[4'(i)].valid ) begin
        if ( ( ( queue[4'(i)].optype == 3'( __const__R_TYPE ) ) | ( queue[4'(i)].optype == 3'( __const__S_TYPE ) ) ) | ( queue[4'(i)].optype == 3'( __const__B_TYPE ) ) ) begin
          if ( ( ~busy_table[queue[4'(i)].prs1] ) & ( ~busy_table[queue[4'(i)].prs2] ) ) begin
            uop_out <= queue[4'(i)];
            tail <= tail - 4'd1;
            queue_full <= 1'd0;
            __tmpvar__ff_collapse = 1'd1;
          end
        end
        else if ( queue[4'(i)].optype == 3'( __const__I_TYPE ) ) begin
          if ( ~busy_table[queue[4'(i)].prs1] ) begin
            uop_out <= queue[4'(i)];
            tail <= tail - 4'd1;
            queue_full <= 1'd0;
            __tmpvar__ff_collapse = 1'd1;
          end
        end
        else if ( ( queue[4'(i)].optype == 3'( __const__U_TYPE ) ) | ( queue[4'(i)].optype == 3'( __const__J_TYPE ) ) ) begin
          uop_out <= queue[4'(i)];
          tail <= tail - 4'd1;
          queue_full <= 1'd0;
          __tmpvar__ff_collapse = 1'd1;
        end
      end
    if ( 1'(__tmpvar__ff_collapse) ) begin
      queue_empty <= ( tail - 4'd1 ) == 4'd0;
      queue[5'( __const__ISSUE_QUEUE_DEPTH ) - 5'd1] <= { 3'd0, 32'd0, 8'd0, 1'd0, 5'd0, 5'd0, 5'd0, 6'd0, 6'd0, 6'd0, 6'd0, 1'd0, 1'd0, 32'd0, 2'd0, 2'd0, 4'd0, 5'd0 };
    end
    if ( ( duop_in.uop1.valid & duop_in.uop2.valid ) & ( tail < ( 4'( __const__ISSUE_QUEUE_DEPTH ) - 4'd1 ) ) ) begin
      queue[tail] <= duop_in.uop1;
      queue[tail + 4'd1] <= duop_in.uop2;
      queue_empty <= 1'd0;
      tail <= tail + 4'd2;
      if ( ( tail + 4'd2 ) == 4'd0 ) begin
        queue_full <= 1'd1;
      end
    end
    else if ( duop_in.uop1.valid & ( ~queue_full ) ) begin
      queue[tail] <= duop_in.uop1;
      queue_empty <= 1'd0;
      tail <= tail + 4'd1;
      if ( ( tail + 4'd1 ) == 4'd0 ) begin
        queue_full <= 1'd1;
      end
    end
    else if ( duop_in.uop2.valid & ( ~queue_full ) ) begin
      queue[tail] <= duop_in.uop2;
      queue_empty <= 1'd0;
      tail <= tail + 4'd1;
      if ( ( tail + 4'd1 ) == 4'd0 ) begin
        queue_full <= 1'd1;
      end
    end
  end

endmodule
