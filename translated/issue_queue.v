//-------------------------------------------------------------------------
// IssueQueue.v
//-------------------------------------------------------------------------
// This file is generated by PyMTL SystemVerilog translation pass.

// PyMTL BitStruct MicroOp__c9b3dc01a081cc30 Definition
typedef struct packed {
  logic [5:0] uop_type;
  logic [31:0] inst;
  logic [7:0] pc;
  logic [0:0] valid;
  logic [4:0] lrd;
  logic [4:0] lrs1;
  logic [4:0] lrs2;
  logic [5:0] prd;
  logic [5:0] prs1;
  logic [5:0] prs2;
  logic [5:0] stale;
  logic [0:0] prs1_busy;
  logic [0:0] prs2_busy;
  logic [31:0] imm;
  logic [1:0] issue_unit;
  logic [1:0] fu_unit;
  logic [1:0] fu_op;
  logic [4:0] rob_idx;
} MicroOp__c9b3dc01a081cc30;

// PyMTL BitStruct DualMicroOp__080ef2515763923d Definition
typedef struct packed {
  MicroOp__c9b3dc01a081cc30 uop1;
  MicroOp__c9b3dc01a081cc30 uop2;
} DualMicroOp__080ef2515763923d;

// PyMTL Component IssueQueue Definition
// Full name: IssueQueue_noparam
// At /Users/curtisbucher/Desktop/ramp-core/src/cl/issue_queue.py

module IssueQueue
(
  input  logic [63:0] busy_table ,
  input  logic [0:0] clk ,
  input  DualMicroOp__080ef2515763923d duop_in ,
  input  logic [0:0] reset ,
  output MicroOp__c9b3dc01a081cc30 uop_out 
);
  logic [3:0] head;
  MicroOp__c9b3dc01a081cc30 queue [0:15];
  logic [3:0] tail;

  // PyMTL Update Block Source
  // At /Users/curtisbucher/Desktop/ramp-core/src/cl/issue_queue.py:26
  // @update_ff
  // def ff():
  //     # reset
  //     if s.reset:
  //         s.head <<= 0
  //         s.tail <<= 0
  //     else:
  //         # adding new uops to queue, if valid
  //         if(s.duop_in.uop1.valid & s.duop_in.uop2.valid):
  //             s.queue[s.tail] <<= s.duop_in.uop1
  //             s.queue[s.tail+1] <<= s.duop_in.uop2
  //             s.tail <<= s.tail + 2
  //         elif(s.duop_in.uop1.valid):
  //             s.queue[s.tail] <<= s.duop_in.uop1
  //             s.tail <<= s.tail + 1
  //         elif(s.duop_in.uop2.valid):
  //             s.queue[s.tail] <<= s.duop_in.uop2
  //             s.tail <<= s.tail + 1
  
  always_ff @(posedge clk) begin : ff
    if ( reset ) begin
      head <= 4'd0;
      tail <= 4'd0;
    end
    else if ( duop_in.uop1.valid & duop_in.uop2.valid ) begin
      queue[tail] <= duop_in.uop1;
      queue[tail + 4'd1] <= duop_in.uop2;
      tail <= tail + 4'd2;
    end
    else if ( duop_in.uop1.valid ) begin
      queue[tail] <= duop_in.uop1;
      tail <= tail + 4'd1;
    end
    else if ( duop_in.uop2.valid ) begin
      queue[tail] <= duop_in.uop2;
      tail <= tail + 4'd1;
    end
  end

endmodule
