//-------------------------------------------------------------------------
// MemoryUnit.v
//-------------------------------------------------------------------------
// This file is generated by PyMTL SystemVerilog translation pass.

// PyMTL BitStruct LoadEntry__data_32__rob_idx_5 Definition
typedef struct packed {
  logic [31:0] data;
  logic [4:0] rob_idx;
} LoadEntry__data_32__rob_idx_5;

// PyMTL BitStruct LoadStoreEntry__op_4__addr_32__data_32__rob_idx_5__mem_q_idx_4 Definition
typedef struct packed {
  logic [3:0] op;
  logic [31:0] addr;
  logic [31:0] data;
  logic [4:0] rob_idx;
  logic [3:0] mem_q_idx;
} LoadStoreEntry__op_4__addr_32__data_32__rob_idx_5__mem_q_idx_4;

// PyMTL Component DRAM Definition
// Full name: DRAM__Type_Bits32__num_entries_256__rd_ports_1__wr_ports_1__reset_value_0
// At /Users/curtisbucher/Desktop/ramp-core/src/cl/dram.py

module DRAM__361782fcf1c09bcb
(
  input  logic [0:0] clk ,
  input  logic [7:0] raddr [0:0],
  output logic [31:0] rdata [0:0],
  input  logic [0:0] reset ,
  input  logic [7:0] waddr [0:0],
  input  logic [31:0] wdata [0:0],
  input  logic [0:0] wen [0:0]
);
  localparam logic [0:0] __const__rd_ports_at_up_rf_read  = 1'd1;
  localparam logic [1:0] __const__addr_shift_at_up_rf_read  = 2'd2;
  localparam logic [8:0] __const__num_entries_at_up_rf_write  = 9'd256;
  localparam logic [0:0] __const__reset_value_at_up_rf_write  = 1'd0;
  localparam logic [0:0] __const__wr_ports_at_up_rf_write  = 1'd1;
  localparam logic [1:0] __const__addr_shift_at_up_rf_write  = 2'd2;
  logic [31:0] mem [0:255];

  // PyMTL Update Block Source
  // At /Users/curtisbucher/Desktop/ramp-core/src/cl/dram.py:33
  // @update
  // def up_rf_read():
  //     for i in range(rd_ports):
  //         # TODO: CL debugging
  //         # assert not (s.raddr[i] % (Type.nbits // 8)), f"Address must be {Type.nbits // 8}-byte aligned"
  //         # byte addressable
  //         s.rdata[i] @= s.mem[s.raddr[i] >> addr_shift]
  
  always_comb begin : up_rf_read
    for ( int unsigned i = 1'd0; i < 1'( __const__rd_ports_at_up_rf_read ); i += 1'd1 )
      rdata[1'(i)] = mem[raddr[1'(i)] >> 2'( __const__addr_shift_at_up_rf_read )];
  end

  // PyMTL Update Block Source
  // At /Users/curtisbucher/Desktop/ramp-core/src/cl/dram.py:41
  // @update_ff
  // def up_rf_write():
  //     if s.reset:
  //         for i in range(num_entries):
  //             s.mem[i] <<= reset_value
  //     else:
  //         for i in range(wr_ports):
  //             if s.wen[i]:
  //                 # TODO: CL debugging
  //                 # assert not (s.waddr[i] % (Type.nbits // 8)), f"Address must be {Type.nbits // 8}-byte aligned"
  //                 s.mem[s.waddr[i] >> addr_shift] <<= s.wdata[i]
  
  always_ff @(posedge clk) begin : up_rf_write
    if ( reset ) begin
      for ( int unsigned i = 1'd0; i < 9'( __const__num_entries_at_up_rf_write ); i += 1'd1 )
        mem[8'(i)] <= 32'( __const__reset_value_at_up_rf_write );
    end
    else
      for ( int unsigned i = 1'd0; i < 1'( __const__wr_ports_at_up_rf_write ); i += 1'd1 )
        if ( wen[1'(i)] ) begin
          mem[waddr[1'(i)] >> 2'( __const__addr_shift_at_up_rf_write )] <= wdata[1'(i)];
        end
  end

endmodule


// PyMTL Component MultiInputRdyCircularBuffer Definition
// Full name: MultiInputRdyCircularBuffer__Type_LoadStoreEntry__op_4__addr_32__data_32__rob_idx_5__mem_q_idx_4__size_16__num_inports_2
// At /Users/curtisbucher/Desktop/ramp-core/src/cl/buffers.py

module MultiInputRdyCircularBuffer__2ffcb48ba0961d6c
(
  input  logic [0:0] clk ,
  output logic [4:0] n_elements ,
  input  logic [0:0] reset ,
  output logic [3:0] tail ,
  input logic [0:0] allocate_in__en  ,
  input logic [4:0] allocate_in__msg  ,
  output logic [0:0] allocate_in__rdy  ,
  output logic [0:0] out__en  ,
  output LoadStoreEntry__op_4__addr_32__data_32__rob_idx_5__mem_q_idx_4 out__msg  ,
  input logic [0:0] out__rdy  ,
  input logic [0:0] update_idx_in__en [0:1] ,
  input logic [3:0] update_idx_in__msg [0:1] ,
  output logic [0:0] update_idx_in__rdy [0:1] ,
  input logic [0:0] update_in__en [0:1] ,
  input LoadStoreEntry__op_4__addr_32__data_32__rob_idx_5__mem_q_idx_4 update_in__msg [0:1] ,
  output logic [0:0] update_in__rdy [0:1] 
);
  localparam logic [4:0] __const__size_at_updt_comb  = 5'd16;
  localparam LoadStoreEntry__op_4__addr_32__data_32__rob_idx_5__mem_q_idx_4 __const__type_reset_val_at_updt_comb  = { 4'd0, 32'd0, 32'd0, 5'd0, 4'd0 };
  localparam logic [1:0] __const__num_inports_at_updt_comb  = 2'd2;
  localparam logic [1:0] __const__num_inports_at_updt_ff  = 2'd2;
  LoadStoreEntry__op_4__addr_32__data_32__rob_idx_5__mem_q_idx_4 buffer [0:15];
  logic [0:0] buffer_rdy [0:15];
  logic [0:0] empty;
  logic [0:0] full;
  logic [3:0] head;
  logic [3:0] head_next;
  logic [4:0] n_elements_next;
  logic [0:0] out_en_next;
  LoadStoreEntry__op_4__addr_32__data_32__rob_idx_5__mem_q_idx_4 out_next;
  logic [3:0] tail_next;

  // PyMTL Update Block Source
  // At /Users/curtisbucher/Desktop/ramp-core/src/cl/buffers.py:56
  // @update
  // def updt_comb():
  //     s.full @= s.n_elements == size
  //     s.empty @= s.n_elements == 0
  //     s.allocate_in.rdy @= ~s.full
  // 
  //     # reset
  //     if s.reset:
  //         s.out_next @= type_reset_val
  //         s.head_next @= 0
  //         s.tail_next @= 0
  //         s.n_elements_next @= 0
  //     else:
  //         # default values
  //         s.out_en_next @= 0
  //         s.head_next @= s.head
  //         s.tail_next @= s.tail
  //         s.n_elements_next @= s.n_elements
  // 
  //         # popping off stack if first element valid
  //         if s.out.rdy & ~s.empty:
  //             # checking head of stack
  //             if s.buffer_rdy[s.head]:
  //                 s.out_next @= s.buffer[s.head]
  //                 s.out_en_next @= 1
  //                 s.head_next @= s.head_next + 1
  //                 s.n_elements_next @= s.n_elements - 1
  //             # forwarding update inputs
  //             for i in range(num_inports):
  //                 # ensuring that update data has a corresponding index
  //                 # TODO: CL debugging
  //                 # assert ~(s.update_idx_in[i].en ^ s.update_in[i].en)
  //                 if s.update_idx_in[i].en & (s.update_idx_in[i].msg == s.head):
  //                     # checking that index has valid corresponding data
  //                     s.out_next @= s.update_in[i].msg
  //                     s.out_en_next @= 1
  //                     s.head_next @= s.head_next + 1
  //                     s.n_elements_next @= s.n_elements - 1
  // 
  //         # updating tail with elements allocated
  //         if s.allocate_in.en == 1:
  //             s.tail_next @= trunc(
  //                 zext(s.tail, s.n_elements_nbits) + s.allocate_in.msg,
  //                 s.tail_nbits
  //             )
  //             s.n_elements_next @= s.n_elements_next + zext(
  //                 s.allocate_in.msg,
  //                 s.n_elements_nbits
  //             )
  
  always_comb begin : updt_comb
    full = n_elements == 5'( __const__size_at_updt_comb );
    empty = n_elements == 5'd0;
    allocate_in__rdy = ~full;
    if ( reset ) begin
      out_next = 77'( __const__type_reset_val_at_updt_comb );
      head_next = 4'd0;
      tail_next = 4'd0;
      n_elements_next = 5'd0;
    end
    else begin
      out_en_next = 1'd0;
      head_next = head;
      tail_next = tail;
      n_elements_next = n_elements;
      if ( out__rdy & ( ~empty ) ) begin
        if ( buffer_rdy[head] ) begin
          out_next = buffer[head];
          out_en_next = 1'd1;
          head_next = head_next + 4'd1;
          n_elements_next = n_elements - 5'd1;
        end
        for ( int unsigned i = 1'd0; i < 2'( __const__num_inports_at_updt_comb ); i += 1'd1 )
          if ( update_idx_in__en[1'(i)] & ( update_idx_in__msg[1'(i)] == head ) ) begin
            out_next = update_in__msg[1'(i)];
            out_en_next = 1'd1;
            head_next = head_next + 4'd1;
            n_elements_next = n_elements - 5'd1;
          end
      end
      if ( allocate_in__en == 1'd1 ) begin
        tail_next = 4'({ { 1 { 1'b0 } }, tail } + allocate_in__msg);
        n_elements_next = n_elements_next + allocate_in__msg;
      end
    end
  end

  // PyMTL Update Block Source
  // At /Users/curtisbucher/Desktop/ramp-core/src/cl/buffers.py:106
  // @update_ff
  // def updt_ff():
  //     # reset
  //     # TODO: just set the first ready bit to 0?
  //     if s.reset:
  //         for i in range(num_inports):
  //             s.buffer_rdy[i] <<= 0
  // 
  //     # setting newely allocated elements to 0
  //     # if s.allocate_in.en:
  //     #     for i in range(num_inports):
  //     #         if (i > s.tail_next) & (i < s.head_next):
  //     #             s.buffer_rdy[i] <<= 0
  // 
  //     # updating data, and setting ready bit
  //     for i in range(num_inports):
  //         # ensuring that update data has a corresponding index
  //         # TODO: CL debugging
  //         # assert ~(
  //         #     s.update_idx_in[i].en ^ s.update_in[i].en
  //         # ), f"update idx[{i}] en: {s.update_idx_in[i].en}, update[{i}] en: {s.update_in[i].en}"
  //         if s.update_idx_in[i].en:
  //             s.buffer[s.update_idx_in[i].msg] <<= s.update_in[i].msg
  //             s.buffer_rdy[s.update_idx_in[i].msg] <<= 1
  // 
  //     # updating state
  //     s.tail <<= s.tail_next
  //     s.head <<= s.head_next
  //     s.out.msg <<= s.out_next
  //     s.out.en <<= s.out_en_next
  //     s.n_elements <<= s.n_elements_next
  
  always_ff @(posedge clk) begin : updt_ff
    if ( reset ) begin
      for ( int unsigned i = 1'd0; i < 2'( __const__num_inports_at_updt_ff ); i += 1'd1 )
        buffer_rdy[4'(i)] <= 1'd0;
    end
    for ( int unsigned i = 1'd0; i < 2'( __const__num_inports_at_updt_ff ); i += 1'd1 )
      if ( update_idx_in__en[1'(i)] ) begin
        buffer[update_idx_in__msg[1'(i)]] <= update_in__msg[1'(i)];
        buffer_rdy[update_idx_in__msg[1'(i)]] <= 1'd1;
      end
    tail <= tail_next;
    head <= head_next;
    out__msg <= out_next;
    out__en <= out_en_next;
    n_elements <= n_elements_next;
  end

  assign update_in__rdy[0] = 1'd1;
  assign update_idx_in__rdy[0] = 1'd1;
  assign update_in__rdy[1] = 1'd1;
  assign update_idx_in__rdy[1] = 1'd1;

endmodule


// PyMTL Component MemoryUnit Definition
// Full name: MemoryUnit__queue_size_16__memory_size_256__window_size_2__reset_value_0
// At /Users/curtisbucher/Desktop/ramp-core/src/cl/memory_unit.py

module MemoryUnit
(
  input  logic [0:0] clk ,
  output logic [3:0] mem_q_tail ,
  input  logic [0:0] reset ,
  input logic [0:0] allocate_in__en  ,
  input logic [1:0] allocate_in__msg  ,
  output logic [0:0] allocate_in__rdy  ,
  output logic [0:0] load_out__en  ,
  output LoadEntry__data_32__rob_idx_5 load_out__msg  ,
  input logic [0:0] load_out__rdy  ,
  input logic [0:0] update_in__en [0:1] ,
  input LoadStoreEntry__op_4__addr_32__data_32__rob_idx_5__mem_q_idx_4 update_in__msg [0:1] ,
  output logic [0:0] update_in__rdy [0:1] 
);
  localparam logic [3:0] __const__MEM_FLAG  = 4'd8;
  localparam logic [3:0] __const__MEM_STORE  = 4'd8;
  localparam logic [3:0] __const__MEM_LW  = 4'd2;
  localparam logic [3:0] __const__MEM_LH  = 4'd1;
  localparam logic [3:0] __const__MEM_LHU  = 4'd5;
  localparam logic [3:0] __const__MEM_LB  = 4'd0;
  localparam logic [3:0] __const__MEM_LBU  = 4'd4;
  localparam logic [3:0] __const__MEM_LOAD  = 4'd0;
  //-------------------------------------------------------------
  // Component dram
  //-------------------------------------------------------------

  logic [0:0] dram__clk;
  logic [7:0] dram__raddr [0:0];
  logic [31:0] dram__rdata [0:0];
  logic [0:0] dram__reset;
  logic [7:0] dram__waddr [0:0];
  logic [31:0] dram__wdata [0:0];
  logic [0:0] dram__wen [0:0];

  DRAM__361782fcf1c09bcb dram
  (
    .clk( dram__clk ),
    .raddr( dram__raddr ),
    .rdata( dram__rdata ),
    .reset( dram__reset ),
    .waddr( dram__waddr ),
    .wdata( dram__wdata ),
    .wen( dram__wen )
  );

  //-------------------------------------------------------------
  // End of component dram
  //-------------------------------------------------------------

  //-------------------------------------------------------------
  // Component ls_queue
  //-------------------------------------------------------------

  logic [0:0] ls_queue__clk;
  logic [4:0] ls_queue__n_elements;
  logic [0:0] ls_queue__reset;
  logic [3:0] ls_queue__tail;
  logic [0:0] ls_queue__allocate_in__en;
  logic [4:0] ls_queue__allocate_in__msg;
  logic [0:0] ls_queue__allocate_in__rdy;
  logic [0:0] ls_queue__out__en;
  LoadStoreEntry__op_4__addr_32__data_32__rob_idx_5__mem_q_idx_4 ls_queue__out__msg;
  logic [0:0] ls_queue__out__rdy;
  logic [0:0] ls_queue__update_idx_in__en [0:1];
  logic [3:0] ls_queue__update_idx_in__msg [0:1];
  logic [0:0] ls_queue__update_idx_in__rdy [0:1];
  logic [0:0] ls_queue__update_in__en [0:1];
  LoadStoreEntry__op_4__addr_32__data_32__rob_idx_5__mem_q_idx_4 ls_queue__update_in__msg [0:1];
  logic [0:0] ls_queue__update_in__rdy [0:1];

  MultiInputRdyCircularBuffer__2ffcb48ba0961d6c ls_queue
  (
    .clk( ls_queue__clk ),
    .n_elements( ls_queue__n_elements ),
    .reset( ls_queue__reset ),
    .tail( ls_queue__tail ),
    .allocate_in__en( ls_queue__allocate_in__en ),
    .allocate_in__msg( ls_queue__allocate_in__msg ),
    .allocate_in__rdy( ls_queue__allocate_in__rdy ),
    .out__en( ls_queue__out__en ),
    .out__msg( ls_queue__out__msg ),
    .out__rdy( ls_queue__out__rdy ),
    .update_idx_in__en( ls_queue__update_idx_in__en ),
    .update_idx_in__msg( ls_queue__update_idx_in__msg ),
    .update_idx_in__rdy( ls_queue__update_idx_in__rdy ),
    .update_in__en( ls_queue__update_in__en ),
    .update_in__msg( ls_queue__update_in__msg ),
    .update_in__rdy( ls_queue__update_in__rdy )
  );

  //-------------------------------------------------------------
  // End of component ls_queue
  //-------------------------------------------------------------

  // PyMTL Update Block Source
  // At /Users/curtisbucher/Desktop/ramp-core/src/cl/memory_unit.py:76
  // @update
  // def connect_():
  //     # connecting input to queue
  //     s.ls_queue.out.rdy @= 1
  //     s.ls_queue.allocate_in.msg @= zext(s.allocate_in.msg, queue_addr_nbits)
  //     s.ls_queue.allocate_in.en @= s.allocate_in.en
  //     s.allocate_in.rdy @= s.ls_queue.allocate_in.rdy
  // 
  //     # connecting memory to queue
  //     s.dram.raddr[0] @= trunc(s.ls_queue.out.msg.addr, mem_addr_nbits)
  //     s.dram.waddr[0] @= trunc(s.ls_queue.out.msg.addr, mem_addr_nbits)
  //     # slicing and signing happens in execution
  //     s.dram.wdata[0] @= s.ls_queue.out.msg.data
  // 
  //     s.dram.wen[0] @= s.ls_queue.out.en & (
  //         (s.ls_queue.out.msg.op & MEM_FLAG) == MEM_STORE
  //     )
  // 
  //     # connecting memory to load output
  //     if s.ls_queue.out.msg.op == MEM_LW:
  //         s.load_out.msg.data @= s.dram.rdata[0]
  //     elif s.ls_queue.out.msg.op == MEM_LH:
  //         s.load_out.msg.data @= sext(s.dram.rdata[0][0:16], 32)
  //     elif s.ls_queue.out.msg.op == MEM_LHU:
  //         s.load_out.msg.data @= zext(s.dram.rdata[0][0:16], 32)
  //     elif s.ls_queue.out.msg.op == MEM_LB:
  //         s.load_out.msg.data @= sext(s.dram.rdata[0][0:8], 32)
  //     elif s.ls_queue.out.msg.op == MEM_LBU:
  //         s.load_out.msg.data @= zext(s.dram.rdata[0][0:8], 32)
  //     else:
  //         s.load_out.msg.data @= s.dram.rdata[0]
  // 
  //     s.load_out.msg.rob_idx @= s.ls_queue.out.msg.rob_idx
  //     s.load_out.en @= s.ls_queue.out.en & (
  //         (s.ls_queue.out.msg.op & MEM_FLAG) == MEM_LOAD
  //     )
  
  always_comb begin : connect_
    ls_queue__out__rdy = 1'd1;
    ls_queue__allocate_in__msg = { { 3 { 1'b0 } }, allocate_in__msg };
    ls_queue__allocate_in__en = allocate_in__en;
    allocate_in__rdy = ls_queue__allocate_in__rdy;
    dram__raddr[1'd0] = 8'(ls_queue__out__msg.addr);
    dram__waddr[1'd0] = 8'(ls_queue__out__msg.addr);
    dram__wdata[1'd0] = ls_queue__out__msg.data;
    dram__wen[1'd0] = ls_queue__out__en & ( ( ls_queue__out__msg.op & 4'( __const__MEM_FLAG ) ) == 4'( __const__MEM_STORE ) );
    if ( ls_queue__out__msg.op == 4'( __const__MEM_LW ) ) begin
      load_out__msg.data = dram__rdata[1'd0];
    end
    else if ( ls_queue__out__msg.op == 4'( __const__MEM_LH ) ) begin
      load_out__msg.data = { { 16 { dram__rdata[1'd0][5'd15] } }, dram__rdata[1'd0][5'd15:5'd0] };
    end
    else if ( ls_queue__out__msg.op == 4'( __const__MEM_LHU ) ) begin
      load_out__msg.data = { { 16 { 1'b0 } }, dram__rdata[1'd0][5'd15:5'd0] };
    end
    else if ( ls_queue__out__msg.op == 4'( __const__MEM_LB ) ) begin
      load_out__msg.data = { { 24 { dram__rdata[1'd0][5'd7] } }, dram__rdata[1'd0][5'd7:5'd0] };
    end
    else if ( ls_queue__out__msg.op == 4'( __const__MEM_LBU ) ) begin
      load_out__msg.data = { { 24 { 1'b0 } }, dram__rdata[1'd0][5'd7:5'd0] };
    end
    else
      load_out__msg.data = dram__rdata[1'd0];
    load_out__msg.rob_idx = ls_queue__out__msg.rob_idx;
    load_out__en = ls_queue__out__en & ( ( ls_queue__out__msg.op & 4'( __const__MEM_FLAG ) ) == 4'( __const__MEM_LOAD ) );
  end

  assign ls_queue__clk = clk;
  assign ls_queue__reset = reset;
  assign mem_q_tail = ls_queue__tail;
  assign ls_queue__update_in__en[0] = update_in__en[0];
  assign ls_queue__update_in__msg[0] = update_in__msg[0];
  assign update_in__rdy[0] = ls_queue__update_in__rdy[0];
  assign ls_queue__update_idx_in__msg[0] = update_in__msg[0].mem_q_idx;
  assign ls_queue__update_idx_in__en[0] = update_in__en[0];
  assign ls_queue__update_in__en[1] = update_in__en[1];
  assign ls_queue__update_in__msg[1] = update_in__msg[1];
  assign update_in__rdy[1] = ls_queue__update_in__rdy[1];
  assign ls_queue__update_idx_in__msg[1] = update_in__msg[1].mem_q_idx;
  assign ls_queue__update_idx_in__en[1] = update_in__en[1];
  assign dram__clk = clk;
  assign dram__reset = reset;

endmodule
