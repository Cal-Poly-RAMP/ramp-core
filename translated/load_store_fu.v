//-------------------------------------------------------------------------
// LoadStoreFU.v
//-------------------------------------------------------------------------
// This file is generated by PyMTL SystemVerilog translation pass.

// PyMTL BitStruct LoadStoreEntry__op_4__addr_32__data_32__rob_idx_5__mem_q_idx_4 Definition
typedef struct packed {
  logic [3:0] op;
  logic [31:0] addr;
  logic [31:0] data;
  logic [4:0] rob_idx;
  logic [3:0] mem_q_idx;
} LoadStoreEntry__op_4__addr_32__data_32__rob_idx_5__mem_q_idx_4;

// PyMTL Component LoadStoreFU Definition
// Full name: LoadStoreFU_noparam
// At /Users/curtisbucher/Desktop/ramp-core/src/cl/load_store_fu.py

module LoadStoreFU
(
  input  logic [0:0] clk ,
  input  logic [0:0] enable ,
  input  logic [3:0] funct ,
  input  logic [31:0] imm_in ,
  input  logic [3:0] mem_q_idx_in ,
  input  logic [5:0] prd_addr_in ,
  input  logic [0:0] reset ,
  input  logic [4:0] rob_idx_in ,
  input  logic [31:0] rs1_din ,
  input  logic [31:0] rs2_din ,
  output logic [0:0] load_out__en  ,
  output LoadStoreEntry__op_4__addr_32__data_32__rob_idx_5__mem_q_idx_4 load_out__msg  ,
  input logic [0:0] load_out__rdy  ,
  output logic [0:0] store_out__en  ,
  output LoadStoreEntry__op_4__addr_32__data_32__rob_idx_5__mem_q_idx_4 store_out__msg  ,
  input logic [0:0] store_out__rdy  
);
  localparam logic [3:0] __const__MEM_FLAG  = 4'd8;
  localparam logic [3:0] __const__MEM_LOAD  = 4'd0;
  localparam logic [3:0] __const__MEM_STORE  = 4'd8;
  localparam logic [3:0] __const__MEM_SB  = 4'd8;
  localparam logic [3:0] __const__MEM_SH  = 4'd9;
  localparam logic [3:0] __const__MEM_SW  = 4'd10;

  // PyMTL Update Block Source
  // At /Users/curtisbucher/Desktop/ramp-core/src/cl/load_store_fu.py:36
  // @update
  // def updt():
  //     s.load_out.en @= s.enable & ((s.funct & MEM_FLAG) == MEM_LOAD)
  //     s.load_out.msg.op @= s.funct
  //     s.load_out.msg.addr @= sext(s.imm_in, 32) + s.rs1_din
  //     s.load_out.msg.data @= 0
  //     s.load_out.msg.rob_idx @= s.rob_idx_in
  //     s.load_out.msg.mem_q_idx @= s.mem_q_idx_in
  // 
  //     s.store_out.en @= s.enable & ((s.funct & MEM_FLAG) == MEM_STORE)
  //     s.store_out.msg.op @= s.funct
  //     s.store_out.msg.addr @= sext(s.imm_in, 32) + s.rs1_din
  //     s.store_out.msg.rob_idx @= s.rob_idx_in
  //     s.store_out.msg.mem_q_idx @= s.mem_q_idx_in
  // 
  //     # Getting data for store
  //     # TODO: update for 64 bit
  //     # calculating slice for subword
  //     if s.funct == MEM_SB:
  //         s.store_out.msg.data @= zext(s.rs2_din[0:8], 32)
  //     elif s.funct == MEM_SH:
  //         s.store_out.msg.data @= zext(s.rs2_din[0:16], 32)
  //     elif s.funct == MEM_SW:
  //         s.store_out.msg.data @= s.rs2_din
  //     else:
  //         s.store_out.msg.data @= s.rs2_din
  //     # TODO: CL debugging
  //     # assert ~s.enable | s.load_out.en | s.store_out.en, "Invalid funct"
  
  always_comb begin : updt
    load_out__en = enable & ( ( funct & 4'( __const__MEM_FLAG ) ) == 4'( __const__MEM_LOAD ) );
    load_out__msg.op = funct;
    load_out__msg.addr = imm_in + rs1_din;
    load_out__msg.data = 32'd0;
    load_out__msg.rob_idx = rob_idx_in;
    load_out__msg.mem_q_idx = mem_q_idx_in;
    store_out__en = enable & ( ( funct & 4'( __const__MEM_FLAG ) ) == 4'( __const__MEM_STORE ) );
    store_out__msg.op = funct;
    store_out__msg.addr = imm_in + rs1_din;
    store_out__msg.rob_idx = rob_idx_in;
    store_out__msg.mem_q_idx = mem_q_idx_in;
    if ( funct == 4'( __const__MEM_SB ) ) begin
      store_out__msg.data = { { 24 { 1'b0 } }, rs2_din[5'd7:5'd0] };
    end
    else if ( funct == 4'( __const__MEM_SH ) ) begin
      store_out__msg.data = { { 16 { 1'b0 } }, rs2_din[5'd15:5'd0] };
    end
    else if ( funct == 4'( __const__MEM_SW ) ) begin
      store_out__msg.data = rs2_din;
    end
    else
      store_out__msg.data = rs2_din;
  end

endmodule
