//-------------------------------------------------------------------------
// RampCore.v
//-------------------------------------------------------------------------
// This file is generated by PyMTL SystemVerilog translation pass.

// PyMTL BitStruct IOEntry__addr_32__data_32 Definition
typedef struct packed {
  logic [31:0] addr;
  logic [31:0] data;
} IOEntry__addr_32__data_32;

// PyMTL BitStruct MicroOp__38e2b09b91e4b306 Definition
typedef struct packed {
  logic [2:0] optype;
  logic [31:0] inst;
  logic [31:0] pc;
  logic [0:0] valid;
  logic [4:0] lrd;
  logic [4:0] lrs1;
  logic [4:0] lrs2;
  logic [5:0] prd;
  logic [5:0] prs1;
  logic [5:0] prs2;
  logic [5:0] stale;
  logic [31:0] imm;
  logic [1:0] issue_unit;
  logic [1:0] funct_unit;
  logic [3:0] funct_op;
  logic [0:0] branch_taken;
  logic [7:0] br_mask;
  logic [2:0] br_tag;
  logic [4:0] rob_idx;
  logic [3:0] mem_q_idx;
} MicroOp__38e2b09b91e4b306;

// PyMTL BitStruct DualMicroOp__93e30b890d7542af Definition
typedef struct packed {
  MicroOp__38e2b09b91e4b306 uop1;
  MicroOp__38e2b09b91e4b306 uop2;
} DualMicroOp__93e30b890d7542af;

// PyMTL BitStruct BranchUpdate__target_32__mispredict_1__tag_3 Definition
typedef struct packed {
  logic [31:0] target;
  logic [0:0] mispredict;
  logic [2:0] tag;
} BranchUpdate__target_32__mispredict_1__tag_3;

// PyMTL BitStruct ROBEntryUop__0a11cf2a2340c105 Definition
typedef struct packed {
  logic [0:0] valid;
  logic [0:0] busy;
  logic [2:0] optype;
  logic [5:0] prd;
  logic [5:0] stale;
  logic [31:0] data;
  logic [3:0] mem_q_idx;
  logic [31:0] store_addr;
  logic [31:0] br_target;
  logic [2:0] br_tag;
  logic [0:0] br_mispredict;
  logic [7:0] br_mask;
} ROBEntryUop__0a11cf2a2340c105;

// PyMTL BitStruct ROBEntry__dfb4245d7bc69416 Definition
typedef struct packed {
  logic [31:0] pc;
  ROBEntryUop__0a11cf2a2340c105 uop1_entry;
  ROBEntryUop__0a11cf2a2340c105 uop2_entry;
} ROBEntry__dfb4245d7bc69416;

// PyMTL BitStruct LoadStoreEntry__op_4__addr_32__data_32__rob_idx_5__mem_q_idx_4 Definition
typedef struct packed {
  logic [3:0] op;
  logic [31:0] addr;
  logic [31:0] data;
  logic [4:0] rob_idx;
  logic [3:0] mem_q_idx;
} LoadStoreEntry__op_4__addr_32__data_32__rob_idx_5__mem_q_idx_4;

// PyMTL BitStruct FetchPacket__pc_32__branch_taken_1__inst1_32__inst2_32__valid_1 Definition
typedef struct packed {
  logic [31:0] pc;
  logic [0:0] branch_taken;
  logic [31:0] inst1;
  logic [31:0] inst2;
  logic [0:0] valid;
} FetchPacket__pc_32__branch_taken_1__inst1_32__inst2_32__valid_1;

// PyMTL BitStruct LoadEntry__data_32__rob_idx_5 Definition
typedef struct packed {
  logic [31:0] data;
  logic [4:0] rob_idx;
} LoadEntry__data_32__rob_idx_5;

// PyMTL BitStruct ExecToROB__894aaf470679b4c5 Definition
typedef struct packed {
  logic [4:0] int_rob_idx;
  logic [0:0] int_rob_complete;
  logic [31:0] int_data;
  logic [4:0] load_rob_idx;
  logic [0:0] load_rob_complete;
  logic [31:0] load_data;
  logic [4:0] store_rob_idx;
  logic [3:0] store_mem_q_idx;
  logic [0:0] store_rob_complete;
  logic [31:0] store_addr;
  logic [31:0] store_data;
  logic [4:0] br_rob_idx;
  logic [0:0] br_rob_complete;
  logic [31:0] br_target;
  logic [0:0] br_mispredict;
  logic [2:0] br_tag;
} ExecToROB__894aaf470679b4c5;

// PyMTL BitStruct PhysicalRegs__prd_6__prs1_6__prs2_6__stale_6 Definition
typedef struct packed {
  logic [5:0] prd;
  logic [5:0] prs1;
  logic [5:0] prs2;
  logic [5:0] stale;
} PhysicalRegs__prd_6__prs1_6__prs2_6__stale_6;

// PyMTL BitStruct PRegBusy__prs1_1__prs2_1 Definition
typedef struct packed {
  logic [0:0] prs1;
  logic [0:0] prs2;
} PRegBusy__prs1_1__prs2_1;

// PyMTL BitStruct LogicalRegs__lrd_5__lrs1_5__lrs2_5 Definition
typedef struct packed {
  logic [4:0] lrd;
  logic [4:0] lrs1;
  logic [4:0] lrs2;
} LogicalRegs__lrd_5__lrs1_5__lrs2_5;

// PyMTL Component ALU Definition
// At /home/cubucher/Desktop/ramp-core/src/cl/alu.py

module ALU__Type_Bits32
(
  input  logic [31:0] a ,
  input  logic [31:0] b ,
  input  logic [0:0] clk ,
  input  logic [3:0] op ,
  output logic [31:0] out ,
  input  logic [0:0] reset 
);
  localparam logic [3:0] __const__ALU_ADD  = 4'd0;
  localparam logic [3:0] __const__ALU_SUB  = 4'd8;
  localparam logic [3:0] __const__ALU_OR  = 4'd6;
  localparam logic [3:0] __const__ALU_AND  = 4'd7;
  localparam logic [3:0] __const__ALU_XOR  = 4'd4;
  localparam logic [3:0] __const__ALU_SRL  = 4'd5;
  localparam logic [3:0] __const__ALU_SLL  = 4'd1;
  localparam logic [3:0] __const__ALU_SRA  = 4'd13;
  localparam logic [31:0] __const__ONES_at_updt  = 32'd4294967295;
  localparam logic [3:0] __const__ALU_SLT  = 4'd2;
  localparam logic [3:0] __const__ALU_SLTU  = 4'd3;
  localparam logic [3:0] __const__ALU_LUI_COPY  = 4'd9;
  logic [31:0] b_sub;

  // PyMTL Update Block Source
  // At /home/cubucher/Desktop/ramp-core/src/cl/alu.py:30
  // @update
  // def updt():
  //     # s.b[4:0] (for 32 bit) s.b[7:0] (for 64 bit)
  //     s.b_sub @= s.b & (Type.nbits - 1)
  // 
  //     # ADD
  //     if s.op == ALU_ADD:
  //         s.out @= s.a + s.b
  //     # SUB
  //     elif s.op == ALU_SUB:
  //         s.out @= s.a - s.b
  //     # OR
  //     elif s.op == ALU_OR:
  //         s.out @= s.a | s.b
  //     # AND
  //     elif s.op == ALU_AND:
  //         s.out @= s.a & s.b
  //     # XOR
  //     elif s.op == ALU_XOR:
  //         s.out @= s.a ^ s.b
  //     # Shift Right Logical
  //     elif s.op == ALU_SRL:
  //         s.out @= s.a >> s.b_sub
  //     # Shift Left Logical
  //     elif s.op == ALU_SLL:
  //         # s.a << s.b[4:0] (for 32 bit)
  //         s.out @= s.a << s.b_sub
  //     # Shift Right Arithmetic
  //     elif s.op == ALU_SRA:
  //         # s.a >>> s.b[4:0] (for 32 bit)
  //         if s.a[Type.nbits - 1]:
  //             s.out @= (s.a >> s.b_sub) | ~(ONES >> s.b_sub)
  //         else:
  //             s.out @= s.a >> s.b_sub
  //     # Set Less Than TODO: `and` may not work
  //     elif s.op == ALU_SLT:
  //         if s.a[Type.nbits - 1] ^ s.b[Type.nbits - 1]:
  //             s.out @= zext(s.a[Type.nbits - 1], Type.nbits)
  //         elif s.a < s.b:
  //             s.out @= 1
  //         else:
  //             s.out @= 0
  //     # Set Less Than Unsigned
  //     elif s.op == ALU_SLTU:
  //         s.out @= 1 if (s.a < s.b) else 0  # TODO: Better way to do this?
  //     # Load Upper Immediate Copy
  //     elif s.op == ALU_LUI_COPY:
  //         s.out @= s.b
  //     else:
  //         s.out @= 0
  
  always_comb begin : updt
    b_sub = b & ( 32'd32 - 32'd1 );
    if ( op == 4'( __const__ALU_ADD ) ) begin
      out = a + b;
    end
    else if ( op == 4'( __const__ALU_SUB ) ) begin
      out = a - b;
    end
    else if ( op == 4'( __const__ALU_OR ) ) begin
      out = a | b;
    end
    else if ( op == 4'( __const__ALU_AND ) ) begin
      out = a & b;
    end
    else if ( op == 4'( __const__ALU_XOR ) ) begin
      out = a ^ b;
    end
    else if ( op == 4'( __const__ALU_SRL ) ) begin
      out = a >> b_sub;
    end
    else if ( op == 4'( __const__ALU_SLL ) ) begin
      out = a << b_sub;
    end
    else if ( op == 4'( __const__ALU_SRA ) ) begin
      if ( a[6'd32 - 6'd1] ) begin
        out = ( a >> b_sub ) | ( ~( 32'( __const__ONES_at_updt ) >> b_sub ) );
      end
      else
        out = a >> b_sub;
    end
    else if ( op == 4'( __const__ALU_SLT ) ) begin
      if ( a[6'd32 - 6'd1] ^ b[6'd32 - 6'd1] ) begin
        out = { { 31 { 1'b0 } }, a[6'd32 - 6'd1] };
      end
      else if ( a < b ) begin
        out = 32'd1;
      end
      else
        out = 32'd0;
    end
    else if ( op == 4'( __const__ALU_SLTU ) ) begin
      out = ( a < b ) ? 32'd1 : 32'd0;
    end
    else if ( op == 4'( __const__ALU_LUI_COPY ) ) begin
      out = b;
    end
    else
      out = 32'd0;
  end

endmodule


// PyMTL Component IssueQueue Definition
// At /home/cubucher/Desktop/ramp-core/src/cl/issue_queue.py

module IssueQueue_noparam
(
  input  logic [63:0] busy_table ,
  input  logic [0:0] clk ,
  input  DualMicroOp__93e30b890d7542af duop_in ,
  output logic [0:0] queue_empty ,
  output logic [0:0] queue_empty_next ,
  output logic [0:0] queue_full ,
  output logic [0:0] queue_full_next ,
  input  logic [0:0] reset ,
  output MicroOp__38e2b09b91e4b306 uop_out ,
  output MicroOp__38e2b09b91e4b306 uop_out_next 
);
  localparam logic [167:0] __const__NO_OP  = 168'd0;
  localparam logic [4:0] __const__ISSUE_QUEUE_DEPTH  = 5'd16;
  localparam logic [0:0] __const__R_TYPE  = 1'd1;
  localparam logic [1:0] __const__S_TYPE  = 2'd3;
  localparam logic [2:0] __const__B_TYPE  = 3'd4;
  localparam logic [1:0] __const__I_TYPE  = 2'd2;
  localparam logic [2:0] __const__U_TYPE  = 3'd5;
  localparam logic [2:0] __const__J_TYPE  = 3'd6;
  MicroOp__38e2b09b91e4b306 queue [0:15];
  MicroOp__38e2b09b91e4b306 queue_next [0:15];
  logic [3:0] tail;
  logic [3:0] tail_next;
  logic [0:0] __tmpvar__comb_collapse;

  // PyMTL Update Block Source
  // At /home/cubucher/Desktop/ramp-core/src/cl/issue_queue.py:49
  // @update
  // def comb():
  //     # reset
  //     collapse = 0
  //     s.tail_next @= 0
  //     s.queue_full_next @= 0
  //     s.queue_empty_next @= 1
  //     s.uop_out_next @= NO_OP
  //     for i in range(ISSUE_QUEUE_DEPTH):
  //         s.queue_next[i] @= NO_OP
  // 
  //     if ~s.reset:
  //         # APPENDING new uops to queue, if valid
  //         for i in range(ISSUE_QUEUE_DEPTH):
  //             s.queue_next[i] @= s.queue[i]
  //         s.uop_out_next @= NO_OP
  //         s.tail_next @= s.tail
  //         s.queue_full_next @= s.queue_full
  //         s.queue_empty_next @= s.queue_empty
  // 
  //         if (
  //             s.duop_in.uop1.valid
  //             & s.duop_in.uop2.valid
  //             & (s.tail_next < (ISSUE_QUEUE_DEPTH - 1))
  //         ):
  //             s.queue_next[s.tail_next] @= s.duop_in.uop1
  //             s.queue_next[s.tail_next + 1] @= s.duop_in.uop2
  // 
  //             #  if overflow, no wrap around
  //             s.queue_empty_next @= 0
  //             s.tail_next @= s.tail_next + 2
  //             if s.tail_next == 0:
  //                 s.queue_full_next @= 1
  // 
  //         elif s.duop_in.uop1.valid & ~s.queue_full:
  //             s.queue_next[s.tail_next] @= s.duop_in.uop1
  // 
  //             s.queue_empty_next @= 0
  //             s.tail_next @= s.tail_next + 1
  //             if s.tail_next == 0:
  //                 s.queue_full_next @= 1
  // 
  //         elif s.duop_in.uop2.valid & ~s.queue_full:
  //             s.queue_next[s.tail_next] @= s.duop_in.uop2
  // 
  //             s.queue_empty_next @= 0
  //             s.tail_next @= s.tail_next + 1
  //             if s.tail_next == 0:
  //                 s.queue_full_next @= 1
  // 
  //         # ISSUING uops from queue, if ready
  //         for i in range(ISSUE_QUEUE_DEPTH):
  //             # s.queue_next[i] @= s.queue[i]
  //             # if instruction has already been issued, collapse queue to fill in
  //             if collapse:
  //                 s.queue_next[i - 1] @= s.queue_next[i]
  //             # if not busy and valid, issue
  //             elif s.queue_next[i].valid:
  //                 # r,s,b type: need rs1, rs2 to be not busy
  //                 if (
  //                     (s.queue_next[i].optype == R_TYPE)
  //                     | (s.queue_next[i].optype == S_TYPE)
  //                     | (s.queue_next[i].optype == B_TYPE)
  //                 ):
  //                     if (
  //                         ~s.busy_table[s.queue_next[i].prs1]
  //                         & ~s.busy_table[s.queue_next[i].prs2]
  //                     ):
  //                         s.uop_out_next @= s.queue_next[i]
  //                         s.tail_next @= s.tail_next - 1
  //                         s.queue_full_next @= 0
  //                         collapse = 1
  // 
  //                 # i type: need rs1 to be not busy
  //                 elif s.queue_next[i].optype == I_TYPE:
  //                     if ~s.busy_table[s.queue_next[i].prs1]:
  //                         s.uop_out_next @= s.queue_next[i]
  //                         s.tail_next @= s.tail_next - 1
  //                         s.queue_full_next @= 0
  //                         collapse = 1
  // 
  //                 # u,b,j type: ready to issue
  //                 elif (s.queue_next[i].optype == U_TYPE) | (
  //                     s.queue_next[i].optype == J_TYPE
  //                 ):
  //                     s.uop_out_next @= s.queue_next[i]
  //                     s.tail_next @= s.tail_next - 1
  //                     s.queue_full_next @= 0
  //                     collapse = 1
  // 
  //         if collapse:
  //             s.queue_empty_next @= (s.tail_next - 1) == 0
  //             s.queue_next[ISSUE_QUEUE_DEPTH - 1] @= NO_OP
  
  always_comb begin : comb
    __tmpvar__comb_collapse = 1'd0;
    tail_next = 4'd0;
    queue_full_next = 1'd0;
    queue_empty_next = 1'd1;
    uop_out_next = 168'( __const__NO_OP );
    for ( int unsigned i = 1'd0; i < 5'( __const__ISSUE_QUEUE_DEPTH ); i += 1'd1 )
      queue_next[4'(i)] = 168'( __const__NO_OP );
    if ( ~reset ) begin
      for ( int unsigned i = 1'd0; i < 5'( __const__ISSUE_QUEUE_DEPTH ); i += 1'd1 )
        queue_next[4'(i)] = queue[4'(i)];
      uop_out_next = 168'( __const__NO_OP );
      tail_next = tail;
      queue_full_next = queue_full;
      queue_empty_next = queue_empty;
      if ( ( duop_in.uop1.valid & duop_in.uop2.valid ) & ( tail_next < ( 4'( __const__ISSUE_QUEUE_DEPTH ) - 4'd1 ) ) ) begin
        queue_next[tail_next] = duop_in.uop1;
        queue_next[tail_next + 4'd1] = duop_in.uop2;
        queue_empty_next = 1'd0;
        tail_next = tail_next + 4'd2;
        if ( tail_next == 4'd0 ) begin
          queue_full_next = 1'd1;
        end
      end
      else if ( duop_in.uop1.valid & ( ~queue_full ) ) begin
        queue_next[tail_next] = duop_in.uop1;
        queue_empty_next = 1'd0;
        tail_next = tail_next + 4'd1;
        if ( tail_next == 4'd0 ) begin
          queue_full_next = 1'd1;
        end
      end
      else if ( duop_in.uop2.valid & ( ~queue_full ) ) begin
        queue_next[tail_next] = duop_in.uop2;
        queue_empty_next = 1'd0;
        tail_next = tail_next + 4'd1;
        if ( tail_next == 4'd0 ) begin
          queue_full_next = 1'd1;
        end
      end
      for ( int unsigned i = 1'd0; i < 5'( __const__ISSUE_QUEUE_DEPTH ); i += 1'd1 )
        if ( 1'(__tmpvar__comb_collapse) ) begin
          queue_next[4'(i) - 4'd1] = queue_next[4'(i)];
        end
        else if ( queue_next[4'(i)].valid ) begin
          if ( ( ( queue_next[4'(i)].optype == 3'( __const__R_TYPE ) ) | ( queue_next[4'(i)].optype == 3'( __const__S_TYPE ) ) ) | ( queue_next[4'(i)].optype == 3'( __const__B_TYPE ) ) ) begin
            if ( ( ~busy_table[queue_next[4'(i)].prs1] ) & ( ~busy_table[queue_next[4'(i)].prs2] ) ) begin
              uop_out_next = queue_next[4'(i)];
              tail_next = tail_next - 4'd1;
              queue_full_next = 1'd0;
              __tmpvar__comb_collapse = 1'd1;
            end
          end
          else if ( queue_next[4'(i)].optype == 3'( __const__I_TYPE ) ) begin
            if ( ~busy_table[queue_next[4'(i)].prs1] ) begin
              uop_out_next = queue_next[4'(i)];
              tail_next = tail_next - 4'd1;
              queue_full_next = 1'd0;
              __tmpvar__comb_collapse = 1'd1;
            end
          end
          else if ( ( queue_next[4'(i)].optype == 3'( __const__U_TYPE ) ) | ( queue_next[4'(i)].optype == 3'( __const__J_TYPE ) ) ) begin
            uop_out_next = queue_next[4'(i)];
            tail_next = tail_next - 4'd1;
            queue_full_next = 1'd0;
            __tmpvar__comb_collapse = 1'd1;
          end
        end
      if ( 1'(__tmpvar__comb_collapse) ) begin
        queue_empty_next = ( tail_next - 4'd1 ) == 4'd0;
        queue_next[5'( __const__ISSUE_QUEUE_DEPTH ) - 5'd1] = 168'( __const__NO_OP );
      end
    end
  end

  // PyMTL Update Block Source
  // At /home/cubucher/Desktop/ramp-core/src/cl/issue_queue.py:143
  // @update_ff
  // def ff():
  //     s.tail <<= s.tail_next
  //     s.queue_full <<= s.queue_full_next
  //     s.queue_empty <<= s.queue_empty_next
  //     s.uop_out <<= s.uop_out_next
  //     for i in range(ISSUE_QUEUE_DEPTH):
  //         s.queue[i] <<= s.queue_next[i]
  
  always_ff @(posedge clk) begin : ff
    tail <= tail_next;
    queue_full <= queue_full_next;
    queue_empty <= queue_empty_next;
    uop_out <= uop_out_next;
    for ( int unsigned i = 1'd0; i < 5'( __const__ISSUE_QUEUE_DEPTH ); i += 1'd1 )
      queue[4'(i)] <= queue_next[4'(i)];
  end

endmodule


// PyMTL Component BranchFU Definition
// At /home/cubucher/Desktop/ramp-core/src/cl/branch_fu.py

module BranchFU_noparam
(
  input  logic [0:0] clk ,
  input  logic [0:0] reset ,
  input  logic [31:0] rs1_din ,
  input  logic [31:0] rs2_din ,
  input  MicroOp__38e2b09b91e4b306 uop ,
  output logic [0:0] br_update__en  ,
  output BranchUpdate__target_32__mispredict_1__tag_3 br_update__msg  ,
  input logic [0:0] br_update__rdy  
);
  localparam logic [1:0] __const__BRANCH_FUNCT_UNIT  = 2'd3;
  localparam logic [3:0] __const__BFU_BEQ  = 4'd0;
  localparam logic [3:0] __const__BFU_BNE  = 4'd1;
  localparam logic [3:0] __const__BFU_BLT  = 4'd4;
  localparam logic [3:0] __const__BFU_BGE  = 4'd5;
  localparam logic [3:0] __const__BFU_BLTU  = 4'd6;
  localparam logic [3:0] __const__BFU_BGEU  = 4'd7;
  logic [0:0] __tmpvar__updt_rs1_neg;
  logic [0:0] __tmpvar__updt_rs2_neg;
  logic [0:0] __tmpvar__updt_sign_diff;

  // PyMTL Update Block Source
  // At /home/cubucher/Desktop/ramp-core/src/cl/branch_fu.py:29
  // @update
  // def updt():
  //     # for signed logic
  //     rs1_neg = s.rs1_din[32 - 1]
  //     rs2_neg = s.rs2_din[32 - 1]
  //     sign_diff = rs1_neg ^ rs2_neg
  //     s.br_update.en @= s.uop.funct_unit == BRANCH_FUNCT_UNIT
  //     s.br_update.msg.tag @= s.uop.br_tag
  // 
  //     # if branch taken...
  //     if (
  //         ((s.uop.funct_op == BFU_BEQ) & (s.rs1_din == s.rs2_din))
  //         | ((s.uop.funct_op == BFU_BNE) & (s.rs1_din != s.rs2_din))
  //         | (
  //             (s.uop.funct_op == BFU_BLT)
  //             & ((sign_diff & rs1_neg) | (~sign_diff & (s.rs1_din < s.rs2_din)))
  //         )
  //         | (
  //             (s.uop.funct_op == BFU_BGE)
  //             & ((sign_diff & rs2_neg) | (~sign_diff & (s.rs1_din >= s.rs2_din)))
  //         )
  //         | ((s.uop.funct_op == BFU_BLTU) & (s.rs1_din < s.rs2_din))
  //         | ((s.uop.funct_op == BFU_BGEU) & (s.rs1_din >= s.rs2_din))
  //     ):
  // 
  //         # mispredict if branch is predicted not taken but taken
  //         s.br_update.msg.mispredict @= ~s.uop.branch_taken
  //         s.br_update.msg.target @= s.uop.pc + s.uop.imm
  // 
  //     # if branch not taken...
  //     else:
  //         # mispredict if branch is predicted taken but not taken
  //         s.br_update.msg.mispredict @= s.uop.branch_taken
  //         s.br_update.msg.target @= s.uop.pc + 8
  
  always_comb begin : updt
    __tmpvar__updt_rs1_neg = rs1_din[6'd32 - 6'd1];
    __tmpvar__updt_rs2_neg = rs2_din[6'd32 - 6'd1];
    __tmpvar__updt_sign_diff = __tmpvar__updt_rs1_neg ^ __tmpvar__updt_rs2_neg;
    br_update__en = uop.funct_unit == 2'( __const__BRANCH_FUNCT_UNIT );
    br_update__msg.tag = uop.br_tag;
    if ( ( ( ( ( ( ( uop.funct_op == 4'( __const__BFU_BEQ ) ) & ( rs1_din == rs2_din ) ) | ( ( uop.funct_op == 4'( __const__BFU_BNE ) ) & ( rs1_din != rs2_din ) ) ) | ( ( uop.funct_op == 4'( __const__BFU_BLT ) ) & ( ( __tmpvar__updt_sign_diff & __tmpvar__updt_rs1_neg ) | ( ( ~__tmpvar__updt_sign_diff ) & ( rs1_din < rs2_din ) ) ) ) ) | ( ( uop.funct_op == 4'( __const__BFU_BGE ) ) & ( ( __tmpvar__updt_sign_diff & __tmpvar__updt_rs2_neg ) | ( ( ~__tmpvar__updt_sign_diff ) & ( rs1_din >= rs2_din ) ) ) ) ) | ( ( uop.funct_op == 4'( __const__BFU_BLTU ) ) & ( rs1_din < rs2_din ) ) ) | ( ( uop.funct_op == 4'( __const__BFU_BGEU ) ) & ( rs1_din >= rs2_din ) ) ) begin
      br_update__msg.mispredict = ~uop.branch_taken;
      br_update__msg.target = uop.pc + uop.imm;
    end
    else begin
      br_update__msg.mispredict = uop.branch_taken;
      br_update__msg.target = uop.pc + 32'd8;
    end
  end

endmodule


// PyMTL Component SingleCommit Definition
// At /home/cubucher/Desktop/ramp-core/src/cl/commit_unit.py

module SingleCommit_noparam
(
  input  logic [0:0] clk ,
  input  ROBEntryUop__0a11cf2a2340c105 in_ ,
  output logic [5:0] ready_out ,
  output logic [5:0] reg_wb_addr ,
  output logic [31:0] reg_wb_data ,
  output logic [0:0] reg_wb_en ,
  input  logic [0:0] reset ,
  output logic [5:0] stale_out ,
  output logic [0:0] br_update__en  ,
  output BranchUpdate__target_32__mispredict_1__tag_3 br_update__msg  ,
  input logic [0:0] br_update__rdy  ,
  output logic [0:0] store_out__en  ,
  output LoadStoreEntry__op_4__addr_32__data_32__rob_idx_5__mem_q_idx_4 store_out__msg  ,
  input logic [0:0] store_out__rdy  
);
  localparam logic [3:0] __const__MEM_STORE  = 4'd8;
  localparam logic [2:0] __const__B_TYPE  = 3'd4;
  localparam logic [2:0] __const__J_TYPE  = 3'd6;
  localparam logic [1:0] __const__S_TYPE  = 2'd3;

  // PyMTL Update Block Source
  // At /home/cubucher/Desktop/ramp-core/src/cl/commit_unit.py:76
  // @update
  // def comb_():
  //     s.reg_wb_en @= 0
  //     s.reg_wb_addr @= 0
  //     s.reg_wb_data @= 0
  //     s.stale_out @= 0
  //     s.ready_out @= 0
  // 
  //     s.store_out.en @= 0
  //     s.store_out.msg.addr @= 0
  //     s.store_out.msg.data @= 0
  //     s.store_out.msg.rob_idx @= 0
  //     s.store_out.msg.mem_q_idx @= 0
  //     s.store_out.msg.op @= MEM_STORE
  // 
  //     s.br_update.en @= 0
  //     s.br_update.msg.target @= 0
  //     s.br_update.msg.mispredict @= 0
  //     s.br_update.msg.tag @= 0
  // 
  //     # writeback loads / arithmetic to registers
  //     if s.in_.valid:
  //         # handling branchs TODO: need to handle JALR and linking registers (i-type)
  //         if (s.in_.optype == B_TYPE) | (s.in_.optype == J_TYPE):
  //             s.br_update.en @= 1
  //             s.br_update.msg.target @= s.in_.br_target
  //             s.br_update.msg.mispredict @= s.in_.br_mispredict
  //             s.br_update.msg.tag @= s.in_.br_tag
  //         # writeback stores to memory
  //         elif s.in_.optype == S_TYPE:
  //             s.store_out.en @= 1
  //             s.store_out.msg.addr @= s.in_.store_addr
  //             s.store_out.msg.data @= s.in_.data
  //             s.store_out.msg.mem_q_idx @= s.in_.mem_q_idx
  //             s.stale_out @= 0
  //             s.ready_out @= 0
  //         # writeback to registers
  //         else:
  //             s.reg_wb_en @= 1
  //             s.reg_wb_addr @= s.in_.prd
  //             s.reg_wb_data @= s.in_.data
  //             s.stale_out @= s.in_.stale
  //             s.ready_out @= s.in_.prd
  
  always_comb begin : comb_
    reg_wb_en = 1'd0;
    reg_wb_addr = 6'd0;
    reg_wb_data = 32'd0;
    stale_out = 6'd0;
    ready_out = 6'd0;
    store_out__en = 1'd0;
    store_out__msg.addr = 32'd0;
    store_out__msg.data = 32'd0;
    store_out__msg.rob_idx = 5'd0;
    store_out__msg.mem_q_idx = 4'd0;
    store_out__msg.op = 4'( __const__MEM_STORE );
    br_update__en = 1'd0;
    br_update__msg.target = 32'd0;
    br_update__msg.mispredict = 1'd0;
    br_update__msg.tag = 3'd0;
    if ( in_.valid ) begin
      if ( ( in_.optype == 3'( __const__B_TYPE ) ) | ( in_.optype == 3'( __const__J_TYPE ) ) ) begin
        br_update__en = 1'd1;
        br_update__msg.target = in_.br_target;
        br_update__msg.mispredict = in_.br_mispredict;
        br_update__msg.tag = in_.br_tag;
      end
      else if ( in_.optype == 3'( __const__S_TYPE ) ) begin
        store_out__en = 1'd1;
        store_out__msg.addr = in_.store_addr;
        store_out__msg.data = in_.data;
        store_out__msg.mem_q_idx = in_.mem_q_idx;
        stale_out = 6'd0;
        ready_out = 6'd0;
      end
      else begin
        reg_wb_en = 1'd1;
        reg_wb_addr = in_.prd;
        reg_wb_data = in_.data;
        stale_out = in_.stale;
        ready_out = in_.prd;
      end
    end
  end

endmodule


// PyMTL Component CommitUnit Definition
// At /home/cubucher/Desktop/ramp-core/src/cl/commit_unit.py

module CommitUnit__width_2
(
  input  logic [0:0] clk ,
  input  ROBEntry__dfb4245d7bc69416 in_ ,
  output logic [5:0] ready_out [0:1],
  output logic [5:0] reg_wb_addr [0:1],
  output logic [31:0] reg_wb_data [0:1],
  output logic [0:0] reg_wb_en [0:1],
  input  logic [0:0] reset ,
  output logic [5:0] stale_out [0:1],
  output logic [0:0] br_update__en  ,
  output BranchUpdate__target_32__mispredict_1__tag_3 br_update__msg  ,
  input logic [0:0] br_update__rdy  ,
  output logic [0:0] store_out__en [0:1] ,
  output LoadStoreEntry__op_4__addr_32__data_32__rob_idx_5__mem_q_idx_4 store_out__msg [0:1] ,
  input logic [0:0] store_out__rdy [0:1] 
);
  localparam logic [1:0] __const__width_at_br_updt  = 2'd2;
  //-------------------------------------------------------------
  // Component commit_units[0:1]
  //-------------------------------------------------------------

  logic [0:0] commit_units__clk [0:1];
  ROBEntryUop__0a11cf2a2340c105 commit_units__in_ [0:1];
  logic [5:0] commit_units__ready_out [0:1];
  logic [5:0] commit_units__reg_wb_addr [0:1];
  logic [31:0] commit_units__reg_wb_data [0:1];
  logic [0:0] commit_units__reg_wb_en [0:1];
  logic [0:0] commit_units__reset [0:1];
  logic [5:0] commit_units__stale_out [0:1];
  logic [0:0] commit_units__br_update__en [0:1];
  BranchUpdate__target_32__mispredict_1__tag_3 commit_units__br_update__msg [0:1];
  logic [0:0] commit_units__br_update__rdy [0:1];
  logic [0:0] commit_units__store_out__en [0:1];
  LoadStoreEntry__op_4__addr_32__data_32__rob_idx_5__mem_q_idx_4 commit_units__store_out__msg [0:1];
  logic [0:0] commit_units__store_out__rdy [0:1];

  SingleCommit_noparam commit_units__0
  (
    .clk( commit_units__clk[0] ),
    .in_( commit_units__in_[0] ),
    .ready_out( commit_units__ready_out[0] ),
    .reg_wb_addr( commit_units__reg_wb_addr[0] ),
    .reg_wb_data( commit_units__reg_wb_data[0] ),
    .reg_wb_en( commit_units__reg_wb_en[0] ),
    .reset( commit_units__reset[0] ),
    .stale_out( commit_units__stale_out[0] ),
    .br_update__en( commit_units__br_update__en[0] ),
    .br_update__msg( commit_units__br_update__msg[0] ),
    .br_update__rdy( commit_units__br_update__rdy[0] ),
    .store_out__en( commit_units__store_out__en[0] ),
    .store_out__msg( commit_units__store_out__msg[0] ),
    .store_out__rdy( commit_units__store_out__rdy[0] )
  );

  SingleCommit_noparam commit_units__1
  (
    .clk( commit_units__clk[1] ),
    .in_( commit_units__in_[1] ),
    .ready_out( commit_units__ready_out[1] ),
    .reg_wb_addr( commit_units__reg_wb_addr[1] ),
    .reg_wb_data( commit_units__reg_wb_data[1] ),
    .reg_wb_en( commit_units__reg_wb_en[1] ),
    .reset( commit_units__reset[1] ),
    .stale_out( commit_units__stale_out[1] ),
    .br_update__en( commit_units__br_update__en[1] ),
    .br_update__msg( commit_units__br_update__msg[1] ),
    .br_update__rdy( commit_units__br_update__rdy[1] ),
    .store_out__en( commit_units__store_out__en[1] ),
    .store_out__msg( commit_units__store_out__msg[1] ),
    .store_out__rdy( commit_units__store_out__rdy[1] )
  );

  //-------------------------------------------------------------
  // End of component commit_units[0:1]
  //-------------------------------------------------------------

  // PyMTL Update Block Source
  // At /home/cubucher/Desktop/ramp-core/src/cl/commit_unit.py:46
  // @update
  // def br_updt():
  //     # handling single branch prediction output, with multiple uops
  //     # first uop that is a branch is the one that is committed
  //     s.br_update.en @= 0
  //     s.br_update.msg @= BranchUpdate(0, 0, 0)
  //     for x in range(width):
  //         s.commit_units[x].br_update.rdy @= 0
  //         if s.commit_units[x].br_update.en & ~s.br_update.en:
  //             s.br_update.en @= 1
  //             s.br_update.msg @= s.commit_units[x].br_update.msg
  //             s.commit_units[x].br_update.rdy @= s.br_update.rdy
  
  always_comb begin : br_updt
    br_update__en = 1'd0;
    br_update__msg = { 32'd0, 1'd0, 3'd0 };
    for ( int unsigned x = 1'd0; x < 2'( __const__width_at_br_updt ); x += 1'd1 ) begin
      commit_units__br_update__rdy[1'(x)] = 1'd0;
      if ( commit_units__br_update__en[1'(x)] & ( ~br_update__en ) ) begin
        br_update__en = 1'd1;
        br_update__msg = commit_units__br_update__msg[1'(x)];
        commit_units__br_update__rdy[1'(x)] = br_update__rdy;
      end
    end
  end

  assign commit_units__clk[0] = clk;
  assign commit_units__reset[0] = reset;
  assign commit_units__clk[1] = clk;
  assign commit_units__reset[1] = reset;
  assign commit_units__in_[0] = in_.uop1_entry;
  assign commit_units__in_[1] = in_.uop2_entry;
  assign reg_wb_addr[0] = commit_units__reg_wb_addr[0];
  assign reg_wb_data[0] = commit_units__reg_wb_data[0];
  assign reg_wb_en[0] = commit_units__reg_wb_en[0];
  assign store_out__en[0] = commit_units__store_out__en[0];
  assign store_out__msg[0] = commit_units__store_out__msg[0];
  assign commit_units__store_out__rdy[0] = store_out__rdy[0];
  assign stale_out[0] = commit_units__stale_out[0];
  assign ready_out[0] = commit_units__ready_out[0];
  assign reg_wb_addr[1] = commit_units__reg_wb_addr[1];
  assign reg_wb_data[1] = commit_units__reg_wb_data[1];
  assign reg_wb_en[1] = commit_units__reg_wb_en[1];
  assign store_out__en[1] = commit_units__store_out__en[1];
  assign store_out__msg[1] = commit_units__store_out__msg[1];
  assign commit_units__store_out__rdy[1] = store_out__rdy[1];
  assign stale_out[1] = commit_units__stale_out[1];
  assign ready_out[1] = commit_units__ready_out[1];

endmodule


// PyMTL Component BranchAllocate Definition
// At /home/cubucher/Desktop/ramp-core/src/cl/branch_allocate.py

module BranchAllocate__ntags_8__window_size_2
(
  output logic [7:0] br_mask [0:1],
  input  logic [0:0] clk ,
  input  logic [0:0] reset ,
  output logic [0:0] br_tag__en [0:1] ,
  output logic [2:0] br_tag__msg [0:1] ,
  input logic [0:0] br_tag__rdy [0:1] ,
  input logic [0:0] br_update__en  ,
  input BranchUpdate__target_32__mispredict_1__tag_3 br_update__msg  ,
  output logic [0:0] br_update__rdy  
);
  localparam logic [1:0] __const__window_size_at_updt  = 2'd2;
  localparam logic [3:0] __const__ntags_at_updt  = 4'd8;
  logic [7:0] br_freelist;
  logic [7:0] br_freelist_next;
  logic [0:0] full;

  // PyMTL Update Block Source
  // At /home/cubucher/Desktop/ramp-core/src/cl/branch_allocate.py:30
  // @update
  // def updt():
  //     # deallocate executed branch
  //     s.br_freelist_next @= s.br_freelist
  //     if s.br_update.en:
  //         s.br_freelist_next[s.br_update.msg.tag] @= 0
  // 
  //     # allocate the first available bit in br_mask, if available
  //     # update freelist accordingly
  //     for i in range(window_size):
  //         s.br_tag[i].en @= 0
  //         s.br_tag[i].msg @= 0
  //         s.br_mask[i] @= s.br_freelist_next
  //         for b in range(ntags):
  //             s.full @= reduce_and(s.br_freelist_next)
  //             if (s.br_freelist_next[b] == 0) & s.br_tag[i].rdy & ~s.br_tag[i].en:
  //                 s.br_tag[i].en @= 1
  //                 s.br_tag[i].msg @= b
  //                 s.br_freelist_next[s.br_tag[i].msg] @= 1
  
  always_comb begin : updt
    br_freelist_next = br_freelist;
    if ( br_update__en ) begin
      br_freelist_next[br_update__msg.tag] = 1'd0;
    end
    for ( int unsigned i = 1'd0; i < 2'( __const__window_size_at_updt ); i += 1'd1 ) begin
      br_tag__en[1'(i)] = 1'd0;
      br_tag__msg[1'(i)] = 3'd0;
      br_mask[1'(i)] = br_freelist_next;
      for ( int unsigned b = 1'd0; b < 4'( __const__ntags_at_updt ); b += 1'd1 ) begin
        full = ( & br_freelist_next );
        if ( ( ( br_freelist_next[3'(b)] == 1'd0 ) & br_tag__rdy[1'(i)] ) & ( ~br_tag__en[1'(i)] ) ) begin
          br_tag__en[1'(i)] = 1'd1;
          br_tag__msg[1'(i)] = 3'(b);
          br_freelist_next[br_tag__msg[1'(i)]] = 1'd1;
        end
      end
    end
  end

  // PyMTL Update Block Source
  // At /home/cubucher/Desktop/ramp-core/src/cl/branch_allocate.py:23
  // @update_ff
  // def updt_ff():
  //     if s.reset:
  //         s.br_freelist <<= 0
  //     else:
  //         s.br_freelist <<= s.br_freelist_next
  
  always_ff @(posedge clk) begin : updt_ff
    if ( reset ) begin
      br_freelist <= 8'd0;
    end
    else
      br_freelist <= br_freelist_next;
  end

  assign br_update__rdy = 1'd1;

endmodule


// PyMTL Component SingleInstDecode Definition
// At /home/cubucher/Desktop/ramp-core/src/cl/decode.py

module SingleInstDecode_noparam
(
  input  logic [7:0] br_mask ,
  input  logic [2:0] br_tag ,
  input  logic [0:0] branch_taken ,
  input  logic [0:0] clk ,
  input  logic [31:0] inst ,
  input  logic [3:0] mem_q_idx ,
  input  logic [31:0] pc ,
  input  PhysicalRegs__prd_6__prs1_6__prs2_6__stale_6 pregs ,
  input  PRegBusy__prs1_1__prs2_1 pregs_busy ,
  input  logic [0:0] reset ,
  output MicroOp__38e2b09b91e4b306 uop ,
  input  logic [0:0] valid 
);
  localparam logic [4:0] __const__INSTR_NOP  = 5'd19;
  localparam logic [5:0] __const__RTYPE_OPCODE  = 6'd51;
  localparam logic [0:0] __const__R_TYPE  = 1'd1;
  localparam logic [0:0] __const__INT_ISSUE_UNIT  = 1'd1;
  localparam logic [0:0] __const__ALU_FUNCT_UNIT  = 1'd1;
  localparam logic [4:0] __const__ITYPE_OPCODE1  = 5'd19;
  localparam logic [1:0] __const__I_TYPE  = 2'd2;
  localparam logic [1:0] __const__ITYPE_OPCODE2  = 2'd3;
  localparam logic [1:0] __const__MEM_ISSUE_UNIT  = 2'd2;
  localparam logic [1:0] __const__MEM_FUNCT_UNIT  = 2'd2;
  localparam logic [6:0] __const__ITYPE_OPCODE3  = 7'd103;
  localparam logic [1:0] __const__BRANCH_ISSUE_UNIT  = 2'd3;
  localparam logic [1:0] __const__BRANCH_FUNCT_UNIT  = 2'd3;
  localparam logic [5:0] __const__STYPE_OPCODE  = 6'd35;
  localparam logic [1:0] __const__S_TYPE  = 2'd3;
  localparam logic [6:0] __const__BTYPE_OPCODE  = 7'd99;
  localparam logic [2:0] __const__B_TYPE  = 3'd4;
  localparam logic [5:0] __const__UTYPE_OPCODE1  = 6'd55;
  localparam logic [4:0] __const__UTYPE_OPCODE2  = 5'd23;
  localparam logic [2:0] __const__U_TYPE  = 3'd5;
  localparam logic [6:0] __const__JTYPE_OPCODE  = 7'd111;
  localparam logic [2:0] __const__J_TYPE  = 3'd6;
  localparam logic [6:0] __const__CSRTYPE_OPCODE  = 7'd115;
  localparam logic [2:0] __const__CSR_TYPE  = 3'd7;
  localparam logic [0:0] __const__NA_ISSUE_UNIT  = 1'd0;
  localparam logic [0:0] __const__NA_FUNCT_UNIT  = 1'd0;
  localparam logic [0:0] __const__NA_TYPE  = 1'd0;
  logic [6:0] __tmpvar__decode_comb_opcode;
  logic [11:0] __tmpvar__decode_comb_tmp1;
  logic [12:0] __tmpvar__decode_comb_tmp2;
  logic [20:0] __tmpvar__decode_comb_tmp3;

  // PyMTL Update Block Source
  // At /home/cubucher/Desktop/ramp-core/src/cl/decode.py:217
  // @update
  // def decode_comb():
  //     # defaults
  //     s.uop.inst @= s.inst
  //     s.uop.pc @= (s.pc + 4) if s.idx else (s.pc)
  //     s.uop.branch_taken @= s.branch_taken
  //     s.uop.br_tag @= s.br_tag
  //     s.uop.br_mask @= s.br_mask
  //     s.uop.valid @= (s.inst != INSTR_NOP) & ~(s.inst == 0)
  // 
  //     # TODO: Currently, register renaming is dependent on not-used
  //     # logical registers being zeroed out. If we want to get rid of the
  //     # zeroing out logic, register renaming must be changed.
  //     s.uop.lrd @= s.inst[RD_SLICE]
  //     s.uop.lrs1 @= s.inst[RS1_SLICE]
  //     s.uop.lrs2 @= s.inst[RS2_SLICE]
  // 
  //     s.uop.prd @= s.pregs.prd
  //     s.uop.prs1 @= s.pregs.prs1
  //     s.uop.prs2 @= s.pregs.prs2
  //     s.uop.stale @= s.pregs.stale
  // 
  //     s.uop.imm @= 0
  //     s.uop.funct_op @= 0
  //     s.uop.rob_idx @= 0
  //     s.uop.mem_q_idx @= 0
  // 
  //     # For determining type
  //     opcode = s.inst[OPCODE_SLICE]
  //     # arithmetic and logical instructions
  //     if opcode == RTYPE_OPCODE:
  //         s.uop.optype @= R_TYPE
  //         s.uop.issue_unit @= INT_ISSUE_UNIT
  //         s.uop.funct_unit @= ALU_FUNCT_UNIT
  //         s.uop.funct_op @= concat(s.inst[30], s.inst[FUNCT3_SLICE])
  // 
  //     # immediate arithmetic and logical
  //     elif opcode == ITYPE_OPCODE1:
  //         s.uop.optype @= I_TYPE
  //         s.uop.issue_unit @= INT_ISSUE_UNIT
  //         s.uop.funct_unit @= ALU_FUNCT_UNIT
  //         s.uop.funct_op @= zext(s.inst[FUNCT3_SLICE], 4)
  //         # srli, srai
  //         if s.inst[FUNCT3_SLICE] == 0b101:
  //             s.uop.funct_op @= concat(s.inst[30], s.inst[FUNCT3_SLICE])
  //         s.uop.imm @= sext(s.inst[20:32], 32)
  // 
  //         s.uop.lrs2 @= 0
  //     # loads
  //     elif opcode == ITYPE_OPCODE2:
  //         s.uop.optype @= I_TYPE
  //         s.uop.issue_unit @= MEM_ISSUE_UNIT
  //         s.uop.funct_unit @= MEM_FUNCT_UNIT
  //         s.uop.funct_op @= concat(opcode[5], s.inst[FUNCT3_SLICE])
  //         s.uop.imm @= sext(s.inst[20:32], 32)
  // 
  //         s.uop.lrs2 @= 0
  //     # jalr
  //     elif opcode == ITYPE_OPCODE3:
  //         s.uop.optype @= I_TYPE
  //         s.uop.issue_unit @= BRANCH_ISSUE_UNIT
  //         s.uop.funct_unit @= BRANCH_FUNCT_UNIT
  //         s.uop.funct_op @= 0
  //         s.uop.imm @= sext(s.inst[20:32], 32)
  // 
  //         s.uop.lrs2 @= 0
  //     # stores
  //     elif opcode == STYPE_OPCODE:
  //         s.uop.optype @= S_TYPE
  //         s.uop.issue_unit @= MEM_ISSUE_UNIT
  //         s.uop.funct_unit @= MEM_FUNCT_UNIT
  //         s.uop.funct_op @= concat(opcode[5], s.inst[FUNCT3_SLICE])
  // 
  //         # cannot have concat nested in sext
  //         tmp1 = concat(s.inst[25:32], s.inst[7:12])
  //         s.uop.imm @= sext(tmp1, 32)
  // 
  //         s.uop.lrd @= 0
  //     # branches
  //     elif opcode == BTYPE_OPCODE:
  //         s.uop.optype @= B_TYPE
  //         s.uop.issue_unit @= BRANCH_ISSUE_UNIT
  //         s.uop.funct_unit @= BRANCH_FUNCT_UNIT
  //         s.uop.funct_op @= zext(s.inst[FUNCT3_SLICE], 4)
  // 
  //         tmp2 = concat(
  //                 s.inst[31], s.inst[7], s.inst[25:31], s.inst[8:12], Bits1(0)
  //             )
  //         s.uop.imm @= sext(tmp2, 32)
  //         s.uop.lrd @= 0
  //     # lui (1), auipc (2)
  //     elif (opcode == UTYPE_OPCODE1) | (opcode == UTYPE_OPCODE2):
  //         s.uop.optype @= U_TYPE
  //         s.uop.issue_unit @= INT_ISSUE_UNIT
  //         s.uop.funct_unit @= ALU_FUNCT_UNIT
  //         s.uop.funct_op @= Bits4(0b1001)  # alu lui-copy TODO: auipc
  //         s.uop.imm @= concat(s.inst[12:32], Bits12(0))
  // 
  //         s.uop.lrs1 @= 0
  //         s.uop.lrs2 @= 0
  //     # jal
  //     elif opcode == JTYPE_OPCODE:
  //         s.uop.optype @= J_TYPE
  //         s.uop.issue_unit @= BRANCH_ISSUE_UNIT
  //         s.uop.funct_unit @= BRANCH_FUNCT_UNIT
  // 
  //         tmp3 = concat(
  //                 s.inst[31],
  //                 s.inst[12:20],
  //                 s.inst[20],
  //                 s.inst[25:31],
  //                 s.inst[21:25],
  //                 Bits1(0),
  //             )
  //         s.uop.imm @= sext(tmp3, 32)
  // 
  //         s.uop.lrs1 @= 0
  //         s.uop.lrs2 @= 0
  //     # system instructions
  //     elif opcode == CSRTYPE_OPCODE:
  //         s.uop.optype @= CSR_TYPE
  //         s.uop.issue_unit @= NA_ISSUE_UNIT
  //         s.uop.funct_unit @= NA_FUNCT_UNIT
  //         s.uop.funct_op @= 0
  //         s.uop.imm @= 0
  // 
  //         s.uop.lrs2 @= 0
  //     # otherwise noop
  //     else:
  //         s.uop.optype @= NA_TYPE
  //         s.uop.issue_unit @= NA_ISSUE_UNIT
  //         s.uop.funct_unit @= NA_FUNCT_UNIT
  //         s.uop.funct_op @= 0
  //         s.uop.imm @= 0
  //         s.uop.lrs2 @= 0
  //         s.uop.lrs1 @= 0
  //         s.uop.lrd @= 0
  //         s.uop.stale @= 0
  
  always_comb begin : decode_comb
    uop.inst = inst;
    uop.pc = 1'd0 ? pc + 32'd4 : pc;
    uop.branch_taken = branch_taken;
    uop.br_tag = br_tag;
    uop.br_mask = br_mask;
    uop.valid = ( inst != 32'( __const__INSTR_NOP ) ) & ( ~( inst == 32'd0 ) );
    uop.lrd = inst[5'd11:5'd7];
    uop.lrs1 = inst[5'd19:5'd15];
    uop.lrs2 = inst[5'd24:5'd20];
    uop.prd = pregs.prd;
    uop.prs1 = pregs.prs1;
    uop.prs2 = pregs.prs2;
    uop.stale = pregs.stale;
    uop.imm = 32'd0;
    uop.funct_op = 4'd0;
    uop.rob_idx = 5'd0;
    uop.mem_q_idx = 4'd0;
    __tmpvar__decode_comb_opcode = inst[5'd6:5'd0];
    if ( __tmpvar__decode_comb_opcode == 7'( __const__RTYPE_OPCODE ) ) begin
      uop.optype = 3'( __const__R_TYPE );
      uop.issue_unit = 2'( __const__INT_ISSUE_UNIT );
      uop.funct_unit = 2'( __const__ALU_FUNCT_UNIT );
      uop.funct_op = { inst[5'd30], inst[5'd14:5'd12] };
    end
    else if ( __tmpvar__decode_comb_opcode == 7'( __const__ITYPE_OPCODE1 ) ) begin
      uop.optype = 3'( __const__I_TYPE );
      uop.issue_unit = 2'( __const__INT_ISSUE_UNIT );
      uop.funct_unit = 2'( __const__ALU_FUNCT_UNIT );
      uop.funct_op = { { 1 { 1'b0 } }, inst[5'd14:5'd12] };
      if ( inst[5'd14:5'd12] == 3'd5 ) begin
        uop.funct_op = { inst[5'd30], inst[5'd14:5'd12] };
      end
      uop.imm = { { 20 { inst[5'd31] } }, inst[5'd31:5'd20] };
      uop.lrs2 = 5'd0;
    end
    else if ( __tmpvar__decode_comb_opcode == 7'( __const__ITYPE_OPCODE2 ) ) begin
      uop.optype = 3'( __const__I_TYPE );
      uop.issue_unit = 2'( __const__MEM_ISSUE_UNIT );
      uop.funct_unit = 2'( __const__MEM_FUNCT_UNIT );
      uop.funct_op = { __tmpvar__decode_comb_opcode[3'd5], inst[5'd14:5'd12] };
      uop.imm = { { 20 { inst[5'd31] } }, inst[5'd31:5'd20] };
      uop.lrs2 = 5'd0;
    end
    else if ( __tmpvar__decode_comb_opcode == 7'( __const__ITYPE_OPCODE3 ) ) begin
      uop.optype = 3'( __const__I_TYPE );
      uop.issue_unit = 2'( __const__BRANCH_ISSUE_UNIT );
      uop.funct_unit = 2'( __const__BRANCH_FUNCT_UNIT );
      uop.funct_op = 4'd0;
      uop.imm = { { 20 { inst[5'd31] } }, inst[5'd31:5'd20] };
      uop.lrs2 = 5'd0;
    end
    else if ( __tmpvar__decode_comb_opcode == 7'( __const__STYPE_OPCODE ) ) begin
      uop.optype = 3'( __const__S_TYPE );
      uop.issue_unit = 2'( __const__MEM_ISSUE_UNIT );
      uop.funct_unit = 2'( __const__MEM_FUNCT_UNIT );
      uop.funct_op = { __tmpvar__decode_comb_opcode[3'd5], inst[5'd14:5'd12] };
      __tmpvar__decode_comb_tmp1 = { inst[5'd31:5'd25], inst[5'd11:5'd7] };
      uop.imm = { { 20 { __tmpvar__decode_comb_tmp1[11] } }, __tmpvar__decode_comb_tmp1 };
      uop.lrd = 5'd0;
    end
    else if ( __tmpvar__decode_comb_opcode == 7'( __const__BTYPE_OPCODE ) ) begin
      uop.optype = 3'( __const__B_TYPE );
      uop.issue_unit = 2'( __const__BRANCH_ISSUE_UNIT );
      uop.funct_unit = 2'( __const__BRANCH_FUNCT_UNIT );
      uop.funct_op = { { 1 { 1'b0 } }, inst[5'd14:5'd12] };
      __tmpvar__decode_comb_tmp2 = { inst[5'd31], inst[5'd7], inst[5'd30:5'd25], inst[5'd11:5'd8], 1'd0 };
      uop.imm = { { 19 { __tmpvar__decode_comb_tmp2[12] } }, __tmpvar__decode_comb_tmp2 };
      uop.lrd = 5'd0;
    end
    else if ( ( __tmpvar__decode_comb_opcode == 7'( __const__UTYPE_OPCODE1 ) ) | ( __tmpvar__decode_comb_opcode == 7'( __const__UTYPE_OPCODE2 ) ) ) begin
      uop.optype = 3'( __const__U_TYPE );
      uop.issue_unit = 2'( __const__INT_ISSUE_UNIT );
      uop.funct_unit = 2'( __const__ALU_FUNCT_UNIT );
      uop.funct_op = 4'd9;
      uop.imm = { inst[5'd31:5'd12], 12'd0 };
      uop.lrs1 = 5'd0;
      uop.lrs2 = 5'd0;
    end
    else if ( __tmpvar__decode_comb_opcode == 7'( __const__JTYPE_OPCODE ) ) begin
      uop.optype = 3'( __const__J_TYPE );
      uop.issue_unit = 2'( __const__BRANCH_ISSUE_UNIT );
      uop.funct_unit = 2'( __const__BRANCH_FUNCT_UNIT );
      __tmpvar__decode_comb_tmp3 = { inst[5'd31], inst[5'd19:5'd12], inst[5'd20], inst[5'd30:5'd25], inst[5'd24:5'd21], 1'd0 };
      uop.imm = { { 11 { __tmpvar__decode_comb_tmp3[20] } }, __tmpvar__decode_comb_tmp3 };
      uop.lrs1 = 5'd0;
      uop.lrs2 = 5'd0;
    end
    else if ( __tmpvar__decode_comb_opcode == 7'( __const__CSRTYPE_OPCODE ) ) begin
      uop.optype = 3'( __const__CSR_TYPE );
      uop.issue_unit = 2'( __const__NA_ISSUE_UNIT );
      uop.funct_unit = 2'( __const__NA_FUNCT_UNIT );
      uop.funct_op = 4'd0;
      uop.imm = 32'd0;
      uop.lrs2 = 5'd0;
    end
    else begin
      uop.optype = 3'( __const__NA_TYPE );
      uop.issue_unit = 2'( __const__NA_ISSUE_UNIT );
      uop.funct_unit = 2'( __const__NA_FUNCT_UNIT );
      uop.funct_op = 4'd0;
      uop.imm = 32'd0;
      uop.lrs2 = 5'd0;
      uop.lrs1 = 5'd0;
      uop.lrd = 5'd0;
      uop.stale = 6'd0;
    end
  end

endmodule


// PyMTL Component RegisterRename Definition
// At /home/cubucher/Desktop/ramp-core/src/cl/register_rename.py

module RegisterRename_noparam
(
  output logic [63:0] busy_table ,
  input  logic [0:0] clk ,
  output logic [63:0] free_list ,
  input  LogicalRegs__lrd_5__lrs1_5__lrs2_5 inst1_lregs ,
  output PhysicalRegs__prd_6__prs1_6__prs2_6__stale_6 inst1_pregs ,
  output PRegBusy__prs1_1__prs2_1 inst1_pregs_busy ,
  input  LogicalRegs__lrd_5__lrs1_5__lrs2_5 inst2_lregs ,
  output PhysicalRegs__prd_6__prs1_6__prs2_6__stale_6 inst2_pregs ,
  output PRegBusy__prs1_1__prs2_1 inst2_pregs_busy ,
  input  logic [5:0] ready_in [0:1],
  input  logic [0:0] reset ,
  input  logic [5:0] stale_in [0:1],
  input logic [0:0] br_update__en  ,
  input BranchUpdate__target_32__mispredict_1__tag_3 br_update__msg  ,
  output logic [0:0] br_update__rdy  
);
  localparam logic [6:0] __const__NUM_PHYS_REGS  = 7'd64;
  localparam logic [5:0] __const__NUM_ISA_REGS  = 6'd32;
  logic [63:0] busy_table_next;
  logic [63:0] free_list_next;
  logic [5:0] map_table [0:31];
  logic [5:0] map_table_wr1;
  logic [5:0] map_table_wr2;
  logic [5:0] pdst1;
  logic [5:0] pdst2;

  // PyMTL Update Block Source
  // At /home/cubucher/Desktop/ramp-core/src/cl/register_rename.py:71
  // @update
  // def rename_comb():
  //     # Combinatorially getting physical source registers from map table
  //     # and getting physical dest registers from free list
  //     # TODO: add assert statements for when physical registers are full
  // 
  //     # DEFAULTS
  //     s.free_list_next @= s.free_list
  //     s.busy_table_next @= s.busy_table
  //     s.map_table_wr1 @= s.map_table[s.inst1_lregs.lrd]
  //     s.map_table_wr2 @= s.map_table[s.inst2_lregs.lrd]
  // 
  //     # *combinatorially* getting dest registers, but not updating tables
  //     # pdst1, pdst2 = cascading_priority_encoder(2, s.free_list_next)
  //     s.pdst1 @= 0
  //     s.pdst2 @= 0
  //     for i in range(NUM_PHYS_REGS):
  //         if s.free_list[i]:
  //             if s.pdst1 == 0:
  //                 s.pdst1 @= i
  //             elif s.pdst2 == 0:
  //                 s.pdst2 @= i
  //     # making sure that there are free registers
  //     # assert s.pdst1 != 0 or s.pdst2 != 0
  // 
  //     if s.inst1_lregs.lrd:
  //         s.inst1_pregs.prd @= s.pdst1
  //         s.inst2_pregs.prd @= s.pdst2 if s.inst2_lregs.lrd else 0
  //     elif s.inst2_lregs.lrd:
  //         s.inst1_pregs.prd @= 0
  //         s.inst2_pregs.prd @= s.pdst1
  //     else:
  //         s.inst1_pregs.prd @= 0
  //         s.inst2_pregs.prd @= 0
  // 
  //     s.inst1_pregs.prs1 @= s.map_table[s.inst1_lregs.lrs1]
  //     s.inst1_pregs.prs2 @= s.map_table[s.inst1_lregs.lrs2]
  //     s.inst1_pregs.stale @= s.map_table[s.inst1_lregs.lrd]
  //     s.inst1_pregs_busy.prs1 @= s.busy_table[s.inst1_pregs.prs1]
  //     s.inst1_pregs_busy.prs2 @= s.busy_table[s.inst1_pregs.prs2]
  // 
  //     # bypass network.
  //     # forward dependent sources from inst2 to inst1. handle stale
  //     if (s.inst2_lregs.lrd == s.inst1_lregs.lrd) & (s.inst1_lregs.lrd != 0):
  //         # inst2 dependent on inst1.
  //         s.inst2_pregs.stale @= s.pdst1
  //     else:
  //         s.inst2_pregs.stale @= s.map_table[s.inst2_lregs.lrd]
  // 
  //     if (s.inst2_lregs.lrs1 == s.inst1_lregs.lrd) & (s.inst1_lregs.lrd != 0):
  //         # inst2 dependent on inst1. inst2 prs1 = pdst1 and is busy
  //         s.inst2_pregs.prs1 @= s.pdst1
  //         s.inst2_pregs_busy.prs1 @= 1
  //     else:
  //         s.inst2_pregs.prs1 @= s.map_table[s.inst2_lregs.lrs1]
  //         s.inst2_pregs_busy.prs1 @= s.busy_table[s.inst2_pregs.prs1]
  // 
  //     if (s.inst2_lregs.lrs2 == s.inst1_lregs.lrd) & (s.inst1_lregs.lrd != 0):
  //         # inst2 dependent on inst1. inst2 prs2 = pdst1 and is busy
  //         s.inst2_pregs.prs2 @= s.pdst1
  //         s.inst2_pregs_busy.prs2 @= 1
  //     else:
  //         s.inst2_pregs.prs2 @= s.map_table[s.inst2_lregs.lrs2]
  //         s.inst2_pregs_busy.prs2 @= s.busy_table[s.inst2_pregs.prs2]
  // 
  //     # nextstate for updating free_list, map_table, busy_table
  //     if s.reset:
  //         s.free_list_next @= s.free_list_reset
  //         s.busy_table_next @= 0
  //     else:
  //         # updating tables with newely allocated registers
  //         if (s.inst1_lregs.lrd != 0) ^ (s.inst2_lregs.lrd != 0):
  //             s.free_list_next @= s.free_list_next & ~(
  //                 s.ONE << zext(s.pdst1, NUM_PHYS_REGS)
  //             )
  //             s.busy_table_next @= s.busy_table | (
  //                 s.ONE << zext(s.pdst1, NUM_PHYS_REGS)
  //             )
  //             if s.inst1_lregs.lrd:
  //                 s.map_table_wr1 @= s.pdst1
  //                 s.map_table_wr2 @= 0
  //             elif s.inst2_lregs.lrd:
  //                 s.map_table_wr1 @= 0
  //                 s.map_table_wr2 @= s.pdst1
  // 
  //         elif (s.inst1_lregs.lrd != 0) & (s.inst2_lregs.lrd != 0):
  //             # ensuring there are registers to allocate
  //             s.free_list_next @= (
  //                 s.free_list_next
  //                 & ~(s.ONE << zext(s.pdst1, NUM_PHYS_REGS))
  //                 & ~(s.ONE << zext(s.pdst2, NUM_PHYS_REGS))
  //             )
  //             s.busy_table_next @= (
  //                 s.busy_table
  //                 | s.ONE << zext(s.pdst1, NUM_PHYS_REGS)
  //                 | s.ONE << zext(s.pdst2, NUM_PHYS_REGS)
  //             )
  //             s.map_table_wr1 @= s.pdst1
  //             s.map_table_wr2 @= s.pdst2
  // 
  //     # updating free_list, busy_table
  //     for i in range(2):
  //         if s.stale_in[i]:
  //             s.free_list_next @= s.free_list_next | (
  //                 s.ONE << zext(s.stale_in[i], NUM_PHYS_REGS)
  //             )
  //         if s.ready_in[i]:
  //             s.busy_table_next @= s.busy_table_next & ~(
  //                 s.ONE << zext(s.ready_in[i], NUM_PHYS_REGS)
  //             )
  
  always_comb begin : rename_comb
    free_list_next = free_list;
    busy_table_next = busy_table;
    map_table_wr1 = map_table[inst1_lregs.lrd];
    map_table_wr2 = map_table[inst2_lregs.lrd];
    pdst1 = 6'd0;
    pdst2 = 6'd0;
    for ( int unsigned i = 1'd0; i < 7'( __const__NUM_PHYS_REGS ); i += 1'd1 )
      if ( free_list[6'(i)] ) begin
        if ( pdst1 == 6'd0 ) begin
          pdst1 = 6'(i);
        end
        else if ( pdst2 == 6'd0 ) begin
          pdst2 = 6'(i);
        end
      end
    if ( inst1_lregs.lrd ) begin
      inst1_pregs.prd = pdst1;
      inst2_pregs.prd = inst2_lregs.lrd ? pdst2 : 6'd0;
    end
    else if ( inst2_lregs.lrd ) begin
      inst1_pregs.prd = 6'd0;
      inst2_pregs.prd = pdst1;
    end
    else begin
      inst1_pregs.prd = 6'd0;
      inst2_pregs.prd = 6'd0;
    end
    inst1_pregs.prs1 = map_table[inst1_lregs.lrs1];
    inst1_pregs.prs2 = map_table[inst1_lregs.lrs2];
    inst1_pregs.stale = map_table[inst1_lregs.lrd];
    inst1_pregs_busy.prs1 = busy_table[inst1_pregs.prs1];
    inst1_pregs_busy.prs2 = busy_table[inst1_pregs.prs2];
    if ( ( inst2_lregs.lrd == inst1_lregs.lrd ) & ( inst1_lregs.lrd != 5'd0 ) ) begin
      inst2_pregs.stale = pdst1;
    end
    else
      inst2_pregs.stale = map_table[inst2_lregs.lrd];
    if ( ( inst2_lregs.lrs1 == inst1_lregs.lrd ) & ( inst1_lregs.lrd != 5'd0 ) ) begin
      inst2_pregs.prs1 = pdst1;
      inst2_pregs_busy.prs1 = 1'd1;
    end
    else begin
      inst2_pregs.prs1 = map_table[inst2_lregs.lrs1];
      inst2_pregs_busy.prs1 = busy_table[inst2_pregs.prs1];
    end
    if ( ( inst2_lregs.lrs2 == inst1_lregs.lrd ) & ( inst1_lregs.lrd != 5'd0 ) ) begin
      inst2_pregs.prs2 = pdst1;
      inst2_pregs_busy.prs2 = 1'd1;
    end
    else begin
      inst2_pregs.prs2 = map_table[inst2_lregs.lrs2];
      inst2_pregs_busy.prs2 = busy_table[inst2_pregs.prs2];
    end
    if ( reset ) begin
      free_list_next = 64'd18446744073709551614;
      busy_table_next = 64'd0;
    end
    else if ( ( inst1_lregs.lrd != 5'd0 ) ^ ( inst2_lregs.lrd != 5'd0 ) ) begin
      free_list_next = free_list_next & ( ~( 64'd1 << { { 58 { 1'b0 } }, pdst1 } ) );
      busy_table_next = busy_table | ( 64'd1 << { { 58 { 1'b0 } }, pdst1 } );
      if ( inst1_lregs.lrd ) begin
        map_table_wr1 = pdst1;
        map_table_wr2 = 6'd0;
      end
      else if ( inst2_lregs.lrd ) begin
        map_table_wr1 = 6'd0;
        map_table_wr2 = pdst1;
      end
    end
    else if ( ( inst1_lregs.lrd != 5'd0 ) & ( inst2_lregs.lrd != 5'd0 ) ) begin
      free_list_next = ( free_list_next & ( ~( 64'd1 << { { 58 { 1'b0 } }, pdst1 } ) ) ) & ( ~( 64'd1 << { { 58 { 1'b0 } }, pdst2 } ) );
      busy_table_next = ( busy_table | ( 64'd1 << { { 58 { 1'b0 } }, pdst1 } ) ) | ( 64'd1 << { { 58 { 1'b0 } }, pdst2 } );
      map_table_wr1 = pdst1;
      map_table_wr2 = pdst2;
    end
    for ( int unsigned i = 1'd0; i < 2'd2; i += 1'd1 ) begin
      if ( stale_in[1'(i)] ) begin
        free_list_next = free_list_next | ( 64'd1 << { { 58 { 1'b0 } }, stale_in[1'(i)] } );
      end
      if ( ready_in[1'(i)] ) begin
        busy_table_next = busy_table_next & ( ~( 64'd1 << { { 58 { 1'b0 } }, ready_in[1'(i)] } ) );
      end
    end
  end

  // PyMTL Update Block Source
  // At /home/cubucher/Desktop/ramp-core/src/cl/register_rename.py:182
  // @update_ff
  // def rename_ff():
  //     s.free_list <<= s.free_list_next
  //     s.busy_table <<= s.busy_table_next
  //     s.map_table[s.inst1_lregs.lrd] <<= s.map_table_wr1
  //     s.map_table[s.inst2_lregs.lrd] <<= s.map_table_wr2
  //     # TODO: CL debugging
  //     # assert s.map_table[0] == 0
  //     # assert ~((s.inst1_lregs.lrd == 0) ^ (s.map_table_wr1 == 0))
  //     # assert ~((s.inst2_lregs.lrd == 0) ^ (s.map_table_wr2 == 0))
  // 
  //     # # resetting
  //     if s.reset == 1:
  //         for x in range(NUM_ISA_REGS):
  //             s.map_table[x] <<= 0
  // 
  //     # checking zero always points to zero
  
  always_ff @(posedge clk) begin : rename_ff
    free_list <= free_list_next;
    busy_table <= busy_table_next;
    map_table[inst1_lregs.lrd] <= map_table_wr1;
    map_table[inst2_lregs.lrd] <= map_table_wr2;
    if ( reset == 1'd1 ) begin
      for ( int unsigned x = 1'd0; x < 6'( __const__NUM_ISA_REGS ); x += 1'd1 )
        map_table[5'(x)] <= 6'd0;
    end
  end

  assign br_update__rdy = 1'd1;

endmodule


// PyMTL Component Decode Definition
// At /home/cubucher/Desktop/ramp-core/src/cl/decode.py

module Decode_noparam
(
  output logic [63:0] busy_table ,
  input  logic [0:0] clk ,
  output DualMicroOp__93e30b890d7542af dual_uop ,
  input  FetchPacket__pc_32__branch_taken_1__inst1_32__inst2_32__valid_1 fetch_packet ,
  output logic [1:0] mem_q_allocate ,
  input  logic [5:0] ready_in [0:1],
  input  logic [0:0] reset ,
  input  logic [5:0] stale_in [0:1],
  input logic [0:0] br_update__en  ,
  input BranchUpdate__target_32__mispredict_1__tag_3 br_update__msg  ,
  output logic [0:0] br_update__rdy  
);
  localparam logic [1:0] __const__MEM_ISSUE_UNIT  = 2'd2;
  localparam logic [2:0] __const__B_TYPE  = 3'd4;
  logic [31:0] inst1;
  logic [31:0] inst2;
  //-------------------------------------------------------------
  // Component branch_allocate
  //-------------------------------------------------------------

  logic [7:0] branch_allocate__br_mask [0:1];
  logic [0:0] branch_allocate__clk;
  logic [0:0] branch_allocate__reset;
  logic [0:0] branch_allocate__br_tag__en [0:1];
  logic [2:0] branch_allocate__br_tag__msg [0:1];
  logic [0:0] branch_allocate__br_tag__rdy [0:1];
  logic [0:0] branch_allocate__br_update__en;
  BranchUpdate__target_32__mispredict_1__tag_3 branch_allocate__br_update__msg;
  logic [0:0] branch_allocate__br_update__rdy;

  BranchAllocate__ntags_8__window_size_2 branch_allocate
  (
    .br_mask( branch_allocate__br_mask ),
    .clk( branch_allocate__clk ),
    .reset( branch_allocate__reset ),
    .br_tag__en( branch_allocate__br_tag__en ),
    .br_tag__msg( branch_allocate__br_tag__msg ),
    .br_tag__rdy( branch_allocate__br_tag__rdy ),
    .br_update__en( branch_allocate__br_update__en ),
    .br_update__msg( branch_allocate__br_update__msg ),
    .br_update__rdy( branch_allocate__br_update__rdy )
  );

  //-------------------------------------------------------------
  // End of component branch_allocate
  //-------------------------------------------------------------

  //-------------------------------------------------------------
  // Component d1
  //-------------------------------------------------------------

  logic [7:0] d1__br_mask;
  logic [2:0] d1__br_tag;
  logic [0:0] d1__branch_taken;
  logic [0:0] d1__clk;
  logic [31:0] d1__inst;
  logic [3:0] d1__mem_q_idx;
  logic [31:0] d1__pc;
  PhysicalRegs__prd_6__prs1_6__prs2_6__stale_6 d1__pregs;
  PRegBusy__prs1_1__prs2_1 d1__pregs_busy;
  logic [0:0] d1__reset;
  MicroOp__38e2b09b91e4b306 d1__uop;
  logic [0:0] d1__valid;

  SingleInstDecode_noparam d1
  (
    .br_mask( d1__br_mask ),
    .br_tag( d1__br_tag ),
    .branch_taken( d1__branch_taken ),
    .clk( d1__clk ),
    .inst( d1__inst ),
    .mem_q_idx( d1__mem_q_idx ),
    .pc( d1__pc ),
    .pregs( d1__pregs ),
    .pregs_busy( d1__pregs_busy ),
    .reset( d1__reset ),
    .uop( d1__uop ),
    .valid( d1__valid )
  );

  //-------------------------------------------------------------
  // End of component d1
  //-------------------------------------------------------------

  //-------------------------------------------------------------
  // Component d2
  //-------------------------------------------------------------

  logic [7:0] d2__br_mask;
  logic [2:0] d2__br_tag;
  logic [0:0] d2__branch_taken;
  logic [0:0] d2__clk;
  logic [31:0] d2__inst;
  logic [3:0] d2__mem_q_idx;
  logic [31:0] d2__pc;
  PhysicalRegs__prd_6__prs1_6__prs2_6__stale_6 d2__pregs;
  PRegBusy__prs1_1__prs2_1 d2__pregs_busy;
  logic [0:0] d2__reset;
  MicroOp__38e2b09b91e4b306 d2__uop;
  logic [0:0] d2__valid;

  SingleInstDecode_noparam d2
  (
    .br_mask( d2__br_mask ),
    .br_tag( d2__br_tag ),
    .branch_taken( d2__branch_taken ),
    .clk( d2__clk ),
    .inst( d2__inst ),
    .mem_q_idx( d2__mem_q_idx ),
    .pc( d2__pc ),
    .pregs( d2__pregs ),
    .pregs_busy( d2__pregs_busy ),
    .reset( d2__reset ),
    .uop( d2__uop ),
    .valid( d2__valid )
  );

  //-------------------------------------------------------------
  // End of component d2
  //-------------------------------------------------------------

  //-------------------------------------------------------------
  // Component register_rename
  //-------------------------------------------------------------

  logic [63:0] register_rename__busy_table;
  logic [0:0] register_rename__clk;
  logic [63:0] register_rename__free_list;
  LogicalRegs__lrd_5__lrs1_5__lrs2_5 register_rename__inst1_lregs;
  PhysicalRegs__prd_6__prs1_6__prs2_6__stale_6 register_rename__inst1_pregs;
  PRegBusy__prs1_1__prs2_1 register_rename__inst1_pregs_busy;
  LogicalRegs__lrd_5__lrs1_5__lrs2_5 register_rename__inst2_lregs;
  PhysicalRegs__prd_6__prs1_6__prs2_6__stale_6 register_rename__inst2_pregs;
  PRegBusy__prs1_1__prs2_1 register_rename__inst2_pregs_busy;
  logic [5:0] register_rename__ready_in [0:1];
  logic [0:0] register_rename__reset;
  logic [5:0] register_rename__stale_in [0:1];
  logic [0:0] register_rename__br_update__en;
  BranchUpdate__target_32__mispredict_1__tag_3 register_rename__br_update__msg;
  logic [0:0] register_rename__br_update__rdy;

  RegisterRename_noparam register_rename
  (
    .busy_table( register_rename__busy_table ),
    .clk( register_rename__clk ),
    .free_list( register_rename__free_list ),
    .inst1_lregs( register_rename__inst1_lregs ),
    .inst1_pregs( register_rename__inst1_pregs ),
    .inst1_pregs_busy( register_rename__inst1_pregs_busy ),
    .inst2_lregs( register_rename__inst2_lregs ),
    .inst2_pregs( register_rename__inst2_pregs ),
    .inst2_pregs_busy( register_rename__inst2_pregs_busy ),
    .ready_in( register_rename__ready_in ),
    .reset( register_rename__reset ),
    .stale_in( register_rename__stale_in ),
    .br_update__en( register_rename__br_update__en ),
    .br_update__msg( register_rename__br_update__msg ),
    .br_update__rdy( register_rename__br_update__rdy )
  );

  //-------------------------------------------------------------
  // End of component register_rename
  //-------------------------------------------------------------

  // PyMTL Update Block Source
  // At /home/cubucher/Desktop/ramp-core/src/cl/decode.py:177
  // @update
  // def allocate_():
  //     # allocate memory queue space
  //     s.mem_q_allocate @= zext(
  //         s.d1.uop.issue_unit == MEM_ISSUE_UNIT, WINDOW_SIZE
  //     ) + zext(s.d2.uop.issue_unit == MEM_ISSUE_UNIT, WINDOW_SIZE)
  // 
  //     # allocate branch tags
  //     s.branch_allocate.br_tag[0].rdy @= s.d1.uop.optype == B_TYPE
  //     s.branch_allocate.br_tag[1].rdy @= s.d2.uop.optype == B_TYPE
  // 
  //     # connecting branch update signals
  //     s.br_update.rdy @= s.branch_allocate.br_update.rdy & s.register_rename.br_update.rdy
  // 
  //     # TODO: FOR CL MODEL
  //     # for i in range(2):
  //     #     assert ~(s.branch_allocate.br_tag[i].rdy ^ s.branch_allocate.br_tag[i].en)
  
  always_comb begin : allocate_
    mem_q_allocate = { { 1 { 1'b0 } }, d1__uop.issue_unit == 2'( __const__MEM_ISSUE_UNIT ) } + { { 1 { 1'b0 } }, d2__uop.issue_unit == 2'( __const__MEM_ISSUE_UNIT ) };
    branch_allocate__br_tag__rdy[1'd0] = d1__uop.optype == 3'( __const__B_TYPE );
    branch_allocate__br_tag__rdy[1'd1] = d2__uop.optype == 3'( __const__B_TYPE );
    br_update__rdy = branch_allocate__br_update__rdy & register_rename__br_update__rdy;
  end

  assign inst1 = fetch_packet.inst1;
  assign inst2 = fetch_packet.inst2;
  assign d1__clk = clk;
  assign d1__reset = reset;
  assign d1__inst = inst1;
  assign d1__pc = fetch_packet.pc;
  assign d1__branch_taken = fetch_packet.branch_taken;
  assign dual_uop.uop1 = d1__uop;
  assign d1__valid = fetch_packet.valid;
  assign d2__clk = clk;
  assign d2__reset = reset;
  assign d2__inst = inst2;
  assign d2__pc = fetch_packet.pc;
  assign d2__branch_taken = fetch_packet.branch_taken;
  assign dual_uop.uop2 = d2__uop;
  assign d2__valid = fetch_packet.valid;
  assign register_rename__clk = clk;
  assign register_rename__reset = reset;
  assign register_rename__inst1_lregs.lrd = d1__uop.lrd;
  assign register_rename__inst1_lregs.lrs1 = d1__uop.lrs1;
  assign register_rename__inst1_lregs.lrs2 = d1__uop.lrs2;
  assign register_rename__inst2_lregs.lrd = d2__uop.lrd;
  assign register_rename__inst2_lregs.lrs1 = d2__uop.lrs1;
  assign register_rename__inst2_lregs.lrs2 = d2__uop.lrs2;
  assign d1__pregs.prd = register_rename__inst1_pregs.prd;
  assign d1__pregs.prs1 = register_rename__inst1_pregs.prs1;
  assign d1__pregs.prs2 = register_rename__inst1_pregs.prs2;
  assign d1__pregs.stale = register_rename__inst1_pregs.stale;
  assign d2__pregs.prd = register_rename__inst2_pregs.prd;
  assign d2__pregs.prs1 = register_rename__inst2_pregs.prs1;
  assign d2__pregs.prs2 = register_rename__inst2_pregs.prs2;
  assign d2__pregs.stale = register_rename__inst2_pregs.stale;
  assign d1__pregs_busy = register_rename__inst1_pregs_busy;
  assign d2__pregs_busy = register_rename__inst2_pregs_busy;
  assign busy_table = register_rename__busy_table;
  assign register_rename__br_update__msg = br_update__msg;
  assign register_rename__br_update__en = br_update__en;
  assign branch_allocate__clk = clk;
  assign branch_allocate__reset = reset;
  assign d1__br_mask = branch_allocate__br_mask[0];
  assign d1__br_tag = branch_allocate__br_tag__msg[0];
  assign d2__br_mask = branch_allocate__br_mask[1];
  assign d2__br_tag = branch_allocate__br_tag__msg[1];
  assign branch_allocate__br_update__msg = br_update__msg;
  assign branch_allocate__br_update__en = br_update__en;
  assign register_rename__stale_in[0] = stale_in[0];
  assign register_rename__ready_in[0] = ready_in[0];
  assign register_rename__stale_in[1] = stale_in[1];
  assign register_rename__ready_in[1] = ready_in[1];

endmodule


// PyMTL Component SingleDispatch Definition
// At /home/cubucher/Desktop/ramp-core/src/cl/dispatch.py

module SingleDispatch_noparam
(
  input  logic [0:0] clk ,
  input  MicroOp__38e2b09b91e4b306 in_ ,
  input  logic [3:0] mem_q_idx ,
  input  logic [0:0] reset ,
  input  logic [4:0] rob_idx ,
  output MicroOp__38e2b09b91e4b306 to_branch_issue ,
  output MicroOp__38e2b09b91e4b306 to_int_issue ,
  output MicroOp__38e2b09b91e4b306 to_mem_issue ,
  output MicroOp__38e2b09b91e4b306 to_rob 
);
  localparam logic [0:0] __const__INT_ISSUE_UNIT  = 1'd1;
  localparam logic [167:0] __const__NO_OP  = 168'd0;
  localparam logic [1:0] __const__MEM_ISSUE_UNIT  = 2'd2;
  localparam logic [1:0] __const__BRANCH_FUNCT_UNIT  = 2'd3;

  // PyMTL Update Block Source
  // At /home/cubucher/Desktop/ramp-core/src/cl/dispatch.py:78
  // @update
  // def conditional_dispatch():
  //     s.to_rob @= s.in_
  
  always_comb begin : conditional_dispatch
    to_rob = in_;
  end

  // PyMTL Update Block Source
  // At /home/cubucher/Desktop/ramp-core/src/cl/dispatch.py:82
  // @update
  // def issue():
  //     if s.in_.issue_unit == INT_ISSUE_UNIT:
  //         s.to_int_issue @= s.in_
  //         s.to_int_issue.rob_idx @= s.rob_idx
  //         s.to_int_issue.mem_q_idx @= 0
  //     else:
  //         s.to_int_issue @= NO_OP
  //     if s.in_.issue_unit == MEM_ISSUE_UNIT:
  //         s.to_mem_issue @= s.in_
  //         s.to_mem_issue.rob_idx @= s.rob_idx
  //         s.to_mem_issue.mem_q_idx @= s.mem_q_idx
  //     else:
  //         s.to_mem_issue @= NO_OP
  //     if s.in_.funct_unit == BRANCH_FUNCT_UNIT:
  //         s.to_branch_issue @= s.in_
  //         s.to_branch_issue.rob_idx @= s.rob_idx
  //         s.to_branch_issue.mem_q_idx @= 0
  //     else:
  //         s.to_branch_issue @= NO_OP
  
  always_comb begin : issue
    if ( in_.issue_unit == 2'( __const__INT_ISSUE_UNIT ) ) begin
      to_int_issue = in_;
      to_int_issue.rob_idx = rob_idx;
      to_int_issue.mem_q_idx = 4'd0;
    end
    else
      to_int_issue = 168'( __const__NO_OP );
    if ( in_.issue_unit == 2'( __const__MEM_ISSUE_UNIT ) ) begin
      to_mem_issue = in_;
      to_mem_issue.rob_idx = rob_idx;
      to_mem_issue.mem_q_idx = mem_q_idx;
    end
    else
      to_mem_issue = 168'( __const__NO_OP );
    if ( in_.funct_unit == 2'( __const__BRANCH_FUNCT_UNIT ) ) begin
      to_branch_issue = in_;
      to_branch_issue.rob_idx = rob_idx;
      to_branch_issue.mem_q_idx = 4'd0;
    end
    else
      to_branch_issue = 168'( __const__NO_OP );
  end

endmodule


// PyMTL Component Dispatch Definition
// At /home/cubucher/Desktop/ramp-core/src/cl/dispatch.py

module Dispatch_noparam
(
  input  logic [0:0] clk ,
  input  DualMicroOp__93e30b890d7542af in_ ,
  input  logic [3:0] mem_q_tail ,
  input  logic [0:0] reset ,
  input  logic [4:0] rob_idx ,
  output DualMicroOp__93e30b890d7542af to_branch_issue ,
  output DualMicroOp__93e30b890d7542af to_int_issue ,
  output DualMicroOp__93e30b890d7542af to_mem_issue ,
  output DualMicroOp__93e30b890d7542af to_rob 
);
  localparam logic [1:0] __const__MEM_ISSUE_UNIT  = 2'd2;
  //-------------------------------------------------------------
  // Component uop1_dispatch
  //-------------------------------------------------------------

  logic [0:0] uop1_dispatch__clk;
  MicroOp__38e2b09b91e4b306 uop1_dispatch__in_;
  logic [3:0] uop1_dispatch__mem_q_idx;
  logic [0:0] uop1_dispatch__reset;
  logic [4:0] uop1_dispatch__rob_idx;
  MicroOp__38e2b09b91e4b306 uop1_dispatch__to_branch_issue;
  MicroOp__38e2b09b91e4b306 uop1_dispatch__to_int_issue;
  MicroOp__38e2b09b91e4b306 uop1_dispatch__to_mem_issue;
  MicroOp__38e2b09b91e4b306 uop1_dispatch__to_rob;

  SingleDispatch_noparam uop1_dispatch
  (
    .clk( uop1_dispatch__clk ),
    .in_( uop1_dispatch__in_ ),
    .mem_q_idx( uop1_dispatch__mem_q_idx ),
    .reset( uop1_dispatch__reset ),
    .rob_idx( uop1_dispatch__rob_idx ),
    .to_branch_issue( uop1_dispatch__to_branch_issue ),
    .to_int_issue( uop1_dispatch__to_int_issue ),
    .to_mem_issue( uop1_dispatch__to_mem_issue ),
    .to_rob( uop1_dispatch__to_rob )
  );

  //-------------------------------------------------------------
  // End of component uop1_dispatch
  //-------------------------------------------------------------

  //-------------------------------------------------------------
  // Component uop2_dispatch
  //-------------------------------------------------------------

  logic [0:0] uop2_dispatch__clk;
  MicroOp__38e2b09b91e4b306 uop2_dispatch__in_;
  logic [3:0] uop2_dispatch__mem_q_idx;
  logic [0:0] uop2_dispatch__reset;
  logic [4:0] uop2_dispatch__rob_idx;
  MicroOp__38e2b09b91e4b306 uop2_dispatch__to_branch_issue;
  MicroOp__38e2b09b91e4b306 uop2_dispatch__to_int_issue;
  MicroOp__38e2b09b91e4b306 uop2_dispatch__to_mem_issue;
  MicroOp__38e2b09b91e4b306 uop2_dispatch__to_rob;

  SingleDispatch_noparam uop2_dispatch
  (
    .clk( uop2_dispatch__clk ),
    .in_( uop2_dispatch__in_ ),
    .mem_q_idx( uop2_dispatch__mem_q_idx ),
    .reset( uop2_dispatch__reset ),
    .rob_idx( uop2_dispatch__rob_idx ),
    .to_branch_issue( uop2_dispatch__to_branch_issue ),
    .to_int_issue( uop2_dispatch__to_int_issue ),
    .to_mem_issue( uop2_dispatch__to_mem_issue ),
    .to_rob( uop2_dispatch__to_rob )
  );

  //-------------------------------------------------------------
  // End of component uop2_dispatch
  //-------------------------------------------------------------

  // PyMTL Update Block Source
  // At /home/cubucher/Desktop/ramp-core/src/cl/dispatch.py:38
  // @update
  // def update_rob_idx():
  //     s.uop1_dispatch.rob_idx @= s.rob_idx
  //     s.uop2_dispatch.rob_idx @= s.rob_idx + 1
  // 
  //     s.uop1_dispatch.mem_q_idx @= 0
  //     s.uop2_dispatch.mem_q_idx @= 0
  //     # uop1 and uop2 in buffer
  //     if (s.in_.uop1.issue_unit == MEM_ISSUE_UNIT) & (
  //         s.in_.uop2.issue_unit == MEM_ISSUE_UNIT
  //     ):
  //         s.uop1_dispatch.mem_q_idx @= s.mem_q_tail - 2
  //         s.uop2_dispatch.mem_q_idx @= s.mem_q_tail - 1
  //     # uop1 is in ls buffer
  //     elif s.in_.uop1.issue_unit == MEM_ISSUE_UNIT:
  //         s.uop1_dispatch.mem_q_idx @= s.mem_q_tail - 1
  //     # uop2 is in ls buffer
  //     elif s.in_.uop2.issue_unit == MEM_ISSUE_UNIT:
  //         s.uop2_dispatch.mem_q_idx @= s.mem_q_tail - 1
  
  always_comb begin : update_rob_idx
    uop1_dispatch__rob_idx = rob_idx;
    uop2_dispatch__rob_idx = rob_idx + 5'd1;
    uop1_dispatch__mem_q_idx = 4'd0;
    uop2_dispatch__mem_q_idx = 4'd0;
    if ( ( in_.uop1.issue_unit == 2'( __const__MEM_ISSUE_UNIT ) ) & ( in_.uop2.issue_unit == 2'( __const__MEM_ISSUE_UNIT ) ) ) begin
      uop1_dispatch__mem_q_idx = mem_q_tail - 4'd2;
      uop2_dispatch__mem_q_idx = mem_q_tail - 4'd1;
    end
    else if ( in_.uop1.issue_unit == 2'( __const__MEM_ISSUE_UNIT ) ) begin
      uop1_dispatch__mem_q_idx = mem_q_tail - 4'd1;
    end
    else if ( in_.uop2.issue_unit == 2'( __const__MEM_ISSUE_UNIT ) ) begin
      uop2_dispatch__mem_q_idx = mem_q_tail - 4'd1;
    end
  end

  assign uop1_dispatch__clk = clk;
  assign uop1_dispatch__reset = reset;
  assign uop1_dispatch__in_ = in_.uop1;
  assign to_rob.uop1 = uop1_dispatch__to_rob;
  assign to_int_issue.uop1 = uop1_dispatch__to_int_issue;
  assign to_mem_issue.uop1 = uop1_dispatch__to_mem_issue;
  assign to_branch_issue.uop1 = uop1_dispatch__to_branch_issue;
  assign uop2_dispatch__clk = clk;
  assign uop2_dispatch__reset = reset;
  assign uop2_dispatch__in_ = in_.uop2;
  assign to_rob.uop2 = uop2_dispatch__to_rob;
  assign to_int_issue.uop2 = uop2_dispatch__to_int_issue;
  assign to_mem_issue.uop2 = uop2_dispatch__to_mem_issue;
  assign to_branch_issue.uop2 = uop2_dispatch__to_branch_issue;

endmodule


// PyMTL Component CombByteAddrROMRTL Definition
// Full name: CombByteAddrROMRTL__num_entries_256__bpw_8__data_[Bits8(0x93), Bits8(0x02), Bits8(0x00), Bits8(0x00), Bits8(0x13), Bits8(0x03), Bits8(0x10), Bits8(0x00), Bits8(0x13), Bits8(0x04), Bits8(0x00), Bits8(0x00), Bits8(0xb3), Bits8(0x83), Bits8(0x62), Bits8(0x00), Bits8(0x93), Bits8(0x02), Bits8(0x03), Bits8(0x00), Bits8(0x13), Bits8(0x83), Bits8(0x03), Bits8(0x00), Bits8(0x23), Bits8(0x20), Bits8(0x54), Bits8(0x00), Bits8(0x13), Bits8(0x04), Bits8(0x44), Bits8(0x00), Bits8(0xe3), Bits8(0x56), Bits8(0x03), Bits8(0xfe), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00)]__num_ports_1
// At /home/cubucher/Desktop/ramp-core/src/cl/fetch_stage.py

module CombByteAddrROMRTL__e5de30f858804e7c
(
  input  logic [0:0] clk ,
  input  logic [7:0] raddr [0:0],
  output logic [63:0] rdata [0:0],
  input  logic [0:0] reset 
);
  localparam logic [0:0] __const__num_ports_at_up_read_rom  = 1'd1;
  logic [7:0] mem [0:255];

  // PyMTL Update Block Source
  // At /home/cubucher/Desktop/ramp-core/src/cl/fetch_stage.py:92
  // @update
  // def up_read_rom():
  //   for i in range(num_ports):
  //     # TODO: generalize for any instruction window size
  //     s.rdata[i] @= concat(s.mem[ s.raddr[i] + 7],
  //                         s.mem[ s.raddr[i] + 6],
  //                         s.mem[ s.raddr[i] + 5],
  //                         s.mem[ s.raddr[i] + 4],
  //                         s.mem[ s.raddr[i] + 3],
  //                         s.mem[ s.raddr[i] + 2],
  //                         s.mem[ s.raddr[i] + 1],
  //                         s.mem[ s.raddr[i] + 0])
  
  always_comb begin : up_read_rom
    for ( int unsigned i = 1'd0; i < 1'( __const__num_ports_at_up_read_rom ); i += 1'd1 )
      rdata[1'(i)] = { mem[raddr[1'(i)] + 8'd7], mem[raddr[1'(i)] + 8'd6], mem[raddr[1'(i)] + 8'd5], mem[raddr[1'(i)] + 8'd4], mem[raddr[1'(i)] + 8'd3], mem[raddr[1'(i)] + 8'd2], mem[raddr[1'(i)] + 8'd1], mem[raddr[1'(i)] + 8'd0] };
  end

  assign mem[0] = 8'd147;
  assign mem[1] = 8'd2;
  assign mem[2] = 8'd0;
  assign mem[3] = 8'd0;
  assign mem[4] = 8'd19;
  assign mem[5] = 8'd3;
  assign mem[6] = 8'd16;
  assign mem[7] = 8'd0;
  assign mem[8] = 8'd19;
  assign mem[9] = 8'd4;
  assign mem[10] = 8'd0;
  assign mem[11] = 8'd0;
  assign mem[12] = 8'd179;
  assign mem[13] = 8'd131;
  assign mem[14] = 8'd98;
  assign mem[15] = 8'd0;
  assign mem[16] = 8'd147;
  assign mem[17] = 8'd2;
  assign mem[18] = 8'd3;
  assign mem[19] = 8'd0;
  assign mem[20] = 8'd19;
  assign mem[21] = 8'd131;
  assign mem[22] = 8'd3;
  assign mem[23] = 8'd0;
  assign mem[24] = 8'd35;
  assign mem[25] = 8'd32;
  assign mem[26] = 8'd84;
  assign mem[27] = 8'd0;
  assign mem[28] = 8'd19;
  assign mem[29] = 8'd4;
  assign mem[30] = 8'd68;
  assign mem[31] = 8'd0;
  assign mem[32] = 8'd227;
  assign mem[33] = 8'd86;
  assign mem[34] = 8'd3;
  assign mem[35] = 8'd254;
  assign mem[36] = 8'd0;
  assign mem[37] = 8'd0;
  assign mem[38] = 8'd0;
  assign mem[39] = 8'd0;
  assign mem[40] = 8'd0;
  assign mem[41] = 8'd0;
  assign mem[42] = 8'd0;
  assign mem[43] = 8'd0;
  assign mem[44] = 8'd0;
  assign mem[45] = 8'd0;
  assign mem[46] = 8'd0;
  assign mem[47] = 8'd0;
  assign mem[48] = 8'd0;
  assign mem[49] = 8'd0;
  assign mem[50] = 8'd0;
  assign mem[51] = 8'd0;
  assign mem[52] = 8'd0;
  assign mem[53] = 8'd0;
  assign mem[54] = 8'd0;
  assign mem[55] = 8'd0;
  assign mem[56] = 8'd0;
  assign mem[57] = 8'd0;
  assign mem[58] = 8'd0;
  assign mem[59] = 8'd0;
  assign mem[60] = 8'd0;
  assign mem[61] = 8'd0;
  assign mem[62] = 8'd0;
  assign mem[63] = 8'd0;
  assign mem[64] = 8'd0;
  assign mem[65] = 8'd0;
  assign mem[66] = 8'd0;
  assign mem[67] = 8'd0;
  assign mem[68] = 8'd0;
  assign mem[69] = 8'd0;
  assign mem[70] = 8'd0;
  assign mem[71] = 8'd0;
  assign mem[72] = 8'd0;
  assign mem[73] = 8'd0;
  assign mem[74] = 8'd0;
  assign mem[75] = 8'd0;
  assign mem[76] = 8'd0;
  assign mem[77] = 8'd0;
  assign mem[78] = 8'd0;
  assign mem[79] = 8'd0;
  assign mem[80] = 8'd0;
  assign mem[81] = 8'd0;
  assign mem[82] = 8'd0;
  assign mem[83] = 8'd0;
  assign mem[84] = 8'd0;
  assign mem[85] = 8'd0;
  assign mem[86] = 8'd0;
  assign mem[87] = 8'd0;
  assign mem[88] = 8'd0;
  assign mem[89] = 8'd0;
  assign mem[90] = 8'd0;
  assign mem[91] = 8'd0;
  assign mem[92] = 8'd0;
  assign mem[93] = 8'd0;
  assign mem[94] = 8'd0;
  assign mem[95] = 8'd0;
  assign mem[96] = 8'd0;
  assign mem[97] = 8'd0;
  assign mem[98] = 8'd0;
  assign mem[99] = 8'd0;
  assign mem[100] = 8'd0;
  assign mem[101] = 8'd0;
  assign mem[102] = 8'd0;
  assign mem[103] = 8'd0;
  assign mem[104] = 8'd0;
  assign mem[105] = 8'd0;
  assign mem[106] = 8'd0;
  assign mem[107] = 8'd0;
  assign mem[108] = 8'd0;
  assign mem[109] = 8'd0;
  assign mem[110] = 8'd0;
  assign mem[111] = 8'd0;
  assign mem[112] = 8'd0;
  assign mem[113] = 8'd0;
  assign mem[114] = 8'd0;
  assign mem[115] = 8'd0;
  assign mem[116] = 8'd0;
  assign mem[117] = 8'd0;
  assign mem[118] = 8'd0;
  assign mem[119] = 8'd0;
  assign mem[120] = 8'd0;
  assign mem[121] = 8'd0;
  assign mem[122] = 8'd0;
  assign mem[123] = 8'd0;
  assign mem[124] = 8'd0;
  assign mem[125] = 8'd0;
  assign mem[126] = 8'd0;
  assign mem[127] = 8'd0;
  assign mem[128] = 8'd0;
  assign mem[129] = 8'd0;
  assign mem[130] = 8'd0;
  assign mem[131] = 8'd0;
  assign mem[132] = 8'd0;
  assign mem[133] = 8'd0;
  assign mem[134] = 8'd0;
  assign mem[135] = 8'd0;
  assign mem[136] = 8'd0;
  assign mem[137] = 8'd0;
  assign mem[138] = 8'd0;
  assign mem[139] = 8'd0;
  assign mem[140] = 8'd0;
  assign mem[141] = 8'd0;
  assign mem[142] = 8'd0;
  assign mem[143] = 8'd0;
  assign mem[144] = 8'd0;
  assign mem[145] = 8'd0;
  assign mem[146] = 8'd0;
  assign mem[147] = 8'd0;
  assign mem[148] = 8'd0;
  assign mem[149] = 8'd0;
  assign mem[150] = 8'd0;
  assign mem[151] = 8'd0;
  assign mem[152] = 8'd0;
  assign mem[153] = 8'd0;
  assign mem[154] = 8'd0;
  assign mem[155] = 8'd0;
  assign mem[156] = 8'd0;
  assign mem[157] = 8'd0;
  assign mem[158] = 8'd0;
  assign mem[159] = 8'd0;
  assign mem[160] = 8'd0;
  assign mem[161] = 8'd0;
  assign mem[162] = 8'd0;
  assign mem[163] = 8'd0;
  assign mem[164] = 8'd0;
  assign mem[165] = 8'd0;
  assign mem[166] = 8'd0;
  assign mem[167] = 8'd0;
  assign mem[168] = 8'd0;
  assign mem[169] = 8'd0;
  assign mem[170] = 8'd0;
  assign mem[171] = 8'd0;
  assign mem[172] = 8'd0;
  assign mem[173] = 8'd0;
  assign mem[174] = 8'd0;
  assign mem[175] = 8'd0;
  assign mem[176] = 8'd0;
  assign mem[177] = 8'd0;
  assign mem[178] = 8'd0;
  assign mem[179] = 8'd0;
  assign mem[180] = 8'd0;
  assign mem[181] = 8'd0;
  assign mem[182] = 8'd0;
  assign mem[183] = 8'd0;
  assign mem[184] = 8'd0;
  assign mem[185] = 8'd0;
  assign mem[186] = 8'd0;
  assign mem[187] = 8'd0;
  assign mem[188] = 8'd0;
  assign mem[189] = 8'd0;
  assign mem[190] = 8'd0;
  assign mem[191] = 8'd0;
  assign mem[192] = 8'd0;
  assign mem[193] = 8'd0;
  assign mem[194] = 8'd0;
  assign mem[195] = 8'd0;
  assign mem[196] = 8'd0;
  assign mem[197] = 8'd0;
  assign mem[198] = 8'd0;
  assign mem[199] = 8'd0;
  assign mem[200] = 8'd0;
  assign mem[201] = 8'd0;
  assign mem[202] = 8'd0;
  assign mem[203] = 8'd0;
  assign mem[204] = 8'd0;
  assign mem[205] = 8'd0;
  assign mem[206] = 8'd0;
  assign mem[207] = 8'd0;
  assign mem[208] = 8'd0;
  assign mem[209] = 8'd0;
  assign mem[210] = 8'd0;
  assign mem[211] = 8'd0;
  assign mem[212] = 8'd0;
  assign mem[213] = 8'd0;
  assign mem[214] = 8'd0;
  assign mem[215] = 8'd0;
  assign mem[216] = 8'd0;
  assign mem[217] = 8'd0;
  assign mem[218] = 8'd0;
  assign mem[219] = 8'd0;
  assign mem[220] = 8'd0;
  assign mem[221] = 8'd0;
  assign mem[222] = 8'd0;
  assign mem[223] = 8'd0;
  assign mem[224] = 8'd0;
  assign mem[225] = 8'd0;
  assign mem[226] = 8'd0;
  assign mem[227] = 8'd0;
  assign mem[228] = 8'd0;
  assign mem[229] = 8'd0;
  assign mem[230] = 8'd0;
  assign mem[231] = 8'd0;
  assign mem[232] = 8'd0;
  assign mem[233] = 8'd0;
  assign mem[234] = 8'd0;
  assign mem[235] = 8'd0;
  assign mem[236] = 8'd0;
  assign mem[237] = 8'd0;
  assign mem[238] = 8'd0;
  assign mem[239] = 8'd0;
  assign mem[240] = 8'd0;
  assign mem[241] = 8'd0;
  assign mem[242] = 8'd0;
  assign mem[243] = 8'd0;
  assign mem[244] = 8'd0;
  assign mem[245] = 8'd0;
  assign mem[246] = 8'd0;
  assign mem[247] = 8'd0;
  assign mem[248] = 8'd0;
  assign mem[249] = 8'd0;
  assign mem[250] = 8'd0;
  assign mem[251] = 8'd0;
  assign mem[252] = 8'd0;
  assign mem[253] = 8'd0;
  assign mem[254] = 8'd0;
  assign mem[255] = 8'd0;

endmodule


// PyMTL Component FetchStage Definition
// Full name: FetchStage__data_[Bits8(0x93), Bits8(0x02), Bits8(0x00), Bits8(0x00), Bits8(0x13), Bits8(0x03), Bits8(0x10), Bits8(0x00), Bits8(0x13), Bits8(0x04), Bits8(0x00), Bits8(0x00), Bits8(0xb3), Bits8(0x83), Bits8(0x62), Bits8(0x00), Bits8(0x93), Bits8(0x02), Bits8(0x03), Bits8(0x00), Bits8(0x13), Bits8(0x83), Bits8(0x03), Bits8(0x00), Bits8(0x23), Bits8(0x20), Bits8(0x54), Bits8(0x00), Bits8(0x13), Bits8(0x04), Bits8(0x44), Bits8(0x00), Bits8(0xe3), Bits8(0x56), Bits8(0x03), Bits8(0xfe), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00)]__size_256__window_size_2
// At /home/cubucher/Desktop/ramp-core/src/cl/fetch_stage.py

module FetchStage__9da88f92371f50f0
(
  input  logic [0:0] clk ,
  output FetchPacket__pc_32__branch_taken_1__inst1_32__inst2_32__valid_1 fetch_packet ,
  output logic [31:0] pc ,
  input  logic [0:0] reset ,
  input logic [0:0] br_update__en  ,
  input BranchUpdate__target_32__mispredict_1__tag_3 br_update__msg  ,
  output logic [0:0] br_update__rdy  
);
  localparam logic [5:0] __const__INSTR_WIDTH  = 6'd32;
  localparam logic [1:0] __const__window_size_at_combi  = 2'd2;
  logic [31:0] pc_next;
  //-------------------------------------------------------------
  // Component icache
  //-------------------------------------------------------------

  logic [0:0] icache__clk;
  logic [7:0] icache__raddr [0:0];
  logic [63:0] icache__rdata [0:0];
  logic [0:0] icache__reset;

  CombByteAddrROMRTL__e5de30f858804e7c icache
  (
    .clk( icache__clk ),
    .raddr( icache__raddr ),
    .rdata( icache__rdata ),
    .reset( icache__reset )
  );

  //-------------------------------------------------------------
  // End of component icache
  //-------------------------------------------------------------

  // PyMTL Update Block Source
  // At /home/cubucher/Desktop/ramp-core/src/cl/fetch_stage.py:59
  // @update
  // def combi():
  //     if ~s.br_update.msg.mispredict | ~s.br_update.en:
  //         s.pc_next @= s.pc + 8  # TODO: branch prediction
  //     else:
  //         s.pc_next @= s.br_update.msg.target
  // 
  //     # calculating input address (converting from byte addr to word addr)
  //     s.icache.raddr[0] @= trunc(s.pc, s.addr_width)
  // 
  //     s.fetch_packet @= FetchPacket(
  //         s.pc,   # pc
  //         0,      # branch_taken TODO: branch prediction
  //         s.icache.rdata[0][0:INSTR_WIDTH],                           # instr1
  //         s.icache.rdata[0][INSTR_WIDTH : window_size * INSTR_WIDTH], # instr2
  //         1,      # valid
  //     )
  
  always_comb begin : combi
    if ( ( ~br_update__msg.mispredict ) | ( ~br_update__en ) ) begin
      pc_next = pc + 32'd8;
    end
    else
      pc_next = br_update__msg.target;
    icache__raddr[1'd0] = 8'(pc);
    fetch_packet = { pc, 1'd0, icache__rdata[1'd0][6'd31:6'd0], icache__rdata[1'd0][7'd63:6'( __const__INSTR_WIDTH )], 1'd1 };
  end

  // PyMTL Update Block Source
  // At /home/cubucher/Desktop/ramp-core/src/cl/fetch_stage.py:51
  // @update_ff
  // def on_tick():
  //     # updating pc
  //     if s.reset:
  //         s.pc <<= 0
  //     else:
  //         s.pc <<= s.pc_next
  
  always_ff @(posedge clk) begin : on_tick
    if ( reset ) begin
      pc <= 32'd0;
    end
    else
      pc <= pc_next;
  end

  assign icache__clk = clk;
  assign icache__reset = reset;
  assign br_update__rdy = 1'd1;

endmodule


// PyMTL Component LoadStoreFU Definition
// At /home/cubucher/Desktop/ramp-core/src/cl/load_store_fu.py

module LoadStoreFU_noparam
(
  input  logic [0:0] clk ,
  input  logic [0:0] enable ,
  input  logic [3:0] funct ,
  input  logic [31:0] imm_in ,
  input  logic [3:0] mem_q_idx_in ,
  input  logic [5:0] prd_addr_in ,
  input  logic [0:0] reset ,
  input  logic [4:0] rob_idx_in ,
  input  logic [31:0] rs1_din ,
  input  logic [31:0] rs2_din ,
  output logic [0:0] load_out__en  ,
  output LoadStoreEntry__op_4__addr_32__data_32__rob_idx_5__mem_q_idx_4 load_out__msg  ,
  input logic [0:0] load_out__rdy  ,
  output logic [0:0] store_out__en  ,
  output LoadStoreEntry__op_4__addr_32__data_32__rob_idx_5__mem_q_idx_4 store_out__msg  ,
  input logic [0:0] store_out__rdy  
);
  localparam logic [3:0] __const__MEM_FLAG  = 4'd8;
  localparam logic [3:0] __const__MEM_LOAD  = 4'd0;
  localparam logic [3:0] __const__MEM_STORE  = 4'd8;
  localparam logic [3:0] __const__MEM_SB  = 4'd8;
  localparam logic [3:0] __const__MEM_SH  = 4'd9;
  localparam logic [3:0] __const__MEM_SW  = 4'd10;

  // PyMTL Update Block Source
  // At /home/cubucher/Desktop/ramp-core/src/cl/load_store_fu.py:36
  // @update
  // def updt():
  //     s.load_out.en @= s.enable & ((s.funct & MEM_FLAG) == MEM_LOAD)
  //     s.load_out.msg.op @= s.funct
  //     s.load_out.msg.addr @= sext(s.imm_in, 32) + s.rs1_din
  //     s.load_out.msg.data @= 0
  //     s.load_out.msg.rob_idx @= s.rob_idx_in
  //     s.load_out.msg.mem_q_idx @= s.mem_q_idx_in
  // 
  //     s.store_out.en @= s.enable & ((s.funct & MEM_FLAG) == MEM_STORE)
  //     s.store_out.msg.op @= s.funct
  //     s.store_out.msg.addr @= sext(s.imm_in, 32) + s.rs1_din
  //     s.store_out.msg.rob_idx @= s.rob_idx_in
  //     s.store_out.msg.mem_q_idx @= s.mem_q_idx_in
  // 
  //     # Getting data for store
  //     # TODO: update for 64 bit
  //     # calculating slice for subword
  //     if s.funct == MEM_SB:
  //         s.store_out.msg.data @= zext(s.rs2_din[0:8], 32)
  //     elif s.funct == MEM_SH:
  //         s.store_out.msg.data @= zext(s.rs2_din[0:16], 32)
  //     elif s.funct == MEM_SW:
  //         s.store_out.msg.data @= s.rs2_din
  //     else:
  //         s.store_out.msg.data @= s.rs2_din
  //     # TODO: CL debugging
  //     # assert ~s.enable | s.load_out.en | s.store_out.en, "Invalid funct"
  
  always_comb begin : updt
    load_out__en = enable & ( ( funct & 4'( __const__MEM_FLAG ) ) == 4'( __const__MEM_LOAD ) );
    load_out__msg.op = funct;
    load_out__msg.addr = imm_in + rs1_din;
    load_out__msg.data = 32'd0;
    load_out__msg.rob_idx = rob_idx_in;
    load_out__msg.mem_q_idx = mem_q_idx_in;
    store_out__en = enable & ( ( funct & 4'( __const__MEM_FLAG ) ) == 4'( __const__MEM_STORE ) );
    store_out__msg.op = funct;
    store_out__msg.addr = imm_in + rs1_din;
    store_out__msg.rob_idx = rob_idx_in;
    store_out__msg.mem_q_idx = mem_q_idx_in;
    if ( funct == 4'( __const__MEM_SB ) ) begin
      store_out__msg.data = { { 24 { 1'b0 } }, rs2_din[5'd7:5'd0] };
    end
    else if ( funct == 4'( __const__MEM_SH ) ) begin
      store_out__msg.data = { { 16 { 1'b0 } }, rs2_din[5'd15:5'd0] };
    end
    else if ( funct == 4'( __const__MEM_SW ) ) begin
      store_out__msg.data = rs2_din;
    end
    else
      store_out__msg.data = rs2_din;
  end

endmodule


// PyMTL Component DRAM Definition
// Full name: DRAM__Type_Bits32__num_entries_256__rd_ports_1__wr_ports_1__reset_value_0
// At /home/cubucher/Desktop/ramp-core/src/cl/dram.py

module DRAM__361782fcf1c09bcb
(
  input  logic [0:0] clk ,
  input  logic [7:0] raddr [0:0],
  output logic [31:0] rdata [0:0],
  input  logic [0:0] reset ,
  input  logic [7:0] waddr [0:0],
  input  logic [31:0] wdata [0:0],
  input  logic [0:0] wen [0:0]
);
  localparam logic [0:0] __const__rd_ports_at_up_rf_read  = 1'd1;
  localparam logic [1:0] __const__addr_shift_at_up_rf_read  = 2'd2;
  localparam logic [8:0] __const__num_entries_at_up_rf_write  = 9'd256;
  localparam logic [0:0] __const__reset_value_at_up_rf_write  = 1'd0;
  localparam logic [0:0] __const__wr_ports_at_up_rf_write  = 1'd1;
  localparam logic [1:0] __const__addr_shift_at_up_rf_write  = 2'd2;
  logic [31:0] mem [0:255];

  // PyMTL Update Block Source
  // At /home/cubucher/Desktop/ramp-core/src/cl/dram.py:33
  // @update
  // def up_rf_read():
  //     for i in range(rd_ports):
  //         # TODO: CL debugging
  //         # assert not (s.raddr[i] % (Type.nbits // 8)), f"Address must be {Type.nbits // 8}-byte aligned"
  //         # byte addressable
  //         s.rdata[i] @= s.mem[s.raddr[i] >> addr_shift]
  
  always_comb begin : up_rf_read
    for ( int unsigned i = 1'd0; i < 1'( __const__rd_ports_at_up_rf_read ); i += 1'd1 )
      rdata[1'(i)] = mem[raddr[1'(i)] >> 2'( __const__addr_shift_at_up_rf_read )];
  end

  // PyMTL Update Block Source
  // At /home/cubucher/Desktop/ramp-core/src/cl/dram.py:41
  // @update_ff
  // def up_rf_write():
  //     if s.reset:
  //         for i in range(num_entries):
  //             s.mem[i] <<= reset_value
  //     else:
  //         for i in range(wr_ports):
  //             if s.wen[i]:
  //                 # TODO: CL debugging
  //                 # assert not (s.waddr[i] % (Type.nbits // 8)), f"Address must be {Type.nbits // 8}-byte aligned"
  //                 s.mem[s.waddr[i] >> addr_shift] <<= s.wdata[i]
  
  always_ff @(posedge clk) begin : up_rf_write
    if ( reset ) begin
      for ( int unsigned i = 1'd0; i < 9'( __const__num_entries_at_up_rf_write ); i += 1'd1 )
        mem[8'(i)] <= 32'( __const__reset_value_at_up_rf_write );
    end
    else
      for ( int unsigned i = 1'd0; i < 1'( __const__wr_ports_at_up_rf_write ); i += 1'd1 )
        if ( wen[1'(i)] ) begin
          mem[waddr[1'(i)] >> 2'( __const__addr_shift_at_up_rf_write )] <= wdata[1'(i)];
        end
  end

endmodule


// PyMTL Component MultiInputRdyCircularBuffer Definition
// Full name: MultiInputRdyCircularBuffer__Type_LoadStoreEntry__op_4__addr_32__data_32__rob_idx_5__mem_q_idx_4__size_16__num_inports_3
// At /home/cubucher/Desktop/ramp-core/src/cl/buffers.py

module MultiInputRdyCircularBuffer__5938a67413e8d704
(
  input  logic [0:0] clk ,
  output logic [4:0] n_elements ,
  input  logic [0:0] reset ,
  output logic [3:0] tail ,
  input logic [0:0] allocate_in__en  ,
  input logic [4:0] allocate_in__msg  ,
  output logic [0:0] allocate_in__rdy  ,
  output logic [0:0] out__en  ,
  output LoadStoreEntry__op_4__addr_32__data_32__rob_idx_5__mem_q_idx_4 out__msg  ,
  input logic [0:0] out__rdy  ,
  input logic [0:0] update_idx_in__en [0:2] ,
  input logic [3:0] update_idx_in__msg [0:2] ,
  output logic [0:0] update_idx_in__rdy [0:2] ,
  input logic [0:0] update_in__en [0:2] ,
  input LoadStoreEntry__op_4__addr_32__data_32__rob_idx_5__mem_q_idx_4 update_in__msg [0:2] ,
  output logic [0:0] update_in__rdy [0:2] 
);
  localparam logic [4:0] __const__size_at_updt_comb  = 5'd16;
  localparam LoadStoreEntry__op_4__addr_32__data_32__rob_idx_5__mem_q_idx_4 __const__type_reset_val_at_updt_comb  = { 4'd0, 32'd0, 32'd0, 5'd0, 4'd0 };
  localparam logic [1:0] __const__num_inports_at_updt_comb  = 2'd3;
  localparam logic [1:0] __const__num_inports_at_updt_ff  = 2'd3;
  LoadStoreEntry__op_4__addr_32__data_32__rob_idx_5__mem_q_idx_4 buffer [0:15];
  logic [0:0] buffer_rdy [0:15];
  logic [0:0] empty;
  logic [0:0] full;
  logic [3:0] head;
  logic [3:0] head_next;
  logic [4:0] n_elements_next;
  logic [0:0] out_en_next;
  LoadStoreEntry__op_4__addr_32__data_32__rob_idx_5__mem_q_idx_4 out_next;
  logic [3:0] tail_next;

  // PyMTL Update Block Source
  // At /home/cubucher/Desktop/ramp-core/src/cl/buffers.py:56
  // @update
  // def updt_comb():
  //     s.full @= s.n_elements == size
  //     s.empty @= s.n_elements == 0
  //     s.allocate_in.rdy @= ~s.full
  // 
  //     # reset
  //     s.out_next @= type_reset_val
  //     s.head_next @= 0
  //     s.tail_next @= 0
  //     s.n_elements_next @= 0
  //     s.out_en_next @= 0
  // 
  //     if ~s.reset:
  //         # default values
  //         s.out_en_next @= 0
  //         s.head_next @= s.head
  //         s.tail_next @= s.tail
  //         s.n_elements_next @= s.n_elements
  // 
  //         # popping off stack if first element valid
  //         if s.out.rdy & ~s.empty:
  //             # checking head of stack
  //             if s.buffer_rdy[s.head]:
  //                 s.out_next @= s.buffer[s.head]
  //                 s.out_en_next @= 1
  //                 s.head_next @= s.head_next + 1
  //                 s.n_elements_next @= s.n_elements - 1
  //             # forwarding update inputs
  //             for i in range(num_inports):
  //                 # ensuring that update data has a corresponding index
  //                 # TODO: CL debugging
  //                 # assert ~(s.update_idx_in[i].en ^ s.update_in[i].en)
  //                 if s.update_idx_in[i].en & (s.update_idx_in[i].msg == s.head):
  //                     # checking that index has valid corresponding data
  //                     s.out_next @= s.update_in[i].msg
  //                     s.out_en_next @= 1
  //                     s.head_next @= s.head_next + 1
  //                     s.n_elements_next @= s.n_elements - 1
  // 
  //         # updating tail with elements allocated
  //         if s.allocate_in.en == 1:
  //             s.tail_next @= trunc(
  //                 zext(s.tail, s.n_elements_nbits) + s.allocate_in.msg,
  //                 s.tail_nbits
  //             )
  //             s.n_elements_next @= s.n_elements_next + zext(
  //                 s.allocate_in.msg,
  //                 s.n_elements_nbits
  //             )
  
  always_comb begin : updt_comb
    full = n_elements == 5'( __const__size_at_updt_comb );
    empty = n_elements == 5'd0;
    allocate_in__rdy = ~full;
    out_next = 77'( __const__type_reset_val_at_updt_comb );
    head_next = 4'd0;
    tail_next = 4'd0;
    n_elements_next = 5'd0;
    out_en_next = 1'd0;
    if ( ~reset ) begin
      out_en_next = 1'd0;
      head_next = head;
      tail_next = tail;
      n_elements_next = n_elements;
      if ( out__rdy & ( ~empty ) ) begin
        if ( buffer_rdy[head] ) begin
          out_next = buffer[head];
          out_en_next = 1'd1;
          head_next = head_next + 4'd1;
          n_elements_next = n_elements - 5'd1;
        end
        for ( int unsigned i = 1'd0; i < 2'( __const__num_inports_at_updt_comb ); i += 1'd1 )
          if ( update_idx_in__en[2'(i)] & ( update_idx_in__msg[2'(i)] == head ) ) begin
            out_next = update_in__msg[2'(i)];
            out_en_next = 1'd1;
            head_next = head_next + 4'd1;
            n_elements_next = n_elements - 5'd1;
          end
      end
      if ( allocate_in__en == 1'd1 ) begin
        tail_next = 4'({ { 1 { 1'b0 } }, tail } + allocate_in__msg);
        n_elements_next = n_elements_next + allocate_in__msg;
      end
    end
  end

  // PyMTL Update Block Source
  // At /home/cubucher/Desktop/ramp-core/src/cl/buffers.py:107
  // @update_ff
  // def updt_ff():
  //     # reset
  //     # TODO: just set the first ready bit to 0?
  //     if s.reset:
  //         for i in range(num_inports):
  //             s.buffer_rdy[i] <<= 0
  // 
  //     # setting newely allocated elements to 0
  //     # if s.allocate_in.en:
  //     #     for i in range(num_inports):
  //     #         if (i > s.tail_next) & (i < s.head_next):
  //     #             s.buffer_rdy[i] <<= 0
  // 
  //     # updating data, and setting ready bit
  //     for i in range(num_inports):
  //         # ensuring that update data has a corresponding index
  //         # TODO: CL debugging
  //         # assert ~(
  //         #     s.update_idx_in[i].en ^ s.update_in[i].en
  //         # ), f"update idx[{i}] en: {s.update_idx_in[i].en}, update[{i}] en: {s.update_in[i].en}"
  //         if s.update_idx_in[i].en:
  //             s.buffer[s.update_idx_in[i].msg] <<= s.update_in[i].msg
  //             s.buffer_rdy[s.update_idx_in[i].msg] <<= 1
  // 
  //     # updating state
  //     s.tail <<= s.tail_next
  //     s.head <<= s.head_next
  //     s.out.msg <<= s.out_next
  //     s.out.en <<= s.out_en_next
  //     s.n_elements <<= s.n_elements_next
  
  always_ff @(posedge clk) begin : updt_ff
    if ( reset ) begin
      for ( int unsigned i = 1'd0; i < 2'( __const__num_inports_at_updt_ff ); i += 1'd1 )
        buffer_rdy[4'(i)] <= 1'd0;
    end
    for ( int unsigned i = 1'd0; i < 2'( __const__num_inports_at_updt_ff ); i += 1'd1 )
      if ( update_idx_in__en[2'(i)] ) begin
        buffer[update_idx_in__msg[2'(i)]] <= update_in__msg[2'(i)];
        buffer_rdy[update_idx_in__msg[2'(i)]] <= 1'd1;
      end
    tail <= tail_next;
    head <= head_next;
    out__msg <= out_next;
    out__en <= out_en_next;
    n_elements <= n_elements_next;
  end

  assign update_in__rdy[0] = 1'd1;
  assign update_idx_in__rdy[0] = 1'd1;
  assign update_in__rdy[1] = 1'd1;
  assign update_idx_in__rdy[1] = 1'd1;
  assign update_in__rdy[2] = 1'd1;
  assign update_idx_in__rdy[2] = 1'd1;

endmodule


// PyMTL Component MemoryUnit Definition
// Full name: MemoryUnit__queue_size_16__memory_size_256__window_size_3__reset_value_0__mmio_start_285212672__mmio_size_255
// At /home/cubucher/Desktop/ramp-core/src/cl/memory_unit.py

module MemoryUnit__b480461cc1d009b8
(
  input  logic [0:0] clk ,
  output logic [3:0] mem_q_tail ,
  input  logic [0:0] reset ,
  input logic [0:0] allocate_in__en  ,
  input logic [1:0] allocate_in__msg  ,
  output logic [0:0] allocate_in__rdy  ,
  input logic [0:0] io_bus_in__en  ,
  input IOEntry__addr_32__data_32 io_bus_in__msg  ,
  output logic [0:0] io_bus_in__rdy  ,
  output logic [0:0] io_bus_out__en  ,
  output IOEntry__addr_32__data_32 io_bus_out__msg  ,
  input logic [0:0] io_bus_out__rdy  ,
  output logic [0:0] load_out__en  ,
  output LoadEntry__data_32__rob_idx_5 load_out__msg  ,
  input logic [0:0] load_out__rdy  ,
  input logic [0:0] update_in__en [0:2] ,
  input LoadStoreEntry__op_4__addr_32__data_32__rob_idx_5__mem_q_idx_4 update_in__msg [0:2] ,
  output logic [0:0] update_in__rdy [0:2] 
);
  localparam logic [28:0] __const__mmio_start_at_connect_  = 29'd285212672;
  localparam logic [7:0] __const__mmio_size_at_connect_  = 8'd255;
  localparam logic [3:0] __const__MEM_FLAG  = 4'd8;
  localparam logic [3:0] __const__MEM_STORE  = 4'd8;
  localparam logic [3:0] __const__MEM_LW  = 4'd2;
  localparam logic [3:0] __const__MEM_LH  = 4'd1;
  localparam logic [3:0] __const__MEM_LHU  = 4'd5;
  localparam logic [3:0] __const__MEM_LB  = 4'd0;
  localparam logic [3:0] __const__MEM_LBU  = 4'd4;
  localparam logic [3:0] __const__MEM_LOAD  = 4'd0;
  //-------------------------------------------------------------
  // Component dram
  //-------------------------------------------------------------

  logic [0:0] dram__clk;
  logic [7:0] dram__raddr [0:0];
  logic [31:0] dram__rdata [0:0];
  logic [0:0] dram__reset;
  logic [7:0] dram__waddr [0:0];
  logic [31:0] dram__wdata [0:0];
  logic [0:0] dram__wen [0:0];

  DRAM__361782fcf1c09bcb dram
  (
    .clk( dram__clk ),
    .raddr( dram__raddr ),
    .rdata( dram__rdata ),
    .reset( dram__reset ),
    .waddr( dram__waddr ),
    .wdata( dram__wdata ),
    .wen( dram__wen )
  );

  //-------------------------------------------------------------
  // End of component dram
  //-------------------------------------------------------------

  //-------------------------------------------------------------
  // Component ls_queue
  //-------------------------------------------------------------

  logic [0:0] ls_queue__clk;
  logic [4:0] ls_queue__n_elements;
  logic [0:0] ls_queue__reset;
  logic [3:0] ls_queue__tail;
  logic [0:0] ls_queue__allocate_in__en;
  logic [4:0] ls_queue__allocate_in__msg;
  logic [0:0] ls_queue__allocate_in__rdy;
  logic [0:0] ls_queue__out__en;
  LoadStoreEntry__op_4__addr_32__data_32__rob_idx_5__mem_q_idx_4 ls_queue__out__msg;
  logic [0:0] ls_queue__out__rdy;
  logic [0:0] ls_queue__update_idx_in__en [0:2];
  logic [3:0] ls_queue__update_idx_in__msg [0:2];
  logic [0:0] ls_queue__update_idx_in__rdy [0:2];
  logic [0:0] ls_queue__update_in__en [0:2];
  LoadStoreEntry__op_4__addr_32__data_32__rob_idx_5__mem_q_idx_4 ls_queue__update_in__msg [0:2];
  logic [0:0] ls_queue__update_in__rdy [0:2];

  MultiInputRdyCircularBuffer__5938a67413e8d704 ls_queue
  (
    .clk( ls_queue__clk ),
    .n_elements( ls_queue__n_elements ),
    .reset( ls_queue__reset ),
    .tail( ls_queue__tail ),
    .allocate_in__en( ls_queue__allocate_in__en ),
    .allocate_in__msg( ls_queue__allocate_in__msg ),
    .allocate_in__rdy( ls_queue__allocate_in__rdy ),
    .out__en( ls_queue__out__en ),
    .out__msg( ls_queue__out__msg ),
    .out__rdy( ls_queue__out__rdy ),
    .update_idx_in__en( ls_queue__update_idx_in__en ),
    .update_idx_in__msg( ls_queue__update_idx_in__msg ),
    .update_idx_in__rdy( ls_queue__update_idx_in__rdy ),
    .update_in__en( ls_queue__update_in__en ),
    .update_in__msg( ls_queue__update_in__msg ),
    .update_in__rdy( ls_queue__update_in__rdy )
  );

  //-------------------------------------------------------------
  // End of component ls_queue
  //-------------------------------------------------------------

  // PyMTL Update Block Source
  // At /home/cubucher/Desktop/ramp-core/src/cl/memory_unit.py:78
  // @update
  // def connect_():
  //     # connecting input to queue
  //     s.ls_queue.out.rdy @= 1
  //     s.ls_queue.allocate_in.msg @= zext(s.allocate_in.msg, queue_addr_nbits)
  //     s.ls_queue.allocate_in.en @= s.allocate_in.en
  //     s.allocate_in.rdy @= s.ls_queue.allocate_in.rdy
  // 
  //     # connecting MMIO to queue (in-order)
  //     if (s.ls_queue.out.msg.addr >= mmio_start) & (s.ls_queue.out.msg.addr < (mmio_start + mmio_size)):
  //         # connecting MMIO output from queue store
  //         s.io_bus_out.msg @= IOEntry(s.ls_queue.out.msg.addr, s.ls_queue.out.msg.data)
  //         s.io_bus_out.en @= (s.ls_queue.out.msg.op & MEM_FLAG) == MEM_STORE
  // 
  //         # connecting MMIO input from queue load
  //         if s.ls_queue.out.msg.op == MEM_LW:
  //             s.load_out.msg.data @= s.io_bus_in.msg.data
  //         elif s.ls_queue.out.msg.op == MEM_LH:
  //             s.load_out.msg.data @= sext(s.io_bus_in.msg.data[0:16], 32)
  //         elif s.ls_queue.out.msg.op == MEM_LHU:
  //             s.load_out.msg.data @= zext(s.io_bus_in.msg.data[0:16], 32)
  //         elif s.ls_queue.out.msg.op == MEM_LB:
  //             s.load_out.msg.data @= sext(s.io_bus_in.msg.data[0:8], 32)
  //         elif s.ls_queue.out.msg.op == MEM_LBU:
  //             s.load_out.msg.data @= zext(s.io_bus_in.msg.data[0:8], 32)
  //         else:
  //             s.load_out.msg.data @= s.io_bus_in.msg.data
  // 
  //         s.load_out.msg.rob_idx @= s.ls_queue.out.msg.rob_idx
  //         s.load_out.en @= s.ls_queue.out.en & (
  //             (s.ls_queue.out.msg.op & MEM_FLAG) == MEM_LOAD
  //         )
  //         s.io_bus_in.rdy @= s.load_out.rdy
  // 
  //     # connecting DRAM to queue
  //     else:
  //         # connecting dram output from queue store
  //         s.dram.raddr[0] @= trunc(s.ls_queue.out.msg.addr, mem_addr_nbits)
  //         s.dram.waddr[0] @= trunc(s.ls_queue.out.msg.addr, mem_addr_nbits)
  //         # slicing and signing happens in execution
  //         s.dram.wdata[0] @= s.ls_queue.out.msg.data
  // 
  //         s.dram.wen[0] @= s.ls_queue.out.en & (
  //             (s.ls_queue.out.msg.op & MEM_FLAG) == MEM_STORE
  //         )
  // 
  //         # connecting dram input from queue load
  //         if s.ls_queue.out.msg.op == MEM_LW:
  //             s.load_out.msg.data @= s.dram.rdata[0]
  //         elif s.ls_queue.out.msg.op == MEM_LH:
  //             s.load_out.msg.data @= sext(s.dram.rdata[0][0:16], 32)
  //         elif s.ls_queue.out.msg.op == MEM_LHU:
  //             s.load_out.msg.data @= zext(s.dram.rdata[0][0:16], 32)
  //         elif s.ls_queue.out.msg.op == MEM_LB:
  //             s.load_out.msg.data @= sext(s.dram.rdata[0][0:8], 32)
  //         elif s.ls_queue.out.msg.op == MEM_LBU:
  //             s.load_out.msg.data @= zext(s.dram.rdata[0][0:8], 32)
  //         else:
  //             s.load_out.msg.data @= s.dram.rdata[0]
  // 
  //         s.load_out.msg.rob_idx @= s.ls_queue.out.msg.rob_idx
  //         s.load_out.en @= s.ls_queue.out.en & (
  //             (s.ls_queue.out.msg.op & MEM_FLAG) == MEM_LOAD
  //         )
  
  always_comb begin : connect_
    ls_queue__out__rdy = 1'd1;
    ls_queue__allocate_in__msg = { { 3 { 1'b0 } }, allocate_in__msg };
    ls_queue__allocate_in__en = allocate_in__en;
    allocate_in__rdy = ls_queue__allocate_in__rdy;
    if ( ( ls_queue__out__msg.addr >= 32'( __const__mmio_start_at_connect_ ) ) & ( ls_queue__out__msg.addr < ( 32'( __const__mmio_start_at_connect_ ) + 32'( __const__mmio_size_at_connect_ ) ) ) ) begin
      io_bus_out__msg = { ls_queue__out__msg.addr, ls_queue__out__msg.data };
      io_bus_out__en = ( ls_queue__out__msg.op & 4'( __const__MEM_FLAG ) ) == 4'( __const__MEM_STORE );
      if ( ls_queue__out__msg.op == 4'( __const__MEM_LW ) ) begin
        load_out__msg.data = io_bus_in__msg.data;
      end
      else if ( ls_queue__out__msg.op == 4'( __const__MEM_LH ) ) begin
        load_out__msg.data = { { 16 { io_bus_in__msg.data[5'd15] } }, io_bus_in__msg.data[5'd15:5'd0] };
      end
      else if ( ls_queue__out__msg.op == 4'( __const__MEM_LHU ) ) begin
        load_out__msg.data = { { 16 { 1'b0 } }, io_bus_in__msg.data[5'd15:5'd0] };
      end
      else if ( ls_queue__out__msg.op == 4'( __const__MEM_LB ) ) begin
        load_out__msg.data = { { 24 { io_bus_in__msg.data[5'd7] } }, io_bus_in__msg.data[5'd7:5'd0] };
      end
      else if ( ls_queue__out__msg.op == 4'( __const__MEM_LBU ) ) begin
        load_out__msg.data = { { 24 { 1'b0 } }, io_bus_in__msg.data[5'd7:5'd0] };
      end
      else
        load_out__msg.data = io_bus_in__msg.data;
      load_out__msg.rob_idx = ls_queue__out__msg.rob_idx;
      load_out__en = ls_queue__out__en & ( ( ls_queue__out__msg.op & 4'( __const__MEM_FLAG ) ) == 4'( __const__MEM_LOAD ) );
      io_bus_in__rdy = load_out__rdy;
    end
    else begin
      dram__raddr[1'd0] = 8'(ls_queue__out__msg.addr);
      dram__waddr[1'd0] = 8'(ls_queue__out__msg.addr);
      dram__wdata[1'd0] = ls_queue__out__msg.data;
      dram__wen[1'd0] = ls_queue__out__en & ( ( ls_queue__out__msg.op & 4'( __const__MEM_FLAG ) ) == 4'( __const__MEM_STORE ) );
      if ( ls_queue__out__msg.op == 4'( __const__MEM_LW ) ) begin
        load_out__msg.data = dram__rdata[1'd0];
      end
      else if ( ls_queue__out__msg.op == 4'( __const__MEM_LH ) ) begin
        load_out__msg.data = { { 16 { dram__rdata[1'd0][5'd15] } }, dram__rdata[1'd0][5'd15:5'd0] };
      end
      else if ( ls_queue__out__msg.op == 4'( __const__MEM_LHU ) ) begin
        load_out__msg.data = { { 16 { 1'b0 } }, dram__rdata[1'd0][5'd15:5'd0] };
      end
      else if ( ls_queue__out__msg.op == 4'( __const__MEM_LB ) ) begin
        load_out__msg.data = { { 24 { dram__rdata[1'd0][5'd7] } }, dram__rdata[1'd0][5'd7:5'd0] };
      end
      else if ( ls_queue__out__msg.op == 4'( __const__MEM_LBU ) ) begin
        load_out__msg.data = { { 24 { 1'b0 } }, dram__rdata[1'd0][5'd7:5'd0] };
      end
      else
        load_out__msg.data = dram__rdata[1'd0];
      load_out__msg.rob_idx = ls_queue__out__msg.rob_idx;
      load_out__en = ls_queue__out__en & ( ( ls_queue__out__msg.op & 4'( __const__MEM_FLAG ) ) == 4'( __const__MEM_LOAD ) );
    end
  end

  assign ls_queue__clk = clk;
  assign ls_queue__reset = reset;
  assign mem_q_tail = ls_queue__tail;
  assign ls_queue__update_in__en[0] = update_in__en[0];
  assign ls_queue__update_in__msg[0] = update_in__msg[0];
  assign update_in__rdy[0] = ls_queue__update_in__rdy[0];
  assign ls_queue__update_idx_in__msg[0] = update_in__msg[0].mem_q_idx;
  assign ls_queue__update_idx_in__en[0] = update_in__en[0];
  assign ls_queue__update_in__en[1] = update_in__en[1];
  assign ls_queue__update_in__msg[1] = update_in__msg[1];
  assign update_in__rdy[1] = ls_queue__update_in__rdy[1];
  assign ls_queue__update_idx_in__msg[1] = update_in__msg[1].mem_q_idx;
  assign ls_queue__update_idx_in__en[1] = update_in__en[1];
  assign ls_queue__update_in__en[2] = update_in__en[2];
  assign ls_queue__update_in__msg[2] = update_in__msg[2];
  assign update_in__rdy[2] = ls_queue__update_in__rdy[2];
  assign ls_queue__update_idx_in__msg[2] = update_in__msg[2].mem_q_idx;
  assign ls_queue__update_idx_in__en[2] = update_in__en[2];
  assign dram__clk = clk;
  assign dram__reset = reset;

endmodule


// PyMTL Component RegEnRst Definition
// Full name: RegEnRst__Type_FetchPacket__pc_32__branch_taken_1__inst1_32__inst2_32__valid_1__reset_value_00000000:0:00000000:00000000:0
// At /home/cubucher/anaconda3/envs/pymtl/lib/python3.8/site-packages/pymtl3/stdlib/basic_rtl/registers.py

module RegEnRst__52ba0effba855e7c
(
  input  logic [0:0] clk ,
  input  logic [0:0] en ,
  input  FetchPacket__pc_32__branch_taken_1__inst1_32__inst2_32__valid_1 in_ ,
  output FetchPacket__pc_32__branch_taken_1__inst1_32__inst2_32__valid_1 out ,
  input  logic [0:0] reset 
);
  localparam FetchPacket__pc_32__branch_taken_1__inst1_32__inst2_32__valid_1 __const__reset_value_at_up_regenrst  = { 32'd0, 1'd0, 32'd0, 32'd0, 1'd0 };

  // PyMTL Update Block Source
  // At /home/cubucher/anaconda3/envs/pymtl/lib/python3.8/site-packages/pymtl3/stdlib/basic_rtl/registers.py:55
  // @update_ff
  // def up_regenrst():
  //   if s.reset: s.out <<= reset_value
  //   elif s.en:  s.out <<= s.in_
  
  always_ff @(posedge clk) begin : up_regenrst
    if ( reset ) begin
      out <= 98'( __const__reset_value_at_up_regenrst );
    end
    else if ( en ) begin
      out <= in_;
    end
  end

endmodule


// PyMTL Component RegEnRst Definition
// Full name: RegEnRst__Type_DualMicroOp__93e30b890d7542af__reset_value_optype: 0 inst: 00000000 pc: 00000000 valid: 0 imm: 00000000 i_unit: 0 f_unit: 0 f_op: 0 br_taken: 0 br_mask: 00 br_tag: 0 lr : 00:00:00 pr : 00:00:00 stale: x00 rob_idx: 00 mem_q_idx: 0:optype: 0 inst: 00000000 pc: 00000000 valid: 0 imm: 00000000 i_unit: 0 f_unit: 0 f_op: 0 br_taken: 0 br_mask: 00 br_tag: 0 lr : 00:00:00 pr : 00:00:00 stale: x00 rob_idx: 00 mem_q_idx: 0
// At /home/cubucher/anaconda3/envs/pymtl/lib/python3.8/site-packages/pymtl3/stdlib/basic_rtl/registers.py

module RegEnRst__f6b304c6c5a627a4
(
  input  logic [0:0] clk ,
  input  logic [0:0] en ,
  input  DualMicroOp__93e30b890d7542af in_ ,
  output DualMicroOp__93e30b890d7542af out ,
  input  logic [0:0] reset 
);
  localparam DualMicroOp__93e30b890d7542af __const__reset_value_at_up_regenrst  = { { 3'd0, 32'd0, 32'd0, 1'd0, 5'd0, 5'd0, 5'd0, 6'd0, 6'd0, 6'd0, 6'd0, 32'd0, 2'd0, 2'd0, 4'd0, 1'd0, 8'd0, 3'd0, 5'd0, 4'd0 }, { 3'd0, 32'd0, 32'd0, 1'd0, 5'd0, 5'd0, 5'd0, 6'd0, 6'd0, 6'd0, 6'd0, 32'd0, 2'd0, 2'd0, 4'd0, 1'd0, 8'd0, 3'd0, 5'd0, 4'd0 } };

  // PyMTL Update Block Source
  // At /home/cubucher/anaconda3/envs/pymtl/lib/python3.8/site-packages/pymtl3/stdlib/basic_rtl/registers.py:55
  // @update_ff
  // def up_regenrst():
  //   if s.reset: s.out <<= reset_value
  //   elif s.en:  s.out <<= s.in_
  
  always_ff @(posedge clk) begin : up_regenrst
    if ( reset ) begin
      out <= 336'( __const__reset_value_at_up_regenrst );
    end
    else if ( en ) begin
      out <= in_;
    end
  end

endmodule


// PyMTL Component RegisterFile Definition
// Full name: RegisterFile__Type_Bits32__nregs_64__rd_ports_6__wr_ports_2__const_zero_True
// At /home/cubucher/anaconda3/envs/pymtl/lib/python3.8/site-packages/pymtl3/stdlib/basic_rtl/register_files.py

module RegisterFile__d5a8eae0540cd56b
(
  input  logic [0:0] clk ,
  input  logic [5:0] raddr [0:5],
  output logic [31:0] rdata [0:5],
  input  logic [0:0] reset ,
  input  logic [5:0] waddr [0:1],
  input  logic [31:0] wdata [0:1],
  input  logic [0:0] wen [0:1]
);
  localparam logic [2:0] __const__rd_ports_at_up_rf_read  = 3'd6;
  localparam logic [1:0] __const__wr_ports_at_up_rf_write_constzero  = 2'd2;
  logic [31:0] regs [0:63];

  // PyMTL Update Block Source
  // At /home/cubucher/anaconda3/envs/pymtl/lib/python3.8/site-packages/pymtl3/stdlib/basic_rtl/register_files.py:20
  // @update
  // def up_rf_read():
  //   for i in range( rd_ports ):
  //     s.rdata[i] @= s.regs[ s.raddr[i] ]
  
  always_comb begin : up_rf_read
    for ( int unsigned i = 1'd0; i < 3'( __const__rd_ports_at_up_rf_read ); i += 1'd1 )
      rdata[3'(i)] = regs[raddr[3'(i)]];
  end

  // PyMTL Update Block Source
  // At /home/cubucher/anaconda3/envs/pymtl/lib/python3.8/site-packages/pymtl3/stdlib/basic_rtl/register_files.py:26
  // @update_ff
  // def up_rf_write_constzero():
  //   for i in range( wr_ports ):
  //     if s.wen[i] & (s.waddr[i] != 0):
  //       s.regs[ s.waddr[i] ] <<= s.wdata[i]
  
  always_ff @(posedge clk) begin : up_rf_write_constzero
    for ( int unsigned i = 1'd0; i < 2'( __const__wr_ports_at_up_rf_write_constzero ); i += 1'd1 )
      if ( wen[1'(i)] & ( waddr[1'(i)] != 6'd0 ) ) begin
        regs[waddr[1'(i)]] <= wdata[1'(i)];
      end
  end

endmodule


// PyMTL Component ReorderBuffer Definition
// At /home/cubucher/Desktop/ramp-core/src/cl/reorder_buffer.py

module ReorderBuffer_noparam
(
  output logic [0:0] bank_empty ,
  output logic [0:0] bank_full ,
  input  logic [0:0] clk ,
  output ROBEntry__dfb4245d7bc69416 commit_out ,
  input  ExecToROB__894aaf470679b4c5 op_complete ,
  input  logic [0:0] reset ,
  output logic [4:0] rob_tail ,
  input  DualMicroOp__93e30b890d7542af write_in ,
  input logic [0:0] br_update__en  ,
  input BranchUpdate__target_32__mispredict_1__tag_3 br_update__msg  ,
  output logic [0:0] br_update__rdy  
);
  localparam ROBEntryUop__0a11cf2a2340c105 __const__empty_rob_entry_at_comb_  = { 1'd0, 1'd0, 3'd0, 6'd0, 6'd0, 32'd0, 4'd0, 32'd0, 32'd0, 3'd0, 1'd0, 8'd0 };
  localparam logic [5:0] __const__ROB_SIZE  = 6'd32;
  localparam logic [0:0] __const__one_at_comb_  = 1'd1;
  ROBEntry__dfb4245d7bc69416 instr_bank [0:15];
  ROBEntry__dfb4245d7bc69416 instr_bank_next [0:15];
  logic [3:0] internal_rob_head;
  logic [3:0] internal_rob_head_next;
  logic [3:0] internal_rob_tail;
  logic [3:0] internal_rob_tail_next;
  ROBEntryUop__0a11cf2a2340c105 uop1_entry;
  ROBEntryUop__0a11cf2a2340c105 uop1_entry_next;
  ROBEntryUop__0a11cf2a2340c105 uop2_entry;
  ROBEntryUop__0a11cf2a2340c105 uop2_entry_next;
  logic [3:0] __tmpvar__comb__internal_int_rob_addr;
  logic [3:0] __tmpvar__comb__internal_load_rob_addr;
  logic [3:0] __tmpvar__comb__internal_store_rob_addr;
  logic [3:0] __tmpvar__comb__internal_br_rob_addr;
  logic [7:0] __tmpvar__comb__tag_mask;

  // PyMTL Update Block Source
  // At /home/cubucher/Desktop/ramp-core/src/cl/reorder_buffer.py:72
  // @update
  // def comb_():
  //     # indexed so that uop1 is at odd indices and uop2 is at even indices
  //     s.rob_tail @= zext(s.internal_rob_tail, rob_addr_nbits) << 1
  // 
  //     # bank full if head == tail and value is busy
  //     s.bank_full @= (
  //         (s.internal_rob_head == s.internal_rob_tail)
  //         & s.instr_bank[s.internal_rob_tail].uop1_entry.busy
  //         & s.instr_bank[s.internal_rob_tail].uop2_entry.busy
  //     )
  // 
  //     # bank empty if head == tail and value is invalid(TODO: ?)
  //     s.bank_empty @= (s.internal_rob_head == s.internal_rob_tail) & ~(
  //         s.instr_bank[s.internal_rob_tail].uop1_entry.busy
  //         | s.instr_bank[s.internal_rob_tail].uop2_entry.busy
  //     )
  // 
  //     # defaults
  //     s.internal_rob_head_next @= s.internal_rob_head
  //     s.internal_rob_tail_next @= s.internal_rob_tail
  //     s.uop1_entry_next @= empty_rob_entry
  //     s.uop1_entry_next @= empty_rob_entry
  //     for i in range(ROB_SIZE >> 1):
  //         s.instr_bank_next[i] @= s.instr_bank[i]
  // 
  //     # WRITING TO ROB
  //     # if either of the uops is valid, and there is room in the buffer,
  //     # write both to the ROB
  //     if s.write_in.uop1.valid | s.write_in.uop2.valid:
  //         # if the circular buffer is not full
  //         # TODO: assert for CL
  //         # assert ~s.bank_full, "ROB is full and tried to write"
  //         s.instr_bank_next[s.internal_rob_tail] @= ROBEntry(
  //             s.write_in.uop1.pc,                 # PC
  //             ROBEntryUop(                        # uop1
  //                 s.write_in.uop1.valid,          # valid
  //                 s.write_in.uop1.valid,          # busy
  //                 s.write_in.uop1.optype,         # optype
  //                 s.write_in.uop1.prd,            # prd
  //                 s.write_in.uop1.stale,          # stale
  //                 0,                              # data
  //                 0,                              # mem_q_idx
  //                 0,                              # store_addr
  //                 0,                              # br_target
  //                 0,                              # br_tag
  //                 0,                              # br_mispredict
  //                 s.write_in.uop1.br_mask,        # br_mask
  //             ),
  //             ROBEntryUop(                        # uop2
  //                 s.write_in.uop2.valid,          # valid
  //                 s.write_in.uop2.valid,          # busy
  //                 s.write_in.uop2.optype,         # optype
  //                 s.write_in.uop2.prd,            # prd
  //                 s.write_in.uop2.stale,          # stale
  //                 0,                              # data
  //                 0,                              # mem_q_idx
  //                 0,                              # store_addr
  //                 0,                              # br_target
  //                 0,                              # br_tag
  //                 0,                              # br_mispredict
  //                 s.write_in.uop2.br_mask,        # br_mask
  //             ),
  //         )
  //         s.internal_rob_tail_next @= s.internal_rob_tail + 1  # wrap around
  // 
  //     # UPDATING COMPLETED UOPS
  //     # even though actual instruction bank is 2 wide,
  //     # uop1 and uop2 are indexed seperately (even and odd respectively)
  //     # rob indices must be calculated from these indices in the uop
  // 
  //     # INTEGER UPDATES
  //     internal_int_rob_addr = trunc(s.op_complete.int_rob_idx >> 1, instr_bank_addr_nbits)
  //     if s.op_complete.int_rob_complete:
  //         if s.op_complete.int_rob_idx % 2 == 0:
  //             # even index, uop1 is completed
  //             s.instr_bank_next[internal_int_rob_addr].uop1_entry.busy @= 0
  //             s.instr_bank_next[
  //                 internal_int_rob_addr
  //             ].uop1_entry.data @= s.op_complete.int_data
  //         else:
  //             # odd index, uop2 is completed
  //             s.instr_bank_next[internal_int_rob_addr].uop2_entry.busy @= 0
  //             s.instr_bank_next[
  //                 internal_int_rob_addr
  //             ].uop2_entry.data @= s.op_complete.int_data
  // 
  //     # LOAD UPDATES
  //     internal_load_rob_addr = trunc(s.op_complete.load_rob_idx >> 1, instr_bank_addr_nbits)
  //     if s.op_complete.load_rob_complete:
  //         if s.op_complete.load_rob_idx % 2 == 0:
  //             # even index, uop1 is completed
  //             s.instr_bank_next[internal_load_rob_addr].uop1_entry.busy @= 0
  //             s.instr_bank_next[
  //                 internal_load_rob_addr
  //             ].uop1_entry.data @= s.op_complete.load_data
  //         else:
  //             # odd index, uop2 is completed
  //             s.instr_bank_next[internal_load_rob_addr].uop2_entry.busy @= 0
  //             s.instr_bank_next[
  //                 internal_load_rob_addr
  //             ].uop2_entry.data @= s.op_complete.load_data
  // 
  //     # STORE UPDATES
  //     internal_store_rob_addr = trunc(s.op_complete.store_rob_idx >> 1, instr_bank_addr_nbits)
  //     if s.op_complete.store_rob_complete:
  //         if s.op_complete.store_rob_idx % 2 == 0:
  //             # even index, uop1 is completed
  //             s.instr_bank_next[internal_store_rob_addr].uop1_entry.busy @= 0
  //             s.instr_bank_next[
  //                 internal_store_rob_addr
  //             ].uop1_entry.data @= s.op_complete.store_data
  //             s.instr_bank_next[
  //                 internal_store_rob_addr
  //             ].uop1_entry.store_addr @= s.op_complete.store_addr
  //             s.instr_bank_next[
  //                 internal_store_rob_addr
  //             ].uop1_entry.mem_q_idx @= s.op_complete.store_mem_q_idx
  //         else:
  //             # odd index, uop2 is completed
  //             s.instr_bank_next[internal_store_rob_addr].uop2_entry.busy @= 0
  //             s.instr_bank_next[
  //                 internal_store_rob_addr
  //             ].uop2_entry.data @= s.op_complete.store_data
  //             s.instr_bank_next[
  //                 internal_store_rob_addr
  //             ].uop2_entry.store_addr @= s.op_complete.store_addr
  //             s.instr_bank_next[
  //                 internal_store_rob_addr
  //             ].uop2_entry.mem_q_idx @= s.op_complete.store_mem_q_idx
  // 
  //     # BRANCH UPDATES
  //     internal_br_rob_addr = trunc(s.op_complete.br_rob_idx >> 1, instr_bank_addr_nbits)
  //     if s.op_complete.br_rob_complete:
  //         if s.op_complete.br_rob_idx % 2 == 0:
  //             # even index, uop1 is completed
  //             s.instr_bank_next[internal_br_rob_addr].uop1_entry.busy @= 0
  //             s.instr_bank_next[
  //                 internal_br_rob_addr
  //             ].uop1_entry.br_target @= s.op_complete.br_target
  //             s.instr_bank_next[
  //                 internal_br_rob_addr
  //             ].uop1_entry.br_tag @= s.op_complete.br_tag
  //             s.instr_bank_next[
  //                 internal_br_rob_addr
  //             ].uop1_entry.br_mispredict @= s.op_complete.br_mispredict
  //         else:
  //             # odd index, uop2 is completed
  //             s.instr_bank_next[internal_br_rob_addr].uop2_entry.busy @= 0
  //             s.instr_bank_next[
  //                 internal_br_rob_addr
  //             ].uop2_entry.br_target @= s.op_complete.br_target
  //             s.instr_bank_next[
  //                 internal_br_rob_addr
  //             ].uop2_entry.br_tag @= s.op_complete.br_tag
  //             s.instr_bank_next[
  //                 internal_br_rob_addr
  //             ].uop2_entry.br_mispredict @= s.op_complete.br_mispredict
  // 
  //     # BRANCH PREDICTION UPDATES (updating tags with branch outcomes)
  //     tag_mask = zext(one, NUM_BRANCHES) << zext(s.br_update.msg.tag, NUM_BRANCHES)
  // 
  //     if s.br_update.en:
  //         for i in range(ROB_SIZE >> 1):
  //             # if the branch was predicted correctly, update bitmask
  //             if ~s.br_update.msg.mispredict:
  //                 s.instr_bank_next[i].uop1_entry.br_mask @= (
  //                     s.instr_bank[i].uop1_entry.br_mask & ~tag_mask
  //                 )
  //                 s.instr_bank_next[i].uop2_entry.br_mask @= (
  //                     s.instr_bank[i].uop2_entry.br_mask & ~tag_mask
  //                 )
  //             # if the branch was predicted incorrectly robentry is dependent on branch
  //             # invalidate robentry
  //             else:
  //                 if s.instr_bank[i].uop1_entry.br_mask & tag_mask:
  //                     s.instr_bank_next[i].uop1_entry.valid @= 0
  //                     s.instr_bank_next[i].uop1_entry.busy @= 0
  //                 if s.instr_bank[i].uop2_entry.br_mask & tag_mask:
  //                     s.instr_bank_next[i].uop2_entry.valid @= 0
  //                     s.instr_bank_next[i].uop2_entry.busy @= 0
  // 
  //     # COMMITTING
  //     # committed store instructions write to memory
  //     # committed arithmetic instructions deallocate stale reg
  // 
  //     # if the ROB's head entry uop1 is valid, not busy, and not under speculation, commit
  //     if (
  //         s.instr_bank_next[s.internal_rob_head_next].uop1_entry.valid
  //         & ~s.instr_bank_next[s.internal_rob_head_next].uop1_entry.busy
  //         & (s.instr_bank_next[s.internal_rob_head_next].uop1_entry.br_mask == 0)
  //     ):
  //         s.uop1_entry_next @= s.instr_bank_next[
  //             s.internal_rob_head_next
  //         ].uop1_entry
  //         s.instr_bank_next[s.internal_rob_head_next].uop1_entry.valid @= 0
  //     # otherwise do not commit it
  //     else:
  //         s.uop1_entry_next @= empty_rob_entry
  //     # if the ROB's head entry uop2 is valid and not busy, commit it
  //     if (
  //         s.instr_bank_next[s.internal_rob_head_next].uop2_entry.valid
  //         & ~s.instr_bank_next[s.internal_rob_head_next].uop2_entry.busy
  //         & (s.instr_bank_next[s.internal_rob_head_next].uop1_entry.br_mask == 0)
  //     ):
  //         s.uop2_entry_next @= s.instr_bank_next[
  //             s.internal_rob_head_next
  //         ].uop2_entry
  //         s.instr_bank_next[s.internal_rob_head_next].uop2_entry.valid @= 0
  //     # otherwise do not commit it
  //     else:
  //         s.uop2_entry_next @= empty_rob_entry
  // 
  //     # if the ROB's head entry is not busy (committed), deallocate it
  //     if (
  //         ~s.instr_bank_next[s.internal_rob_head_next].uop1_entry.valid
  //         & ~s.instr_bank_next[s.internal_rob_head_next].uop2_entry.valid
  //     ):
  //         # if the circular buffer is not empty
  //         if ~s.bank_empty:
  //             s.internal_rob_head_next @= s.internal_rob_head_next + 1
  //         # else:
  //         #     raise Exception("ROB is empty, and tried to deallocate")
  // 
  // 
  //     # ASYNCHRONOUS RESET
  //     if s.reset:
  //         s.internal_rob_head_next @= 0
  //         s.internal_rob_tail_next @= 0
  //         s.uop1_entry_next @= empty_rob_entry
  //         s.uop1_entry_next @= empty_rob_entry
  // 
  //         for i in range(ROB_SIZE >> 1):
  //             s.instr_bank_next[i].uop1_entry.valid @= 0
  //             s.instr_bank_next[i].uop2_entry.valid @= 0
  //             s.instr_bank_next[i].uop1_entry.busy @= 0
  //             s.instr_bank_next[i].uop2_entry.busy @= 0
  
  always_comb begin : comb_
    rob_tail = { { 1 { 1'b0 } }, internal_rob_tail } << 1'd1;
    bank_full = ( ( internal_rob_head == internal_rob_tail ) & instr_bank[internal_rob_tail].uop1_entry.busy ) & instr_bank[internal_rob_tail].uop2_entry.busy;
    bank_empty = ( internal_rob_head == internal_rob_tail ) & ( ~( instr_bank[internal_rob_tail].uop1_entry.busy | instr_bank[internal_rob_tail].uop2_entry.busy ) );
    internal_rob_head_next = internal_rob_head;
    internal_rob_tail_next = internal_rob_tail;
    uop1_entry_next = 129'( __const__empty_rob_entry_at_comb_ );
    uop1_entry_next = 129'( __const__empty_rob_entry_at_comb_ );
    for ( int unsigned i = 1'd0; i < 6'( __const__ROB_SIZE ) >> 1'd1; i += 1'd1 )
      instr_bank_next[4'(i)] = instr_bank[4'(i)];
    if ( write_in.uop1.valid | write_in.uop2.valid ) begin
      instr_bank_next[internal_rob_tail] = { write_in.uop1.pc, { write_in.uop1.valid, write_in.uop1.valid, write_in.uop1.optype, write_in.uop1.prd, write_in.uop1.stale, 32'd0, 4'd0, 32'd0, 32'd0, 3'd0, 1'd0, write_in.uop1.br_mask }, { write_in.uop2.valid, write_in.uop2.valid, write_in.uop2.optype, write_in.uop2.prd, write_in.uop2.stale, 32'd0, 4'd0, 32'd0, 32'd0, 3'd0, 1'd0, write_in.uop2.br_mask } };
      internal_rob_tail_next = internal_rob_tail + 4'd1;
    end
    __tmpvar__comb__internal_int_rob_addr = 4'(op_complete.int_rob_idx >> 1'd1);
    if ( op_complete.int_rob_complete ) begin
      if ( ( op_complete.int_rob_idx % 5'd2 ) == 5'd0 ) begin
        instr_bank_next[__tmpvar__comb__internal_int_rob_addr].uop1_entry.busy = 1'd0;
        instr_bank_next[__tmpvar__comb__internal_int_rob_addr].uop1_entry.data = op_complete.int_data;
      end
      else begin
        instr_bank_next[__tmpvar__comb__internal_int_rob_addr].uop2_entry.busy = 1'd0;
        instr_bank_next[__tmpvar__comb__internal_int_rob_addr].uop2_entry.data = op_complete.int_data;
      end
    end
    __tmpvar__comb__internal_load_rob_addr = 4'(op_complete.load_rob_idx >> 1'd1);
    if ( op_complete.load_rob_complete ) begin
      if ( ( op_complete.load_rob_idx % 5'd2 ) == 5'd0 ) begin
        instr_bank_next[__tmpvar__comb__internal_load_rob_addr].uop1_entry.busy = 1'd0;
        instr_bank_next[__tmpvar__comb__internal_load_rob_addr].uop1_entry.data = op_complete.load_data;
      end
      else begin
        instr_bank_next[__tmpvar__comb__internal_load_rob_addr].uop2_entry.busy = 1'd0;
        instr_bank_next[__tmpvar__comb__internal_load_rob_addr].uop2_entry.data = op_complete.load_data;
      end
    end
    __tmpvar__comb__internal_store_rob_addr = 4'(op_complete.store_rob_idx >> 1'd1);
    if ( op_complete.store_rob_complete ) begin
      if ( ( op_complete.store_rob_idx % 5'd2 ) == 5'd0 ) begin
        instr_bank_next[__tmpvar__comb__internal_store_rob_addr].uop1_entry.busy = 1'd0;
        instr_bank_next[__tmpvar__comb__internal_store_rob_addr].uop1_entry.data = op_complete.store_data;
        instr_bank_next[__tmpvar__comb__internal_store_rob_addr].uop1_entry.store_addr = op_complete.store_addr;
        instr_bank_next[__tmpvar__comb__internal_store_rob_addr].uop1_entry.mem_q_idx = op_complete.store_mem_q_idx;
      end
      else begin
        instr_bank_next[__tmpvar__comb__internal_store_rob_addr].uop2_entry.busy = 1'd0;
        instr_bank_next[__tmpvar__comb__internal_store_rob_addr].uop2_entry.data = op_complete.store_data;
        instr_bank_next[__tmpvar__comb__internal_store_rob_addr].uop2_entry.store_addr = op_complete.store_addr;
        instr_bank_next[__tmpvar__comb__internal_store_rob_addr].uop2_entry.mem_q_idx = op_complete.store_mem_q_idx;
      end
    end
    __tmpvar__comb__internal_br_rob_addr = 4'(op_complete.br_rob_idx >> 1'd1);
    if ( op_complete.br_rob_complete ) begin
      if ( ( op_complete.br_rob_idx % 5'd2 ) == 5'd0 ) begin
        instr_bank_next[__tmpvar__comb__internal_br_rob_addr].uop1_entry.busy = 1'd0;
        instr_bank_next[__tmpvar__comb__internal_br_rob_addr].uop1_entry.br_target = op_complete.br_target;
        instr_bank_next[__tmpvar__comb__internal_br_rob_addr].uop1_entry.br_tag = op_complete.br_tag;
        instr_bank_next[__tmpvar__comb__internal_br_rob_addr].uop1_entry.br_mispredict = op_complete.br_mispredict;
      end
      else begin
        instr_bank_next[__tmpvar__comb__internal_br_rob_addr].uop2_entry.busy = 1'd0;
        instr_bank_next[__tmpvar__comb__internal_br_rob_addr].uop2_entry.br_target = op_complete.br_target;
        instr_bank_next[__tmpvar__comb__internal_br_rob_addr].uop2_entry.br_tag = op_complete.br_tag;
        instr_bank_next[__tmpvar__comb__internal_br_rob_addr].uop2_entry.br_mispredict = op_complete.br_mispredict;
      end
    end
    __tmpvar__comb__tag_mask = { { 7 { 1'b0 } }, 1'( __const__one_at_comb_ ) } << { { 5 { 1'b0 } }, br_update__msg.tag };
    if ( br_update__en ) begin
      for ( int unsigned i = 1'd0; i < 6'( __const__ROB_SIZE ) >> 1'd1; i += 1'd1 )
        if ( ~br_update__msg.mispredict ) begin
          instr_bank_next[4'(i)].uop1_entry.br_mask = instr_bank[4'(i)].uop1_entry.br_mask & ( ~__tmpvar__comb__tag_mask );
          instr_bank_next[4'(i)].uop2_entry.br_mask = instr_bank[4'(i)].uop2_entry.br_mask & ( ~__tmpvar__comb__tag_mask );
        end
        else begin
          if ( instr_bank[4'(i)].uop1_entry.br_mask & __tmpvar__comb__tag_mask ) begin
            instr_bank_next[4'(i)].uop1_entry.valid = 1'd0;
            instr_bank_next[4'(i)].uop1_entry.busy = 1'd0;
          end
          if ( instr_bank[4'(i)].uop2_entry.br_mask & __tmpvar__comb__tag_mask ) begin
            instr_bank_next[4'(i)].uop2_entry.valid = 1'd0;
            instr_bank_next[4'(i)].uop2_entry.busy = 1'd0;
          end
        end
    end
    if ( ( instr_bank_next[internal_rob_head_next].uop1_entry.valid & ( ~instr_bank_next[internal_rob_head_next].uop1_entry.busy ) ) & ( instr_bank_next[internal_rob_head_next].uop1_entry.br_mask == 8'd0 ) ) begin
      uop1_entry_next = instr_bank_next[internal_rob_head_next].uop1_entry;
      instr_bank_next[internal_rob_head_next].uop1_entry.valid = 1'd0;
    end
    else
      uop1_entry_next = 129'( __const__empty_rob_entry_at_comb_ );
    if ( ( instr_bank_next[internal_rob_head_next].uop2_entry.valid & ( ~instr_bank_next[internal_rob_head_next].uop2_entry.busy ) ) & ( instr_bank_next[internal_rob_head_next].uop1_entry.br_mask == 8'd0 ) ) begin
      uop2_entry_next = instr_bank_next[internal_rob_head_next].uop2_entry;
      instr_bank_next[internal_rob_head_next].uop2_entry.valid = 1'd0;
    end
    else
      uop2_entry_next = 129'( __const__empty_rob_entry_at_comb_ );
    if ( ( ~instr_bank_next[internal_rob_head_next].uop1_entry.valid ) & ( ~instr_bank_next[internal_rob_head_next].uop2_entry.valid ) ) begin
      if ( ~bank_empty ) begin
        internal_rob_head_next = internal_rob_head_next + 4'd1;
      end
    end
    if ( reset ) begin
      internal_rob_head_next = 4'd0;
      internal_rob_tail_next = 4'd0;
      uop1_entry_next = 129'( __const__empty_rob_entry_at_comb_ );
      uop1_entry_next = 129'( __const__empty_rob_entry_at_comb_ );
      for ( int unsigned i = 1'd0; i < 6'( __const__ROB_SIZE ) >> 1'd1; i += 1'd1 ) begin
        instr_bank_next[4'(i)].uop1_entry.valid = 1'd0;
        instr_bank_next[4'(i)].uop2_entry.valid = 1'd0;
        instr_bank_next[4'(i)].uop1_entry.busy = 1'd0;
        instr_bank_next[4'(i)].uop2_entry.busy = 1'd0;
      end
    end
  end

  // PyMTL Update Block Source
  // At /home/cubucher/Desktop/ramp-core/src/cl/reorder_buffer.py:310
  // @update_ff
  // def sync_():
  //     s.internal_rob_head <<= s.internal_rob_head_next
  //     s.internal_rob_tail <<= s.internal_rob_tail_next
  //     s.uop1_entry <<= s.uop1_entry_next
  //     s.uop2_entry <<= s.uop2_entry_next
  //     for i in range(ROB_SIZE >> 1):
  //         s.instr_bank[i] <<= s.instr_bank_next[i]
  
  always_ff @(posedge clk) begin : sync_
    internal_rob_head <= internal_rob_head_next;
    internal_rob_tail <= internal_rob_tail_next;
    uop1_entry <= uop1_entry_next;
    uop2_entry <= uop2_entry_next;
    for ( int unsigned i = 1'd0; i < 6'( __const__ROB_SIZE ) >> 1'd1; i += 1'd1 )
      instr_bank[4'(i)] <= instr_bank_next[4'(i)];
  end

  assign commit_out.uop1_entry = uop1_entry;
  assign commit_out.uop2_entry = uop2_entry;
  assign br_update__rdy = 1'd1;

endmodule


// PyMTL Component RampCore Definition
// Full name: RampCore__data_[Bits8(0x93), Bits8(0x02), Bits8(0x00), Bits8(0x00), Bits8(0x13), Bits8(0x03), Bits8(0x10), Bits8(0x00), Bits8(0x13), Bits8(0x04), Bits8(0x00), Bits8(0x00), Bits8(0xb3), Bits8(0x83), Bits8(0x62), Bits8(0x00), Bits8(0x93), Bits8(0x02), Bits8(0x03), Bits8(0x00), Bits8(0x13), Bits8(0x83), Bits8(0x03), Bits8(0x00), Bits8(0x23), Bits8(0x20), Bits8(0x54), Bits8(0x00), Bits8(0x13), Bits8(0x04), Bits8(0x44), Bits8(0x00), Bits8(0xe3), Bits8(0x56), Bits8(0x03), Bits8(0xfe), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00), Bits8(0x00)]__memory_size_256
// At /home/cubucher/Desktop/ramp-core/src/cl/ramp_core.py

module RampCore
(
  input  logic [0:0] clk ,
  input  logic [0:0] reset ,
  input logic [0:0] io_bus_in__en  ,
  input IOEntry__addr_32__data_32 io_bus_in__msg  ,
  output logic [0:0] io_bus_in__rdy  ,
  output logic [0:0] io_bus_out__en  ,
  output IOEntry__addr_32__data_32 io_bus_out__msg  ,
  input logic [0:0] io_bus_out__rdy  
);
  localparam logic [0:0] __const__ALU_FUNCT_UNIT  = 1'd1;
  localparam logic [1:0] __const__MEM_FUNCT_UNIT  = 2'd2;
  localparam logic [0:0] __const__R_TYPE  = 1'd1;
  //-------------------------------------------------------------
  // Component alu
  //-------------------------------------------------------------

  logic [31:0] alu__a;
  logic [31:0] alu__b;
  logic [0:0] alu__clk;
  logic [3:0] alu__op;
  logic [31:0] alu__out;
  logic [0:0] alu__reset;

  ALU__Type_Bits32 alu
  (
    .a( alu__a ),
    .b( alu__b ),
    .clk( alu__clk ),
    .op( alu__op ),
    .out( alu__out ),
    .reset( alu__reset )
  );

  //-------------------------------------------------------------
  // End of component alu
  //-------------------------------------------------------------

  //-------------------------------------------------------------
  // Component branch_issue_queue
  //-------------------------------------------------------------

  logic [63:0] branch_issue_queue__busy_table;
  logic [0:0] branch_issue_queue__clk;
  DualMicroOp__93e30b890d7542af branch_issue_queue__duop_in;
  logic [0:0] branch_issue_queue__queue_empty;
  logic [0:0] branch_issue_queue__queue_empty_next;
  logic [0:0] branch_issue_queue__queue_full;
  logic [0:0] branch_issue_queue__queue_full_next;
  logic [0:0] branch_issue_queue__reset;
  MicroOp__38e2b09b91e4b306 branch_issue_queue__uop_out;
  MicroOp__38e2b09b91e4b306 branch_issue_queue__uop_out_next;

  IssueQueue_noparam branch_issue_queue
  (
    .busy_table( branch_issue_queue__busy_table ),
    .clk( branch_issue_queue__clk ),
    .duop_in( branch_issue_queue__duop_in ),
    .queue_empty( branch_issue_queue__queue_empty ),
    .queue_empty_next( branch_issue_queue__queue_empty_next ),
    .queue_full( branch_issue_queue__queue_full ),
    .queue_full_next( branch_issue_queue__queue_full_next ),
    .reset( branch_issue_queue__reset ),
    .uop_out( branch_issue_queue__uop_out ),
    .uop_out_next( branch_issue_queue__uop_out_next )
  );

  //-------------------------------------------------------------
  // End of component branch_issue_queue
  //-------------------------------------------------------------

  //-------------------------------------------------------------
  // Component branch_unit
  //-------------------------------------------------------------

  logic [0:0] branch_unit__clk;
  logic [0:0] branch_unit__reset;
  logic [31:0] branch_unit__rs1_din;
  logic [31:0] branch_unit__rs2_din;
  MicroOp__38e2b09b91e4b306 branch_unit__uop;
  logic [0:0] branch_unit__br_update__en;
  BranchUpdate__target_32__mispredict_1__tag_3 branch_unit__br_update__msg;
  logic [0:0] branch_unit__br_update__rdy;

  BranchFU_noparam branch_unit
  (
    .clk( branch_unit__clk ),
    .reset( branch_unit__reset ),
    .rs1_din( branch_unit__rs1_din ),
    .rs2_din( branch_unit__rs2_din ),
    .uop( branch_unit__uop ),
    .br_update__en( branch_unit__br_update__en ),
    .br_update__msg( branch_unit__br_update__msg ),
    .br_update__rdy( branch_unit__br_update__rdy )
  );

  //-------------------------------------------------------------
  // End of component branch_unit
  //-------------------------------------------------------------

  //-------------------------------------------------------------
  // Component commit_unit
  //-------------------------------------------------------------

  logic [0:0] commit_unit__clk;
  ROBEntry__dfb4245d7bc69416 commit_unit__in_;
  logic [5:0] commit_unit__ready_out [0:1];
  logic [5:0] commit_unit__reg_wb_addr [0:1];
  logic [31:0] commit_unit__reg_wb_data [0:1];
  logic [0:0] commit_unit__reg_wb_en [0:1];
  logic [0:0] commit_unit__reset;
  logic [5:0] commit_unit__stale_out [0:1];
  logic [0:0] commit_unit__br_update__en;
  BranchUpdate__target_32__mispredict_1__tag_3 commit_unit__br_update__msg;
  logic [0:0] commit_unit__br_update__rdy;
  logic [0:0] commit_unit__store_out__en [0:1];
  LoadStoreEntry__op_4__addr_32__data_32__rob_idx_5__mem_q_idx_4 commit_unit__store_out__msg [0:1];
  logic [0:0] commit_unit__store_out__rdy [0:1];

  CommitUnit__width_2 commit_unit
  (
    .clk( commit_unit__clk ),
    .in_( commit_unit__in_ ),
    .ready_out( commit_unit__ready_out ),
    .reg_wb_addr( commit_unit__reg_wb_addr ),
    .reg_wb_data( commit_unit__reg_wb_data ),
    .reg_wb_en( commit_unit__reg_wb_en ),
    .reset( commit_unit__reset ),
    .stale_out( commit_unit__stale_out ),
    .br_update__en( commit_unit__br_update__en ),
    .br_update__msg( commit_unit__br_update__msg ),
    .br_update__rdy( commit_unit__br_update__rdy ),
    .store_out__en( commit_unit__store_out__en ),
    .store_out__msg( commit_unit__store_out__msg ),
    .store_out__rdy( commit_unit__store_out__rdy )
  );

  //-------------------------------------------------------------
  // End of component commit_unit
  //-------------------------------------------------------------

  //-------------------------------------------------------------
  // Component decode
  //-------------------------------------------------------------

  logic [63:0] decode__busy_table;
  logic [0:0] decode__clk;
  DualMicroOp__93e30b890d7542af decode__dual_uop;
  FetchPacket__pc_32__branch_taken_1__inst1_32__inst2_32__valid_1 decode__fetch_packet;
  logic [1:0] decode__mem_q_allocate;
  logic [5:0] decode__ready_in [0:1];
  logic [0:0] decode__reset;
  logic [5:0] decode__stale_in [0:1];
  logic [0:0] decode__br_update__en;
  BranchUpdate__target_32__mispredict_1__tag_3 decode__br_update__msg;
  logic [0:0] decode__br_update__rdy;

  Decode_noparam decode
  (
    .busy_table( decode__busy_table ),
    .clk( decode__clk ),
    .dual_uop( decode__dual_uop ),
    .fetch_packet( decode__fetch_packet ),
    .mem_q_allocate( decode__mem_q_allocate ),
    .ready_in( decode__ready_in ),
    .reset( decode__reset ),
    .stale_in( decode__stale_in ),
    .br_update__en( decode__br_update__en ),
    .br_update__msg( decode__br_update__msg ),
    .br_update__rdy( decode__br_update__rdy )
  );

  //-------------------------------------------------------------
  // End of component decode
  //-------------------------------------------------------------

  //-------------------------------------------------------------
  // Component dispatch
  //-------------------------------------------------------------

  logic [0:0] dispatch__clk;
  DualMicroOp__93e30b890d7542af dispatch__in_;
  logic [3:0] dispatch__mem_q_tail;
  logic [0:0] dispatch__reset;
  logic [4:0] dispatch__rob_idx;
  DualMicroOp__93e30b890d7542af dispatch__to_branch_issue;
  DualMicroOp__93e30b890d7542af dispatch__to_int_issue;
  DualMicroOp__93e30b890d7542af dispatch__to_mem_issue;
  DualMicroOp__93e30b890d7542af dispatch__to_rob;

  Dispatch_noparam dispatch
  (
    .clk( dispatch__clk ),
    .in_( dispatch__in_ ),
    .mem_q_tail( dispatch__mem_q_tail ),
    .reset( dispatch__reset ),
    .rob_idx( dispatch__rob_idx ),
    .to_branch_issue( dispatch__to_branch_issue ),
    .to_int_issue( dispatch__to_int_issue ),
    .to_mem_issue( dispatch__to_mem_issue ),
    .to_rob( dispatch__to_rob )
  );

  //-------------------------------------------------------------
  // End of component dispatch
  //-------------------------------------------------------------

  //-------------------------------------------------------------
  // Component fetch_stage
  //-------------------------------------------------------------

  logic [0:0] fetch_stage__clk;
  FetchPacket__pc_32__branch_taken_1__inst1_32__inst2_32__valid_1 fetch_stage__fetch_packet;
  logic [31:0] fetch_stage__pc;
  logic [0:0] fetch_stage__reset;
  logic [0:0] fetch_stage__br_update__en;
  BranchUpdate__target_32__mispredict_1__tag_3 fetch_stage__br_update__msg;
  logic [0:0] fetch_stage__br_update__rdy;

  FetchStage__9da88f92371f50f0 fetch_stage
  (
    .clk( fetch_stage__clk ),
    .fetch_packet( fetch_stage__fetch_packet ),
    .pc( fetch_stage__pc ),
    .reset( fetch_stage__reset ),
    .br_update__en( fetch_stage__br_update__en ),
    .br_update__msg( fetch_stage__br_update__msg ),
    .br_update__rdy( fetch_stage__br_update__rdy )
  );

  //-------------------------------------------------------------
  // End of component fetch_stage
  //-------------------------------------------------------------

  //-------------------------------------------------------------
  // Component int_issue_queue
  //-------------------------------------------------------------

  logic [63:0] int_issue_queue__busy_table;
  logic [0:0] int_issue_queue__clk;
  DualMicroOp__93e30b890d7542af int_issue_queue__duop_in;
  logic [0:0] int_issue_queue__queue_empty;
  logic [0:0] int_issue_queue__queue_empty_next;
  logic [0:0] int_issue_queue__queue_full;
  logic [0:0] int_issue_queue__queue_full_next;
  logic [0:0] int_issue_queue__reset;
  MicroOp__38e2b09b91e4b306 int_issue_queue__uop_out;
  MicroOp__38e2b09b91e4b306 int_issue_queue__uop_out_next;

  IssueQueue_noparam int_issue_queue
  (
    .busy_table( int_issue_queue__busy_table ),
    .clk( int_issue_queue__clk ),
    .duop_in( int_issue_queue__duop_in ),
    .queue_empty( int_issue_queue__queue_empty ),
    .queue_empty_next( int_issue_queue__queue_empty_next ),
    .queue_full( int_issue_queue__queue_full ),
    .queue_full_next( int_issue_queue__queue_full_next ),
    .reset( int_issue_queue__reset ),
    .uop_out( int_issue_queue__uop_out ),
    .uop_out_next( int_issue_queue__uop_out_next )
  );

  //-------------------------------------------------------------
  // End of component int_issue_queue
  //-------------------------------------------------------------

  //-------------------------------------------------------------
  // Component load_store_unit
  //-------------------------------------------------------------

  logic [0:0] load_store_unit__clk;
  logic [0:0] load_store_unit__enable;
  logic [3:0] load_store_unit__funct;
  logic [31:0] load_store_unit__imm_in;
  logic [3:0] load_store_unit__mem_q_idx_in;
  logic [5:0] load_store_unit__prd_addr_in;
  logic [0:0] load_store_unit__reset;
  logic [4:0] load_store_unit__rob_idx_in;
  logic [31:0] load_store_unit__rs1_din;
  logic [31:0] load_store_unit__rs2_din;
  logic [0:0] load_store_unit__load_out__en;
  LoadStoreEntry__op_4__addr_32__data_32__rob_idx_5__mem_q_idx_4 load_store_unit__load_out__msg;
  logic [0:0] load_store_unit__load_out__rdy;
  logic [0:0] load_store_unit__store_out__en;
  LoadStoreEntry__op_4__addr_32__data_32__rob_idx_5__mem_q_idx_4 load_store_unit__store_out__msg;
  logic [0:0] load_store_unit__store_out__rdy;

  LoadStoreFU_noparam load_store_unit
  (
    .clk( load_store_unit__clk ),
    .enable( load_store_unit__enable ),
    .funct( load_store_unit__funct ),
    .imm_in( load_store_unit__imm_in ),
    .mem_q_idx_in( load_store_unit__mem_q_idx_in ),
    .prd_addr_in( load_store_unit__prd_addr_in ),
    .reset( load_store_unit__reset ),
    .rob_idx_in( load_store_unit__rob_idx_in ),
    .rs1_din( load_store_unit__rs1_din ),
    .rs2_din( load_store_unit__rs2_din ),
    .load_out__en( load_store_unit__load_out__en ),
    .load_out__msg( load_store_unit__load_out__msg ),
    .load_out__rdy( load_store_unit__load_out__rdy ),
    .store_out__en( load_store_unit__store_out__en ),
    .store_out__msg( load_store_unit__store_out__msg ),
    .store_out__rdy( load_store_unit__store_out__rdy )
  );

  //-------------------------------------------------------------
  // End of component load_store_unit
  //-------------------------------------------------------------

  //-------------------------------------------------------------
  // Component mem_issue_queue
  //-------------------------------------------------------------

  logic [63:0] mem_issue_queue__busy_table;
  logic [0:0] mem_issue_queue__clk;
  DualMicroOp__93e30b890d7542af mem_issue_queue__duop_in;
  logic [0:0] mem_issue_queue__queue_empty;
  logic [0:0] mem_issue_queue__queue_empty_next;
  logic [0:0] mem_issue_queue__queue_full;
  logic [0:0] mem_issue_queue__queue_full_next;
  logic [0:0] mem_issue_queue__reset;
  MicroOp__38e2b09b91e4b306 mem_issue_queue__uop_out;
  MicroOp__38e2b09b91e4b306 mem_issue_queue__uop_out_next;

  IssueQueue_noparam mem_issue_queue
  (
    .busy_table( mem_issue_queue__busy_table ),
    .clk( mem_issue_queue__clk ),
    .duop_in( mem_issue_queue__duop_in ),
    .queue_empty( mem_issue_queue__queue_empty ),
    .queue_empty_next( mem_issue_queue__queue_empty_next ),
    .queue_full( mem_issue_queue__queue_full ),
    .queue_full_next( mem_issue_queue__queue_full_next ),
    .reset( mem_issue_queue__reset ),
    .uop_out( mem_issue_queue__uop_out ),
    .uop_out_next( mem_issue_queue__uop_out_next )
  );

  //-------------------------------------------------------------
  // End of component mem_issue_queue
  //-------------------------------------------------------------

  //-------------------------------------------------------------
  // Component memory_unit
  //-------------------------------------------------------------

  logic [0:0] memory_unit__clk;
  logic [3:0] memory_unit__mem_q_tail;
  logic [0:0] memory_unit__reset;
  logic [0:0] memory_unit__allocate_in__en;
  logic [1:0] memory_unit__allocate_in__msg;
  logic [0:0] memory_unit__allocate_in__rdy;
  logic [0:0] memory_unit__io_bus_in__en;
  IOEntry__addr_32__data_32 memory_unit__io_bus_in__msg;
  logic [0:0] memory_unit__io_bus_in__rdy;
  logic [0:0] memory_unit__io_bus_out__en;
  IOEntry__addr_32__data_32 memory_unit__io_bus_out__msg;
  logic [0:0] memory_unit__io_bus_out__rdy;
  logic [0:0] memory_unit__load_out__en;
  LoadEntry__data_32__rob_idx_5 memory_unit__load_out__msg;
  logic [0:0] memory_unit__load_out__rdy;
  logic [0:0] memory_unit__update_in__en [0:2];
  LoadStoreEntry__op_4__addr_32__data_32__rob_idx_5__mem_q_idx_4 memory_unit__update_in__msg [0:2];
  logic [0:0] memory_unit__update_in__rdy [0:2];

  MemoryUnit__b480461cc1d009b8 memory_unit
  (
    .clk( memory_unit__clk ),
    .mem_q_tail( memory_unit__mem_q_tail ),
    .reset( memory_unit__reset ),
    .allocate_in__en( memory_unit__allocate_in__en ),
    .allocate_in__msg( memory_unit__allocate_in__msg ),
    .allocate_in__rdy( memory_unit__allocate_in__rdy ),
    .io_bus_in__en( memory_unit__io_bus_in__en ),
    .io_bus_in__msg( memory_unit__io_bus_in__msg ),
    .io_bus_in__rdy( memory_unit__io_bus_in__rdy ),
    .io_bus_out__en( memory_unit__io_bus_out__en ),
    .io_bus_out__msg( memory_unit__io_bus_out__msg ),
    .io_bus_out__rdy( memory_unit__io_bus_out__rdy ),
    .load_out__en( memory_unit__load_out__en ),
    .load_out__msg( memory_unit__load_out__msg ),
    .load_out__rdy( memory_unit__load_out__rdy ),
    .update_in__en( memory_unit__update_in__en ),
    .update_in__msg( memory_unit__update_in__msg ),
    .update_in__rdy( memory_unit__update_in__rdy )
  );

  //-------------------------------------------------------------
  // End of component memory_unit
  //-------------------------------------------------------------

  //-------------------------------------------------------------
  // Component pr1
  //-------------------------------------------------------------

  logic [0:0] pr1__clk;
  logic [0:0] pr1__en;
  FetchPacket__pc_32__branch_taken_1__inst1_32__inst2_32__valid_1 pr1__in_;
  FetchPacket__pc_32__branch_taken_1__inst1_32__inst2_32__valid_1 pr1__out;
  logic [0:0] pr1__reset;

  RegEnRst__52ba0effba855e7c pr1
  (
    .clk( pr1__clk ),
    .en( pr1__en ),
    .in_( pr1__in_ ),
    .out( pr1__out ),
    .reset( pr1__reset )
  );

  //-------------------------------------------------------------
  // End of component pr1
  //-------------------------------------------------------------

  //-------------------------------------------------------------
  // Component pr2
  //-------------------------------------------------------------

  logic [0:0] pr2__clk;
  logic [0:0] pr2__en;
  DualMicroOp__93e30b890d7542af pr2__in_;
  DualMicroOp__93e30b890d7542af pr2__out;
  logic [0:0] pr2__reset;

  RegEnRst__f6b304c6c5a627a4 pr2
  (
    .clk( pr2__clk ),
    .en( pr2__en ),
    .in_( pr2__in_ ),
    .out( pr2__out ),
    .reset( pr2__reset )
  );

  //-------------------------------------------------------------
  // End of component pr2
  //-------------------------------------------------------------

  //-------------------------------------------------------------
  // Component register_file
  //-------------------------------------------------------------

  logic [0:0] register_file__clk;
  logic [5:0] register_file__raddr [0:5];
  logic [31:0] register_file__rdata [0:5];
  logic [0:0] register_file__reset;
  logic [5:0] register_file__waddr [0:1];
  logic [31:0] register_file__wdata [0:1];
  logic [0:0] register_file__wen [0:1];

  RegisterFile__d5a8eae0540cd56b register_file
  (
    .clk( register_file__clk ),
    .raddr( register_file__raddr ),
    .rdata( register_file__rdata ),
    .reset( register_file__reset ),
    .waddr( register_file__waddr ),
    .wdata( register_file__wdata ),
    .wen( register_file__wen )
  );

  //-------------------------------------------------------------
  // End of component register_file
  //-------------------------------------------------------------

  //-------------------------------------------------------------
  // Component reorder_buffer
  //-------------------------------------------------------------

  logic [0:0] reorder_buffer__bank_empty;
  logic [0:0] reorder_buffer__bank_full;
  logic [0:0] reorder_buffer__clk;
  ROBEntry__dfb4245d7bc69416 reorder_buffer__commit_out;
  ExecToROB__894aaf470679b4c5 reorder_buffer__op_complete;
  logic [0:0] reorder_buffer__reset;
  logic [4:0] reorder_buffer__rob_tail;
  DualMicroOp__93e30b890d7542af reorder_buffer__write_in;
  logic [0:0] reorder_buffer__br_update__en;
  BranchUpdate__target_32__mispredict_1__tag_3 reorder_buffer__br_update__msg;
  logic [0:0] reorder_buffer__br_update__rdy;

  ReorderBuffer_noparam reorder_buffer
  (
    .bank_empty( reorder_buffer__bank_empty ),
    .bank_full( reorder_buffer__bank_full ),
    .clk( reorder_buffer__clk ),
    .commit_out( reorder_buffer__commit_out ),
    .op_complete( reorder_buffer__op_complete ),
    .reset( reorder_buffer__reset ),
    .rob_tail( reorder_buffer__rob_tail ),
    .write_in( reorder_buffer__write_in ),
    .br_update__en( reorder_buffer__br_update__en ),
    .br_update__msg( reorder_buffer__br_update__msg ),
    .br_update__rdy( reorder_buffer__br_update__rdy )
  );

  //-------------------------------------------------------------
  // End of component reorder_buffer
  //-------------------------------------------------------------

  // PyMTL Update Block Source
  // At /home/cubucher/Desktop/ramp-core/src/cl/ramp_core.py:176
  // @update
  // def update_cntrl():
  //     s.pr1.en @= ~s.reset
  //     s.pr2.en @= ~s.reset
  // 
  //     s.reorder_buffer.op_complete.int_rob_complete @= (
  //         s.int_issue_queue.uop_out.funct_unit == ALU_FUNCT_UNIT
  //     )
  //     s.load_store_unit.enable @= (
  //         s.mem_issue_queue.uop_out.funct_unit == MEM_FUNCT_UNIT
  //     )
  //     # Immediate logic
  //     if s.int_issue_queue.uop_out.optype != R_TYPE:
  //         s.alu.b @= s.int_issue_queue.uop_out.imm
  //     else:
  //         s.alu.b @= s.register_file.rdata[1]
  // 
  //     # # branch outcome logic
  //     # s.branch_unit.br_update.rdy @= (
  //     #     s.fetch_stage.br_update.rdy &
  //     #     s.decode.br_update.rdy &
  //     #     s.reorder_buffer.br_update.rdy
  //     # )
  
  always_comb begin : update_cntrl
    pr1__en = ~reset;
    pr2__en = ~reset;
    reorder_buffer__op_complete.int_rob_complete = int_issue_queue__uop_out.funct_unit == 2'( __const__ALU_FUNCT_UNIT );
    load_store_unit__enable = mem_issue_queue__uop_out.funct_unit == 2'( __const__MEM_FUNCT_UNIT );
    if ( int_issue_queue__uop_out.optype != 3'( __const__R_TYPE ) ) begin
      alu__b = int_issue_queue__uop_out.imm;
    end
    else
      alu__b = register_file__rdata[3'd1];
  end

  assign fetch_stage__clk = clk;
  assign fetch_stage__reset = reset;
  assign pr1__clk = clk;
  assign pr1__reset = reset;
  assign pr1__in_ = fetch_stage__fetch_packet;
  assign decode__clk = clk;
  assign decode__reset = reset;
  assign decode__fetch_packet = pr1__out;
  assign pr2__clk = clk;
  assign pr2__reset = reset;
  assign pr2__in_ = decode__dual_uop;
  assign dispatch__clk = clk;
  assign dispatch__reset = reset;
  assign dispatch__in_ = pr2__out;
  assign reorder_buffer__clk = clk;
  assign reorder_buffer__reset = reset;
  assign reorder_buffer__write_in = dispatch__to_rob;
  assign dispatch__rob_idx = reorder_buffer__rob_tail;
  assign int_issue_queue__clk = clk;
  assign int_issue_queue__reset = reset;
  assign int_issue_queue__duop_in = dispatch__to_int_issue;
  assign int_issue_queue__busy_table = decode__busy_table;
  assign mem_issue_queue__clk = clk;
  assign mem_issue_queue__reset = reset;
  assign mem_issue_queue__duop_in = dispatch__to_mem_issue;
  assign mem_issue_queue__busy_table = decode__busy_table;
  assign branch_issue_queue__clk = clk;
  assign branch_issue_queue__reset = reset;
  assign branch_issue_queue__duop_in = dispatch__to_branch_issue;
  assign branch_issue_queue__busy_table = decode__busy_table;
  assign register_file__clk = clk;
  assign register_file__reset = reset;
  assign register_file__raddr[0] = int_issue_queue__uop_out.prs1;
  assign register_file__raddr[1] = int_issue_queue__uop_out.prs2;
  assign register_file__raddr[2] = mem_issue_queue__uop_out.prs1;
  assign register_file__raddr[3] = mem_issue_queue__uop_out.prs2;
  assign register_file__raddr[4] = branch_issue_queue__uop_out.prs1;
  assign register_file__raddr[5] = branch_issue_queue__uop_out.prs2;
  assign alu__clk = clk;
  assign alu__reset = reset;
  assign alu__a = register_file__rdata[0];
  assign alu__op = int_issue_queue__uop_out.funct_op;
  assign load_store_unit__clk = clk;
  assign load_store_unit__reset = reset;
  assign load_store_unit__rs1_din = register_file__rdata[2];
  assign load_store_unit__rs2_din = register_file__rdata[3];
  assign load_store_unit__prd_addr_in = mem_issue_queue__uop_out.prd;
  assign load_store_unit__imm_in = mem_issue_queue__uop_out.imm;
  assign load_store_unit__rob_idx_in = mem_issue_queue__uop_out.rob_idx;
  assign load_store_unit__mem_q_idx_in = mem_issue_queue__uop_out.mem_q_idx;
  assign load_store_unit__funct = mem_issue_queue__uop_out.funct_op;
  assign branch_unit__clk = clk;
  assign branch_unit__reset = reset;
  assign branch_unit__rs1_din = register_file__rdata[4];
  assign branch_unit__rs2_din = register_file__rdata[5];
  assign branch_unit__uop = branch_issue_queue__uop_out;
  assign commit_unit__clk = clk;
  assign commit_unit__reset = reset;
  assign commit_unit__in_ = reorder_buffer__commit_out;
  assign register_file__waddr[0] = commit_unit__reg_wb_addr[0];
  assign register_file__wdata[0] = commit_unit__reg_wb_data[0];
  assign register_file__wen[0] = commit_unit__reg_wb_en[0];
  assign decode__stale_in[0] = commit_unit__stale_out[0];
  assign decode__ready_in[0] = commit_unit__ready_out[0];
  assign register_file__waddr[1] = commit_unit__reg_wb_addr[1];
  assign register_file__wdata[1] = commit_unit__reg_wb_data[1];
  assign register_file__wen[1] = commit_unit__reg_wb_en[1];
  assign decode__stale_in[1] = commit_unit__stale_out[1];
  assign decode__ready_in[1] = commit_unit__ready_out[1];
  assign commit_unit__br_update__rdy = 1'd1;
  assign fetch_stage__br_update__msg = commit_unit__br_update__msg;
  assign fetch_stage__br_update__en = commit_unit__br_update__en;
  assign decode__br_update__msg = commit_unit__br_update__msg;
  assign decode__br_update__en = commit_unit__br_update__en;
  assign reorder_buffer__br_update__msg = commit_unit__br_update__msg;
  assign reorder_buffer__br_update__en = commit_unit__br_update__en;
  assign memory_unit__clk = clk;
  assign memory_unit__reset = reset;
  assign memory_unit__allocate_in__msg = decode__mem_q_allocate;
  assign memory_unit__allocate_in__en = 1'd1;
  assign memory_unit__update_in__en[0] = load_store_unit__load_out__en;
  assign memory_unit__update_in__msg[0] = load_store_unit__load_out__msg;
  assign load_store_unit__load_out__rdy = memory_unit__update_in__rdy[0];
  assign memory_unit__update_in__en[1] = commit_unit__store_out__en[0];
  assign memory_unit__update_in__msg[1] = commit_unit__store_out__msg[0];
  assign commit_unit__store_out__rdy[0] = memory_unit__update_in__rdy[1];
  assign memory_unit__update_in__en[2] = commit_unit__store_out__en[1];
  assign memory_unit__update_in__msg[2] = commit_unit__store_out__msg[1];
  assign commit_unit__store_out__rdy[1] = memory_unit__update_in__rdy[2];
  assign dispatch__mem_q_tail = memory_unit__mem_q_tail;
  assign memory_unit__io_bus_in__en = io_bus_in__en;
  assign memory_unit__io_bus_in__msg = io_bus_in__msg;
  assign io_bus_in__rdy = memory_unit__io_bus_in__rdy;
  assign io_bus_out__en = memory_unit__io_bus_out__en;
  assign io_bus_out__msg = memory_unit__io_bus_out__msg;
  assign memory_unit__io_bus_out__rdy = io_bus_out__rdy;
  assign reorder_buffer__op_complete.int_rob_idx = int_issue_queue__uop_out.rob_idx;
  assign reorder_buffer__op_complete.int_data = alu__out;
  assign reorder_buffer__op_complete.store_rob_idx = load_store_unit__store_out__msg.rob_idx;
  assign reorder_buffer__op_complete.store_data = load_store_unit__store_out__msg.data;
  assign reorder_buffer__op_complete.store_addr = load_store_unit__store_out__msg.addr;
  assign reorder_buffer__op_complete.store_rob_complete = load_store_unit__store_out__en;
  assign reorder_buffer__op_complete.store_mem_q_idx = load_store_unit__store_out__msg.mem_q_idx;
  assign reorder_buffer__op_complete.load_rob_idx = memory_unit__load_out__msg.rob_idx;
  assign reorder_buffer__op_complete.load_data = memory_unit__load_out__msg.data;
  assign reorder_buffer__op_complete.load_rob_complete = memory_unit__load_out__en;
  assign reorder_buffer__op_complete.br_rob_idx = branch_issue_queue__uop_out.rob_idx;
  assign reorder_buffer__op_complete.br_rob_complete = branch_unit__br_update__en;
  assign reorder_buffer__op_complete.br_mispredict = branch_unit__br_update__msg.mispredict;
  assign reorder_buffer__op_complete.br_target = branch_unit__br_update__msg.target;
  assign reorder_buffer__op_complete.br_tag = branch_unit__br_update__msg.tag;

endmodule
